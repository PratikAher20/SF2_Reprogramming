
demo_MSS_CM3_app:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  20000000  20000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .boot_code    00000330  20000190  20000190  00008190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00004c40  200004c0  200004c0  000084c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000150  20005100  20005100  0000d100  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00003430  20005250  20005250  0000d250  2**4
                  ALLOC
  5 .heap         00006980  20008680  20008680  0000d250  2**4
                  ALLOC
  6 .stack        00001000  2000f000  2000f000  0000d250  2**4
                  ALLOC
  7 .comment      00000158  00000000  00000000  0000d250  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 000006f0  00000000  00000000  0000d3a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000011db  00000000  00000000  0000da98  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000908c  00000000  00000000  0000ec73  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00000f7b  00000000  00000000  00017cff  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000034a1  00000000  00000000  00018c7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000019e0  00000000  00000000  0001c11c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00003554  00000000  00000000  0001dafc  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00002a24  00000000  00000000  00021050  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 00041166  00000000  00000000  00023a74  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .ARM.attributes 00000025  00000000  00000000  00064bda  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 00000730  00000000  00000000  00064bff  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .vector_table:

20000000 <__vector_table_start>:
20000000:	20010000 	.word	0x20010000
20000004:	20000191 	.word	0x20000191
20000008:	2000037f 	.word	0x2000037f
2000000c:	20000381 	.word	0x20000381
20000010:	20000383 	.word	0x20000383
20000014:	20000385 	.word	0x20000385
20000018:	20000387 	.word	0x20000387
	...
2000002c:	20000389 	.word	0x20000389
20000030:	2000038b 	.word	0x2000038b
20000034:	00000000 	.word	0x00000000
20000038:	2000038d 	.word	0x2000038d
2000003c:	2000038f 	.word	0x2000038f
20000040:	20000391 	.word	0x20000391
20000044:	20000393 	.word	0x20000393
20000048:	200039d5 	.word	0x200039d5
2000004c:	200039f9 	.word	0x200039f9
20000050:	20000399 	.word	0x20000399
20000054:	2000039b 	.word	0x2000039b
20000058:	2000039d 	.word	0x2000039d
2000005c:	2000039f 	.word	0x2000039f
20000060:	200003a1 	.word	0x200003a1
20000064:	200003a3 	.word	0x200003a3
20000068:	200017d9 	.word	0x200017d9
2000006c:	200017fd 	.word	0x200017fd
20000070:	200003a9 	.word	0x200003a9
20000074:	200003ab 	.word	0x200003ab
20000078:	200003ad 	.word	0x200003ad
2000007c:	200003af 	.word	0x200003af
20000080:	200003b1 	.word	0x200003b1
20000084:	200003b3 	.word	0x200003b3
20000088:	200003b5 	.word	0x200003b5
2000008c:	20004231 	.word	0x20004231
20000090:	200003b9 	.word	0x200003b9
20000094:	200003bb 	.word	0x200003bb
20000098:	200003bd 	.word	0x200003bd
2000009c:	200003bf 	.word	0x200003bf
200000a0:	200003c1 	.word	0x200003c1
200000a4:	200003c3 	.word	0x200003c3
200000a8:	200003c5 	.word	0x200003c5
200000ac:	200003c7 	.word	0x200003c7
200000b0:	200003c9 	.word	0x200003c9
200000b4:	200003cb 	.word	0x200003cb
200000b8:	200003cd 	.word	0x200003cd
200000bc:	200003cf 	.word	0x200003cf
200000c0:	200003d1 	.word	0x200003d1
200000c4:	200003d3 	.word	0x200003d3
200000c8:	200003d5 	.word	0x200003d5
200000cc:	200003d7 	.word	0x200003d7
200000d0:	200003d9 	.word	0x200003d9
200000d4:	200003db 	.word	0x200003db
200000d8:	200003dd 	.word	0x200003dd
200000dc:	200003df 	.word	0x200003df
200000e0:	200003e1 	.word	0x200003e1
200000e4:	200003e3 	.word	0x200003e3
200000e8:	200003e5 	.word	0x200003e5
200000ec:	200003e7 	.word	0x200003e7
200000f0:	200003e9 	.word	0x200003e9
200000f4:	200003eb 	.word	0x200003eb
200000f8:	200003ed 	.word	0x200003ed
200000fc:	200003ef 	.word	0x200003ef
20000100:	200003f1 	.word	0x200003f1
20000104:	200003f3 	.word	0x200003f3
20000108:	200003f5 	.word	0x200003f5
2000010c:	200003f7 	.word	0x200003f7
20000110:	200003f9 	.word	0x200003f9
20000114:	200003fb 	.word	0x200003fb
20000118:	200003fd 	.word	0x200003fd
2000011c:	200003ff 	.word	0x200003ff
20000120:	20000401 	.word	0x20000401
20000124:	20000403 	.word	0x20000403
20000128:	20000405 	.word	0x20000405
2000012c:	20000407 	.word	0x20000407
20000130:	20000409 	.word	0x20000409
20000134:	2000040b 	.word	0x2000040b
20000138:	2000040d 	.word	0x2000040d
2000013c:	2000040f 	.word	0x2000040f
20000140:	20000411 	.word	0x20000411
20000144:	20000413 	.word	0x20000413
20000148:	20000415 	.word	0x20000415
2000014c:	20000417 	.word	0x20000417
20000150:	20000419 	.word	0x20000419
20000154:	2000041b 	.word	0x2000041b
20000158:	2000041d 	.word	0x2000041d
2000015c:	2000041f 	.word	0x2000041f
20000160:	20000421 	.word	0x20000421
20000164:	20000423 	.word	0x20000423
20000168:	20000425 	.word	0x20000425
2000016c:	20000427 	.word	0x20000427
20000170:	20000429 	.word	0x20000429
20000174:	2000042b 	.word	0x2000042b
20000178:	2000042d 	.word	0x2000042d
2000017c:	2000042f 	.word	0x2000042f
20000180:	20000431 	.word	0x20000431
20000184:	20000433 	.word	0x20000433
	...

Disassembly of section .boot_code:

20000190 <Reset_Handler>:
20000190:	f04f 0b00 	mov.w	fp, #0
20000194:	f8df 02be 	ldr.w	r0, [pc, #702]	; 20000456 <SF2_MDDR_MODE_CR>
20000198:	6800      	ldr	r0, [r0, #0]
2000019a:	f8df 12b6 	ldr.w	r1, [pc, #694]	; 20000452 <SF2_EDAC_CR>
2000019e:	6809      	ldr	r1, [r1, #0]
200001a0:	f001 0103 	and.w	r1, r1, #3
200001a4:	f000 001c 	and.w	r0, r0, #28
200001a8:	2814      	cmp	r0, #20
200001aa:	d101      	bne.n	200001b0 <check_esram_edac>
200001ac:	f04b 0b02 	orr.w	fp, fp, #2

200001b0 <check_esram_edac>:
200001b0:	2900      	cmp	r1, #0
200001b2:	d001      	beq.n	200001b8 <check_stack_init>
200001b4:	f04b 0b01 	orr.w	fp, fp, #1

200001b8 <check_stack_init>:
200001b8:	f1bb 0f00 	cmp.w	fp, #0
200001bc:	d005      	beq.n	200001ca <system_init>

200001be <clear_stack>:
200001be:	48a7      	ldr	r0, [pc, #668]	; (2000045c <SF2_MDDR_MODE_CR+0x6>)
200001c0:	49a7      	ldr	r1, [pc, #668]	; (20000460 <SF2_MDDR_MODE_CR+0xa>)
200001c2:	f8df 2272 	ldr.w	r2, [pc, #626]	; 20000436 <RAM_INIT_PATTERN>
200001c6:	f000 f89f 	bl	20000308 <fill_memory>

200001ca <system_init>:
200001ca:	48a6      	ldr	r0, [pc, #664]	; (20000464 <SF2_MDDR_MODE_CR+0xe>)
200001cc:	4780      	blx	r0
200001ce:	f00b 0a02 	and.w	sl, fp, #2
200001d2:	f1ba 0f00 	cmp.w	sl, #0
200001d6:	d00c      	beq.n	200001f2 <remap_memory>
200001d8:	f8df 026e 	ldr.w	r0, [pc, #622]	; 2000044a <SF2_DDRB_NB_SIZE>
200001dc:	f8df 126e 	ldr.w	r1, [pc, #622]	; 2000044e <SF2_DDRB_CR>
200001e0:	6802      	ldr	r2, [r0, #0]
200001e2:	680b      	ldr	r3, [r1, #0]
200001e4:	b40f      	push	{r0, r1, r2, r3}
200001e6:	f04f 0200 	mov.w	r2, #0
200001ea:	f04f 03ff 	mov.w	r3, #255	; 0xff
200001ee:	6002      	str	r2, [r0, #0]
200001f0:	600b      	str	r3, [r1, #0]

200001f2 <remap_memory>:
200001f2:	489d      	ldr	r0, [pc, #628]	; (20000468 <SF2_MDDR_MODE_CR+0x12>)
200001f4:	4a9d      	ldr	r2, [pc, #628]	; (2000046c <SF2_MDDR_MODE_CR+0x16>)
200001f6:	4b9e      	ldr	r3, [pc, #632]	; (20000470 <SF2_MDDR_MODE_CR+0x1a>)
200001f8:	2802      	cmp	r0, #2
200001fa:	d108      	bne.n	2000020e <check_esram_remap>
200001fc:	f8df 123e 	ldr.w	r1, [pc, #574]	; 2000043e <SF2_ESRAM_CR>
20000200:	600a      	str	r2, [r1, #0]
20000202:	f8df 1242 	ldr.w	r1, [pc, #578]	; 20000446 <SF2_ENVM_REMAP_CR>
20000206:	600a      	str	r2, [r1, #0]
20000208:	f8df 1236 	ldr.w	r1, [pc, #566]	; 20000442 <SF2_DDR_CR>
2000020c:	600b      	str	r3, [r1, #0]

2000020e <check_esram_remap>:
2000020e:	2801      	cmp	r0, #1
20000210:	d108      	bne.n	20000224 <check_mirrored_nvm>
20000212:	f8df 122e 	ldr.w	r1, [pc, #558]	; 20000442 <SF2_DDR_CR>
20000216:	600a      	str	r2, [r1, #0]
20000218:	f8df 122a 	ldr.w	r1, [pc, #554]	; 20000446 <SF2_ENVM_REMAP_CR>
2000021c:	600a      	str	r2, [r1, #0]
2000021e:	f8df 121e 	ldr.w	r1, [pc, #542]	; 2000043e <SF2_ESRAM_CR>
20000222:	600b      	str	r3, [r1, #0]

20000224 <check_mirrored_nvm>:
20000224:	4893      	ldr	r0, [pc, #588]	; (20000474 <SF2_MDDR_MODE_CR+0x1e>)
20000226:	2800      	cmp	r0, #0
20000228:	d109      	bne.n	2000023e <copy_data>
2000022a:	4893      	ldr	r0, [pc, #588]	; (20000478 <SF2_MDDR_MODE_CR+0x22>)
2000022c:	4993      	ldr	r1, [pc, #588]	; (2000047c <SF2_MDDR_MODE_CR+0x26>)
2000022e:	4a94      	ldr	r2, [pc, #592]	; (20000480 <SF2_MDDR_MODE_CR+0x2a>)
20000230:	f000 f832 	bl	20000298 <block_copy>

20000234 <copy_text>:
20000234:	4893      	ldr	r0, [pc, #588]	; (20000484 <SF2_MDDR_MODE_CR+0x2e>)
20000236:	4994      	ldr	r1, [pc, #592]	; (20000488 <SF2_MDDR_MODE_CR+0x32>)
20000238:	4a94      	ldr	r2, [pc, #592]	; (2000048c <SF2_MDDR_MODE_CR+0x36>)
2000023a:	f000 f82d 	bl	20000298 <block_copy>

2000023e <copy_data>:
2000023e:	4894      	ldr	r0, [pc, #592]	; (20000490 <SF2_MDDR_MODE_CR+0x3a>)
20000240:	4994      	ldr	r1, [pc, #592]	; (20000494 <SF2_MDDR_MODE_CR+0x3e>)
20000242:	4a95      	ldr	r2, [pc, #596]	; (20000498 <SF2_MDDR_MODE_CR+0x42>)
20000244:	f000 f828 	bl	20000298 <block_copy>

20000248 <clear_bss>:
20000248:	4894      	ldr	r0, [pc, #592]	; (2000049c <SF2_MDDR_MODE_CR+0x46>)
2000024a:	4995      	ldr	r1, [pc, #596]	; (200004a0 <SF2_MDDR_MODE_CR+0x4a>)
2000024c:	f8df 21e6 	ldr.w	r2, [pc, #486]	; 20000436 <RAM_INIT_PATTERN>
20000250:	f000 f85a 	bl	20000308 <fill_memory>

20000254 <clear_heap>:
20000254:	f1bb 0f00 	cmp.w	fp, #0
20000258:	d012      	beq.n	20000280 <call_glob_ctor>
2000025a:	4892      	ldr	r0, [pc, #584]	; (200004a4 <SF2_MDDR_MODE_CR+0x4e>)
2000025c:	4992      	ldr	r1, [pc, #584]	; (200004a8 <SF2_MDDR_MODE_CR+0x52>)
2000025e:	f8df 21da 	ldr.w	r2, [pc, #474]	; 2000043a <HEAP_INIT_PATTERN>
20000262:	f000 f851 	bl	20000308 <fill_memory>
20000266:	f00b 0a02 	and.w	sl, fp, #2
2000026a:	f1ba 0f00 	cmp.w	sl, #0
2000026e:	d007      	beq.n	20000280 <call_glob_ctor>
20000270:	bc0f      	pop	{r0, r1, r2, r3}
20000272:	6002      	str	r2, [r0, #0]
20000274:	600b      	str	r3, [r1, #0]
20000276:	bf00      	nop
20000278:	f3af 8000 	nop.w
2000027c:	f3af 8000 	nop.w

20000280 <call_glob_ctor>:
20000280:	f8df 0228 	ldr.w	r0, [pc, #552]	; 200004ac <SF2_MDDR_MODE_CR+0x56>
20000284:	f20f 0e03 	addw	lr, pc, #3
20000288:	4700      	bx	r0

2000028a <branch_to_main>:
2000028a:	f04f 0000 	mov.w	r0, #0
2000028e:	f04f 0100 	mov.w	r1, #0
20000292:	f8df f21c 	ldr.w	pc, [pc, #540]	; 200004b0 <SF2_MDDR_MODE_CR+0x5a>

20000296 <ExitLoop>:
20000296:	e7fe      	b.n	20000296 <ExitLoop>

20000298 <block_copy>:
20000298:	e92d 41f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, lr}
2000029c:	4288      	cmp	r0, r1
2000029e:	d025      	beq.n	200002ec <block_copy_exit>
200002a0:	ebb2 0201 	subs.w	r2, r2, r1
200002a4:	d500      	bpl.n	200002a8 <block_copy_address_ok>
200002a6:	e7fe      	b.n	200002a6 <block_copy+0xe>

200002a8 <block_copy_address_ok>:
200002a8:	ea40 0301 	orr.w	r3, r0, r1
200002ac:	f013 0303 	ands.w	r3, r3, #3
200002b0:	d002      	beq.n	200002b8 <block_copy_continue>

200002b2 <block_copy_byte_copy>:
200002b2:	f000 f81d 	bl	200002f0 <block_copy_byte>
200002b6:	e019      	b.n	200002ec <block_copy_exit>

200002b8 <block_copy_continue>:
200002b8:	f04f 0300 	mov.w	r3, #0
200002bc:	4690      	mov	r8, r2
200002be:	1112      	asrs	r2, r2, #4
200002c0:	d0f7      	beq.n	200002b2 <block_copy_byte_copy>

200002c2 <block_copy_loop>:
200002c2:	429a      	cmp	r2, r3
200002c4:	bf1c      	itt	ne
200002c6:	c8f0      	ldmiane	r0!, {r4, r5, r6, r7}
200002c8:	c1f0      	stmiane	r1!, {r4, r5, r6, r7}
200002ca:	f103 0301 	add.w	r3, r3, #1
200002ce:	d1f8      	bne.n	200002c2 <block_copy_loop>
200002d0:	f008 080f 	and.w	r8, r8, #15
200002d4:	f1b8 0f00 	cmp.w	r8, #0
200002d8:	d008      	beq.n	200002ec <block_copy_exit>

200002da <copy_spare_bytes>:
200002da:	7804      	ldrb	r4, [r0, #0]
200002dc:	700c      	strb	r4, [r1, #0]
200002de:	f100 0001 	add.w	r0, r0, #1
200002e2:	f101 0101 	add.w	r1, r1, #1
200002e6:	f1b8 0801 	subs.w	r8, r8, #1
200002ea:	d1f6      	bne.n	200002da <copy_spare_bytes>

200002ec <block_copy_exit>:
200002ec:	e8bd 81f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, pc}

200002f0 <block_copy_byte>:
200002f0:	b508      	push	{r3, lr}
200002f2:	f04f 0300 	mov.w	r3, #0

200002f6 <block_copy_byte_loop>:
200002f6:	7803      	ldrb	r3, [r0, #0]
200002f8:	700b      	strb	r3, [r1, #0]
200002fa:	f100 0001 	add.w	r0, r0, #1
200002fe:	f101 0101 	add.w	r1, r1, #1
20000302:	3a01      	subs	r2, #1
20000304:	d1f7      	bne.n	200002f6 <block_copy_byte_loop>
20000306:	bd08      	pop	{r3, pc}

20000308 <fill_memory>:
20000308:	4288      	cmp	r0, r1
2000030a:	d037      	beq.n	2000037c <fill_memory_exit>
2000030c:	f000 0603 	and.w	r6, r0, #3
20000310:	2e00      	cmp	r6, #0
20000312:	d014      	beq.n	2000033e <fill_memory_end_start>
20000314:	f04f 0504 	mov.w	r5, #4
20000318:	eba5 0406 	sub.w	r4, r5, r6
2000031c:	f04f 0708 	mov.w	r7, #8
20000320:	fb07 f806 	mul.w	r8, r7, r6
20000324:	4691      	mov	r9, r2
20000326:	fa69 f908 	ror.w	r9, r9, r8

2000032a <fill_memory_spare_bytes_start>:
2000032a:	2c00      	cmp	r4, #0
2000032c:	d007      	beq.n	2000033e <fill_memory_end_start>
2000032e:	f880 9000 	strb.w	r9, [r0]
20000332:	fa69 f907 	ror.w	r9, r9, r7
20000336:	f100 0001 	add.w	r0, r0, #1
2000033a:	3c01      	subs	r4, #1
2000033c:	e7f5      	b.n	2000032a <fill_memory_spare_bytes_start>

2000033e <fill_memory_end_start>:
2000033e:	f04f 0600 	mov.w	r6, #0
20000342:	460f      	mov	r7, r1
20000344:	1a09      	subs	r1, r1, r0
20000346:	4688      	mov	r8, r1
20000348:	1109      	asrs	r1, r1, #4
2000034a:	4691      	mov	r9, r2
2000034c:	4614      	mov	r4, r2
2000034e:	4615      	mov	r5, r2
20000350:	42b1      	cmp	r1, r6
20000352:	d006      	beq.n	20000362 <fill_memory_spare_bytes_end>

20000354 <fill_memory_loop>:
20000354:	bf18      	it	ne
20000356:	e8a0 0234 	stmiane.w	r0!, {r2, r4, r5, r9}
2000035a:	f106 0601 	add.w	r6, r6, #1
2000035e:	42b1      	cmp	r1, r6
20000360:	d1f8      	bne.n	20000354 <fill_memory_loop>

20000362 <fill_memory_spare_bytes_end>:
20000362:	f008 080f 	and.w	r8, r8, #15

20000366 <fill_memory_spare_end_loop>:
20000366:	f1b8 0f00 	cmp.w	r8, #0
2000036a:	d007      	beq.n	2000037c <fill_memory_exit>
2000036c:	7002      	strb	r2, [r0, #0]
2000036e:	ea4f 2232 	mov.w	r2, r2, ror #8
20000372:	f100 0001 	add.w	r0, r0, #1
20000376:	f1b8 0801 	subs.w	r8, r8, #1
2000037a:	e7f4      	b.n	20000366 <fill_memory_spare_end_loop>

2000037c <fill_memory_exit>:
2000037c:	4770      	bx	lr

2000037e <NMI_Handler>:
2000037e:	e7fe      	b.n	2000037e <NMI_Handler>

20000380 <HardFault_Handler>:
20000380:	e7fe      	b.n	20000380 <HardFault_Handler>

20000382 <MemManage_Handler>:
20000382:	e7fe      	b.n	20000382 <MemManage_Handler>

20000384 <BusFault_Handler>:
20000384:	e7fe      	b.n	20000384 <BusFault_Handler>

20000386 <UsageFault_Handler>:
20000386:	e7fe      	b.n	20000386 <UsageFault_Handler>

20000388 <SVC_Handler>:
20000388:	e7fe      	b.n	20000388 <SVC_Handler>

2000038a <DebugMon_Handler>:
2000038a:	e7fe      	b.n	2000038a <DebugMon_Handler>

2000038c <PendSV_Handler>:
2000038c:	e7fe      	b.n	2000038c <PendSV_Handler>

2000038e <SysTick_Handler>:
2000038e:	e7fe      	b.n	2000038e <SysTick_Handler>

20000390 <WdogWakeup_IRQHandler>:
20000390:	e7fe      	b.n	20000390 <WdogWakeup_IRQHandler>

20000392 <RTC_Wakeup_IRQHandler>:
20000392:	e7fe      	b.n	20000392 <RTC_Wakeup_IRQHandler>
20000394:	e7fe      	b.n	20000394 <RTC_Wakeup_IRQHandler+0x2>
20000396:	e7fe      	b.n	20000396 <RTC_Wakeup_IRQHandler+0x4>

20000398 <I2C0_IRQHandler>:
20000398:	e7fe      	b.n	20000398 <I2C0_IRQHandler>

2000039a <I2C0_SMBAlert_IRQHandler>:
2000039a:	e7fe      	b.n	2000039a <I2C0_SMBAlert_IRQHandler>

2000039c <I2C0_SMBus_IRQHandler>:
2000039c:	e7fe      	b.n	2000039c <I2C0_SMBus_IRQHandler>

2000039e <I2C1_IRQHandler>:
2000039e:	e7fe      	b.n	2000039e <I2C1_IRQHandler>

200003a0 <I2C1_SMBAlert_IRQHandler>:
200003a0:	e7fe      	b.n	200003a0 <I2C1_SMBAlert_IRQHandler>

200003a2 <I2C1_SMBus_IRQHandler>:
200003a2:	e7fe      	b.n	200003a2 <I2C1_SMBus_IRQHandler>
200003a4:	e7fe      	b.n	200003a4 <I2C1_SMBus_IRQHandler+0x2>
200003a6:	e7fe      	b.n	200003a6 <I2C1_SMBus_IRQHandler+0x4>

200003a8 <EthernetMAC_IRQHandler>:
200003a8:	e7fe      	b.n	200003a8 <EthernetMAC_IRQHandler>

200003aa <DMA_IRQHandler>:
200003aa:	e7fe      	b.n	200003aa <DMA_IRQHandler>

200003ac <Timer1_IRQHandler>:
200003ac:	e7fe      	b.n	200003ac <Timer1_IRQHandler>

200003ae <Timer2_IRQHandler>:
200003ae:	e7fe      	b.n	200003ae <Timer2_IRQHandler>

200003b0 <CAN_IRQHandler>:
200003b0:	e7fe      	b.n	200003b0 <CAN_IRQHandler>

200003b2 <ENVM0_IRQHandler>:
200003b2:	e7fe      	b.n	200003b2 <ENVM0_IRQHandler>

200003b4 <ENVM1_IRQHandler>:
200003b4:	e7fe      	b.n	200003b4 <ENVM1_IRQHandler>
200003b6:	e7fe      	b.n	200003b6 <ENVM1_IRQHandler+0x2>

200003b8 <USB_IRQHandler>:
200003b8:	e7fe      	b.n	200003b8 <USB_IRQHandler>

200003ba <USB_DMA_IRQHandler>:
200003ba:	e7fe      	b.n	200003ba <USB_DMA_IRQHandler>

200003bc <PLL_Lock_IRQHandler>:
200003bc:	e7fe      	b.n	200003bc <PLL_Lock_IRQHandler>

200003be <PLL_LockLost_IRQHandler>:
200003be:	e7fe      	b.n	200003be <PLL_LockLost_IRQHandler>

200003c0 <CommSwitchError_IRQHandler>:
200003c0:	e7fe      	b.n	200003c0 <CommSwitchError_IRQHandler>

200003c2 <CacheError_IRQHandler>:
200003c2:	e7fe      	b.n	200003c2 <CacheError_IRQHandler>

200003c4 <DDR_IRQHandler>:
200003c4:	e7fe      	b.n	200003c4 <DDR_IRQHandler>

200003c6 <HPDMA_Complete_IRQHandler>:
200003c6:	e7fe      	b.n	200003c6 <HPDMA_Complete_IRQHandler>

200003c8 <HPDMA_Error_IRQHandler>:
200003c8:	e7fe      	b.n	200003c8 <HPDMA_Error_IRQHandler>

200003ca <ECC_Error_IRQHandler>:
200003ca:	e7fe      	b.n	200003ca <ECC_Error_IRQHandler>

200003cc <MDDR_IOCalib_IRQHandler>:
200003cc:	e7fe      	b.n	200003cc <MDDR_IOCalib_IRQHandler>

200003ce <FAB_PLL_Lock_IRQHandler>:
200003ce:	e7fe      	b.n	200003ce <FAB_PLL_Lock_IRQHandler>

200003d0 <FAB_PLL_LockLost_IRQHandler>:
200003d0:	e7fe      	b.n	200003d0 <FAB_PLL_LockLost_IRQHandler>

200003d2 <FIC64_IRQHandler>:
200003d2:	e7fe      	b.n	200003d2 <FIC64_IRQHandler>

200003d4 <FabricIrq0_IRQHandler>:
200003d4:	e7fe      	b.n	200003d4 <FabricIrq0_IRQHandler>

200003d6 <FabricIrq1_IRQHandler>:
200003d6:	e7fe      	b.n	200003d6 <FabricIrq1_IRQHandler>

200003d8 <FabricIrq2_IRQHandler>:
200003d8:	e7fe      	b.n	200003d8 <FabricIrq2_IRQHandler>

200003da <FabricIrq3_IRQHandler>:
200003da:	e7fe      	b.n	200003da <FabricIrq3_IRQHandler>

200003dc <FabricIrq4_IRQHandler>:
200003dc:	e7fe      	b.n	200003dc <FabricIrq4_IRQHandler>

200003de <FabricIrq5_IRQHandler>:
200003de:	e7fe      	b.n	200003de <FabricIrq5_IRQHandler>

200003e0 <FabricIrq6_IRQHandler>:
200003e0:	e7fe      	b.n	200003e0 <FabricIrq6_IRQHandler>

200003e2 <FabricIrq7_IRQHandler>:
200003e2:	e7fe      	b.n	200003e2 <FabricIrq7_IRQHandler>

200003e4 <FabricIrq8_IRQHandler>:
200003e4:	e7fe      	b.n	200003e4 <FabricIrq8_IRQHandler>

200003e6 <FabricIrq9_IRQHandler>:
200003e6:	e7fe      	b.n	200003e6 <FabricIrq9_IRQHandler>

200003e8 <FabricIrq10_IRQHandler>:
200003e8:	e7fe      	b.n	200003e8 <FabricIrq10_IRQHandler>

200003ea <FabricIrq11_IRQHandler>:
200003ea:	e7fe      	b.n	200003ea <FabricIrq11_IRQHandler>

200003ec <FabricIrq12_IRQHandler>:
200003ec:	e7fe      	b.n	200003ec <FabricIrq12_IRQHandler>

200003ee <FabricIrq13_IRQHandler>:
200003ee:	e7fe      	b.n	200003ee <FabricIrq13_IRQHandler>

200003f0 <FabricIrq14_IRQHandler>:
200003f0:	e7fe      	b.n	200003f0 <FabricIrq14_IRQHandler>

200003f2 <FabricIrq15_IRQHandler>:
200003f2:	e7fe      	b.n	200003f2 <FabricIrq15_IRQHandler>

200003f4 <GPIO0_IRQHandler>:
200003f4:	e7fe      	b.n	200003f4 <GPIO0_IRQHandler>

200003f6 <GPIO1_IRQHandler>:
200003f6:	e7fe      	b.n	200003f6 <GPIO1_IRQHandler>

200003f8 <GPIO2_IRQHandler>:
200003f8:	e7fe      	b.n	200003f8 <GPIO2_IRQHandler>

200003fa <GPIO3_IRQHandler>:
200003fa:	e7fe      	b.n	200003fa <GPIO3_IRQHandler>

200003fc <GPIO4_IRQHandler>:
200003fc:	e7fe      	b.n	200003fc <GPIO4_IRQHandler>

200003fe <GPIO5_IRQHandler>:
200003fe:	e7fe      	b.n	200003fe <GPIO5_IRQHandler>

20000400 <GPIO6_IRQHandler>:
20000400:	e7fe      	b.n	20000400 <GPIO6_IRQHandler>

20000402 <GPIO7_IRQHandler>:
20000402:	e7fe      	b.n	20000402 <GPIO7_IRQHandler>

20000404 <GPIO8_IRQHandler>:
20000404:	e7fe      	b.n	20000404 <GPIO8_IRQHandler>

20000406 <GPIO9_IRQHandler>:
20000406:	e7fe      	b.n	20000406 <GPIO9_IRQHandler>

20000408 <GPIO10_IRQHandler>:
20000408:	e7fe      	b.n	20000408 <GPIO10_IRQHandler>

2000040a <GPIO11_IRQHandler>:
2000040a:	e7fe      	b.n	2000040a <GPIO11_IRQHandler>

2000040c <GPIO12_IRQHandler>:
2000040c:	e7fe      	b.n	2000040c <GPIO12_IRQHandler>

2000040e <GPIO13_IRQHandler>:
2000040e:	e7fe      	b.n	2000040e <GPIO13_IRQHandler>

20000410 <GPIO14_IRQHandler>:
20000410:	e7fe      	b.n	20000410 <GPIO14_IRQHandler>

20000412 <GPIO15_IRQHandler>:
20000412:	e7fe      	b.n	20000412 <GPIO15_IRQHandler>

20000414 <GPIO16_IRQHandler>:
20000414:	e7fe      	b.n	20000414 <GPIO16_IRQHandler>

20000416 <GPIO17_IRQHandler>:
20000416:	e7fe      	b.n	20000416 <GPIO17_IRQHandler>

20000418 <GPIO18_IRQHandler>:
20000418:	e7fe      	b.n	20000418 <GPIO18_IRQHandler>

2000041a <GPIO19_IRQHandler>:
2000041a:	e7fe      	b.n	2000041a <GPIO19_IRQHandler>

2000041c <GPIO20_IRQHandler>:
2000041c:	e7fe      	b.n	2000041c <GPIO20_IRQHandler>

2000041e <GPIO21_IRQHandler>:
2000041e:	e7fe      	b.n	2000041e <GPIO21_IRQHandler>

20000420 <GPIO22_IRQHandler>:
20000420:	e7fe      	b.n	20000420 <GPIO22_IRQHandler>

20000422 <GPIO23_IRQHandler>:
20000422:	e7fe      	b.n	20000422 <GPIO23_IRQHandler>

20000424 <GPIO24_IRQHandler>:
20000424:	e7fe      	b.n	20000424 <GPIO24_IRQHandler>

20000426 <GPIO25_IRQHandler>:
20000426:	e7fe      	b.n	20000426 <GPIO25_IRQHandler>

20000428 <GPIO26_IRQHandler>:
20000428:	e7fe      	b.n	20000428 <GPIO26_IRQHandler>

2000042a <GPIO27_IRQHandler>:
2000042a:	e7fe      	b.n	2000042a <GPIO27_IRQHandler>

2000042c <GPIO28_IRQHandler>:
2000042c:	e7fe      	b.n	2000042c <GPIO28_IRQHandler>

2000042e <GPIO29_IRQHandler>:
2000042e:	e7fe      	b.n	2000042e <GPIO29_IRQHandler>

20000430 <GPIO30_IRQHandler>:
20000430:	e7fe      	b.n	20000430 <GPIO30_IRQHandler>

20000432 <GPIO31_IRQHandler>:
20000432:	e7fe      	b.n	20000432 <GPIO31_IRQHandler>

20000434 <mscc_post_hw_cfg_init>:
20000434:	4770      	bx	lr

20000436 <RAM_INIT_PATTERN>:
20000436:	0000      	.short	0x0000
	...

2000043a <HEAP_INIT_PATTERN>:
2000043a:	a2a2      	.short	0xa2a2
2000043c:	a2a2      	.short	0xa2a2

2000043e <SF2_ESRAM_CR>:
2000043e:	8000      	.short	0x8000
20000440:	4003      	.short	0x4003

20000442 <SF2_DDR_CR>:
20000442:	8008      	.short	0x8008
20000444:	4003      	.short	0x4003

20000446 <SF2_ENVM_REMAP_CR>:
20000446:	8010      	.short	0x8010
20000448:	4003      	.short	0x4003

2000044a <SF2_DDRB_NB_SIZE>:
2000044a:	8030      	.short	0x8030
2000044c:	4003      	.short	0x4003

2000044e <SF2_DDRB_CR>:
2000044e:	8034      	.short	0x8034
20000450:	4003      	.short	0x4003

20000452 <SF2_EDAC_CR>:
20000452:	8038      	.short	0x8038
20000454:	4003      	.short	0x4003

20000456 <SF2_MDDR_MODE_CR>:
20000456:	0818      	.short	0x0818
20000458:	00004002 	.word	0x00004002
2000045c:	2000f000 	.word	0x2000f000
20000460:	20010000 	.word	0x20010000
20000464:	20003a1d 	.word	0x20003a1d
	...
20000470:	00000001 	.word	0x00000001
20000474:	00000000 	.word	0x00000000
20000478:	20000000 	.word	0x20000000
2000047c:	20000000 	.word	0x20000000
20000480:	20000190 	.word	0x20000190
20000484:	200004c0 	.word	0x200004c0
20000488:	200004c0 	.word	0x200004c0
2000048c:	20005100 	.word	0x20005100
20000490:	20005100 	.word	0x20005100
20000494:	20005100 	.word	0x20005100
20000498:	20005250 	.word	0x20005250
2000049c:	20005250 	.word	0x20005250
200004a0:	20008680 	.word	0x20008680
200004a4:	20008680 	.word	0x20008680
200004a8:	2000f000 	.word	0x2000f000
200004ac:	20004a09 	.word	0x20004a09
200004b0:	20000d19 	.word	0x20000d19
200004b4:	f3af 8000 	nop.w
200004b8:	f3af 8000 	nop.w
200004bc:	f3af 8000 	nop.w

Disassembly of section .text:

200004c0 <__do_global_dtors_aux>:
200004c0:	f245 2350 	movw	r3, #21072	; 0x5250
200004c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004c8:	781a      	ldrb	r2, [r3, #0]
200004ca:	b90a      	cbnz	r2, 200004d0 <__do_global_dtors_aux+0x10>
200004cc:	2001      	movs	r0, #1
200004ce:	7018      	strb	r0, [r3, #0]
200004d0:	4770      	bx	lr
200004d2:	bf00      	nop

200004d4 <frame_dummy>:
200004d4:	f245 1000 	movw	r0, #20736	; 0x5100
200004d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200004dc:	b508      	push	{r3, lr}
200004de:	6803      	ldr	r3, [r0, #0]
200004e0:	b12b      	cbz	r3, 200004ee <frame_dummy+0x1a>
200004e2:	f240 0300 	movw	r3, #0
200004e6:	f2c0 0300 	movt	r3, #0
200004ea:	b103      	cbz	r3, 200004ee <frame_dummy+0x1a>
200004ec:	4798      	blx	r3
200004ee:	bd08      	pop	{r3, pc}

200004f0 <chk_busy>:

	return 0;

}

void chk_busy(){
200004f0:	b580      	push	{r7, lr}
200004f2:	b084      	sub	sp, #16
200004f4:	af02      	add	r7, sp, #8
	uint8_t cmd[] = {0x05};
200004f6:	f04f 0305 	mov.w	r3, #5
200004fa:	703b      	strb	r3, [r7, #0]
	uint32_t i = 0;
200004fc:	f04f 0300 	mov.w	r3, #0
20000500:	607b      	str	r3, [r7, #4]
	MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000502:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000506:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000050a:	f04f 0100 	mov.w	r1, #0
2000050e:	f002 fe63 	bl	200031d8 <MSS_SPI_set_slave_select>
//	while(1){
//	MSS_SPI_transfer_block(&g_mss_spi0, cmd, sizeof(cmd), rx_buf, sizeof(rx_buf));
//		SPI_block_read(&g_mss_spi0, cmd, sizeof(cmd), rx_buf, sizeof(rx_buf));
//	}

	MSS_SPI_transfer_block(&g_mss_spi0, cmd, sizeof(cmd), rx_buf, sizeof(rx_buf));
20000512:	463b      	mov	r3, r7
20000514:	f04f 0210 	mov.w	r2, #16
20000518:	9200      	str	r2, [sp, #0]
2000051a:	f248 50f8 	movw	r0, #34296	; 0x85f8
2000051e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000522:	4619      	mov	r1, r3
20000524:	f04f 0201 	mov.w	r2, #1
20000528:	f245 23d0 	movw	r3, #21200	; 0x52d0
2000052c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000530:	f002 ff1e 	bl	20003370 <MSS_SPI_transfer_block>
	while(1){
		if(!(rx_buf[0] & 0x01)){
20000534:	f245 23d0 	movw	r3, #21200	; 0x52d0
20000538:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000053c:	781b      	ldrb	r3, [r3, #0]
2000053e:	f003 0301 	and.w	r3, r3, #1
20000542:	2b00      	cmp	r3, #0
20000544:	d10b      	bne.n	2000055e <chk_busy+0x6e>
			break;
		}
		MSS_SPI_transfer_block(&g_mss_spi0, cmd, sizeof(cmd), rx_buf, sizeof(rx_buf));
	}

	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000546:	f248 50f8 	movw	r0, #34296	; 0x85f8
2000054a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000054e:	f04f 0100 	mov.w	r1, #0
20000552:	f002 fec5 	bl	200032e0 <MSS_SPI_clear_slave_select>

	return;
}
20000556:	f107 0708 	add.w	r7, r7, #8
2000055a:	46bd      	mov	sp, r7
2000055c:	bd80      	pop	{r7, pc}
	MSS_SPI_transfer_block(&g_mss_spi0, cmd, sizeof(cmd), rx_buf, sizeof(rx_buf));
	while(1){
		if(!(rx_buf[0] & 0x01)){
			break;
		}
		MSS_SPI_transfer_block(&g_mss_spi0, cmd, sizeof(cmd), rx_buf, sizeof(rx_buf));
2000055e:	463b      	mov	r3, r7
20000560:	f04f 0210 	mov.w	r2, #16
20000564:	9200      	str	r2, [sp, #0]
20000566:	f248 50f8 	movw	r0, #34296	; 0x85f8
2000056a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000056e:	4619      	mov	r1, r3
20000570:	f04f 0201 	mov.w	r2, #1
20000574:	f245 23d0 	movw	r3, #21200	; 0x52d0
20000578:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000057c:	f002 fef8 	bl	20003370 <MSS_SPI_transfer_block>
	}
20000580:	e7d8      	b.n	20000534 <chk_busy+0x44>
20000582:	bf00      	nop

20000584 <write_cmd_data>:
    mss_spi_instance_t * this_spi,
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * data_buffer,
    uint16_t data_byte_size
){
20000584:	b580      	push	{r7, lr}
20000586:	f5ad 7d08 	sub.w	sp, sp, #544	; 0x220
2000058a:	af02      	add	r7, sp, #8
2000058c:	f107 0c0c 	add.w	ip, r7, #12
20000590:	f8cc 0000 	str.w	r0, [ip]
20000594:	f107 0008 	add.w	r0, r7, #8
20000598:	6001      	str	r1, [r0, #0]
2000059a:	4639      	mov	r1, r7
2000059c:	600b      	str	r3, [r1, #0]
2000059e:	f107 0308 	add.w	r3, r7, #8
200005a2:	f1a3 0302 	sub.w	r3, r3, #2
200005a6:	801a      	strh	r2, [r3, #0]
	uint8_t tx_buffer[516];
	uint16_t transfer_size;
	uint16_t idx = 0;
200005a8:	f04f 0300 	mov.w	r3, #0
200005ac:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216

	transfer_size = cmd_byte_size + data_byte_size;
200005b0:	f107 0308 	add.w	r3, r7, #8
200005b4:	f1a3 0302 	sub.w	r3, r3, #2
200005b8:	881a      	ldrh	r2, [r3, #0]
200005ba:	f8b7 3220 	ldrh.w	r3, [r7, #544]	; 0x220
200005be:	4413      	add	r3, r2
200005c0:	f8a7 3214 	strh.w	r3, [r7, #532]	; 0x214

	for(idx = 0; idx < cmd_byte_size; ++idx)
200005c4:	f04f 0300 	mov.w	r3, #0
200005c8:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
200005cc:	e011      	b.n	200005f2 <write_cmd_data+0x6e>
	{
		tx_buffer[idx] = cmd_buffer[idx];
200005ce:	f8b7 3216 	ldrh.w	r3, [r7, #534]	; 0x216
200005d2:	f8b7 1216 	ldrh.w	r1, [r7, #534]	; 0x216
200005d6:	f107 0208 	add.w	r2, r7, #8
200005da:	6812      	ldr	r2, [r2, #0]
200005dc:	440a      	add	r2, r1
200005de:	7811      	ldrb	r1, [r2, #0]
200005e0:	f107 0210 	add.w	r2, r7, #16
200005e4:	54d1      	strb	r1, [r2, r3]
	uint16_t transfer_size;
	uint16_t idx = 0;

	transfer_size = cmd_byte_size + data_byte_size;

	for(idx = 0; idx < cmd_byte_size; ++idx)
200005e6:	f8b7 3216 	ldrh.w	r3, [r7, #534]	; 0x216
200005ea:	f103 0301 	add.w	r3, r3, #1
200005ee:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
200005f2:	f107 0308 	add.w	r3, r7, #8
200005f6:	f1a3 0302 	sub.w	r3, r3, #2
200005fa:	f8b7 2216 	ldrh.w	r2, [r7, #534]	; 0x216
200005fe:	881b      	ldrh	r3, [r3, #0]
20000600:	429a      	cmp	r2, r3
20000602:	d3e4      	bcc.n	200005ce <write_cmd_data+0x4a>
	{
		tx_buffer[idx] = cmd_buffer[idx];
	}

	for(idx = 0; idx < data_byte_size; ++idx)
20000604:	f04f 0300 	mov.w	r3, #0
20000608:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
2000060c:	e016      	b.n	2000063c <write_cmd_data+0xb8>
	{
		tx_buffer[cmd_byte_size + idx] = data_buffer[idx];
2000060e:	f107 0308 	add.w	r3, r7, #8
20000612:	f1a3 0302 	sub.w	r3, r3, #2
20000616:	881a      	ldrh	r2, [r3, #0]
20000618:	f8b7 3216 	ldrh.w	r3, [r7, #534]	; 0x216
2000061c:	4413      	add	r3, r2
2000061e:	f8b7 1216 	ldrh.w	r1, [r7, #534]	; 0x216
20000622:	463a      	mov	r2, r7
20000624:	6812      	ldr	r2, [r2, #0]
20000626:	440a      	add	r2, r1
20000628:	7811      	ldrb	r1, [r2, #0]
2000062a:	f107 0210 	add.w	r2, r7, #16
2000062e:	54d1      	strb	r1, [r2, r3]
	for(idx = 0; idx < cmd_byte_size; ++idx)
	{
		tx_buffer[idx] = cmd_buffer[idx];
	}

	for(idx = 0; idx < data_byte_size; ++idx)
20000630:	f8b7 3216 	ldrh.w	r3, [r7, #534]	; 0x216
20000634:	f103 0301 	add.w	r3, r3, #1
20000638:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
2000063c:	f8b7 2216 	ldrh.w	r2, [r7, #534]	; 0x216
20000640:	f8b7 3220 	ldrh.w	r3, [r7, #544]	; 0x220
20000644:	429a      	cmp	r2, r3
20000646:	d3e2      	bcc.n	2000060e <write_cmd_data+0x8a>
	{
		tx_buffer[cmd_byte_size + idx] = data_buffer[idx];
	}

	MSS_SPI_transfer_block( &g_mss_spi0, tx_buffer, transfer_size, 0, 0 );
20000648:	f107 0210 	add.w	r2, r7, #16
2000064c:	f8b7 3214 	ldrh.w	r3, [r7, #532]	; 0x214
20000650:	f04f 0100 	mov.w	r1, #0
20000654:	9100      	str	r1, [sp, #0]
20000656:	f248 50f8 	movw	r0, #34296	; 0x85f8
2000065a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000065e:	4611      	mov	r1, r2
20000660:	461a      	mov	r2, r3
20000662:	f04f 0300 	mov.w	r3, #0
20000666:	f002 fe83 	bl	20003370 <MSS_SPI_transfer_block>
}
2000066a:	f507 7706 	add.w	r7, r7, #536	; 0x218
2000066e:	46bd      	mov	sp, r7
20000670:	bd80      	pop	{r7, pc}
20000672:	bf00      	nop

20000674 <FLASH_program>:
(
    uint32_t address,
    uint8_t * write_buffer,
    size_t size_in_bytes
)
{
20000674:	b580      	push	{r7, lr}
20000676:	b08c      	sub	sp, #48	; 0x30
20000678:	af02      	add	r7, sp, #8
2000067a:	60f8      	str	r0, [r7, #12]
2000067c:	60b9      	str	r1, [r7, #8]
2000067e:	607a      	str	r2, [r7, #4]

    uint32_t in_buffer_idx;
    uint32_t nb_bytes_to_write;
    uint32_t target_addr;

    MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
20000680:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000684:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000688:	f04f 0100 	mov.w	r1, #0
2000068c:	f002 fda4 	bl	200031d8 <MSS_SPI_set_slave_select>

    /* Send Write Enable command */
    cmd_buffer[0] = WRITE_ENABLE_CMD;
20000690:	f04f 0306 	mov.w	r3, #6
20000694:	753b      	strb	r3, [r7, #20]
    wait_ready();
20000696:	f000 fa4f 	bl	20000b38 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 1, 0, 0 );
2000069a:	f107 0314 	add.w	r3, r7, #20
2000069e:	f04f 0200 	mov.w	r2, #0
200006a2:	9200      	str	r2, [sp, #0]
200006a4:	f248 50f8 	movw	r0, #34296	; 0x85f8
200006a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200006ac:	4619      	mov	r1, r3
200006ae:	f04f 0201 	mov.w	r2, #1
200006b2:	f04f 0300 	mov.w	r3, #0
200006b6:	f002 fe5b 	bl	20003370 <MSS_SPI_transfer_block>

    /* Unprotect sector */
    cmd_buffer[0] = UNPROTECT_SECTOR_OPCODE;
200006ba:	f04f 0339 	mov.w	r3, #57	; 0x39
200006be:	753b      	strb	r3, [r7, #20]
    cmd_buffer[1] = (address >> 16) & 0xFF;
200006c0:	68fb      	ldr	r3, [r7, #12]
200006c2:	ea4f 4313 	mov.w	r3, r3, lsr #16
200006c6:	b2db      	uxtb	r3, r3
200006c8:	757b      	strb	r3, [r7, #21]
    cmd_buffer[2] = (address >> 8 ) & 0xFF;
200006ca:	68fb      	ldr	r3, [r7, #12]
200006cc:	ea4f 2313 	mov.w	r3, r3, lsr #8
200006d0:	b2db      	uxtb	r3, r3
200006d2:	75bb      	strb	r3, [r7, #22]
    cmd_buffer[3] = address & 0xFF;
200006d4:	68fb      	ldr	r3, [r7, #12]
200006d6:	b2db      	uxtb	r3, r3
200006d8:	75fb      	strb	r3, [r7, #23]
    wait_ready();
200006da:	f000 fa2d 	bl	20000b38 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, sizeof(cmd_buffer), 0, 0 );
200006de:	f107 0314 	add.w	r3, r7, #20
200006e2:	f04f 0200 	mov.w	r2, #0
200006e6:	9200      	str	r2, [sp, #0]
200006e8:	f248 50f8 	movw	r0, #34296	; 0x85f8
200006ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
200006f0:	4619      	mov	r1, r3
200006f2:	f04f 0204 	mov.w	r2, #4
200006f6:	f04f 0300 	mov.w	r3, #0
200006fa:	f002 fe39 	bl	20003370 <MSS_SPI_transfer_block>

    /* Send Write Enable command */
    cmd_buffer[0] = WRITE_ENABLE_CMD;
200006fe:	f04f 0306 	mov.w	r3, #6
20000702:	753b      	strb	r3, [r7, #20]
    wait_ready();
20000704:	f000 fa18 	bl	20000b38 <wait_ready>
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 1, 0, 0 );
20000708:	f107 0314 	add.w	r3, r7, #20
2000070c:	f04f 0200 	mov.w	r2, #0
20000710:	9200      	str	r2, [sp, #0]
20000712:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000716:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000071a:	4619      	mov	r1, r3
2000071c:	f04f 0201 	mov.w	r2, #1
20000720:	f04f 0300 	mov.w	r3, #0
20000724:	f002 fe24 	bl	20003370 <MSS_SPI_transfer_block>

    /**/
    in_buffer_idx = 0;
20000728:	f04f 0300 	mov.w	r3, #0
2000072c:	61bb      	str	r3, [r7, #24]
    nb_bytes_to_write = size_in_bytes;
2000072e:	687b      	ldr	r3, [r7, #4]
20000730:	61fb      	str	r3, [r7, #28]
    target_addr = address;
20000732:	68fb      	ldr	r3, [r7, #12]
20000734:	623b      	str	r3, [r7, #32]

    while ( in_buffer_idx < size_in_bytes )
20000736:	e050      	b.n	200007da <FLASH_program+0x166>
    {
        uint32_t size_left;
        nb_bytes_to_write = 0x100 - (target_addr & 0xFF);   /* adjust max possible size to page boundary. */
20000738:	6a3b      	ldr	r3, [r7, #32]
2000073a:	f003 03ff 	and.w	r3, r3, #255	; 0xff
2000073e:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
20000742:	61fb      	str	r3, [r7, #28]
        size_left = size_in_bytes - in_buffer_idx;
20000744:	687a      	ldr	r2, [r7, #4]
20000746:	69bb      	ldr	r3, [r7, #24]
20000748:	ebc3 0302 	rsb	r3, r3, r2
2000074c:	627b      	str	r3, [r7, #36]	; 0x24
        if ( size_left < nb_bytes_to_write )
2000074e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
20000750:	69fb      	ldr	r3, [r7, #28]
20000752:	429a      	cmp	r2, r3
20000754:	d201      	bcs.n	2000075a <FLASH_program+0xe6>
        {
            nb_bytes_to_write = size_left;
20000756:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000758:	61fb      	str	r3, [r7, #28]
        }

        wait_ready();
2000075a:	f000 f9ed 	bl	20000b38 <wait_ready>

        /* Send Write Enable command */
        cmd_buffer[0] = WRITE_ENABLE_CMD;
2000075e:	f04f 0306 	mov.w	r3, #6
20000762:	753b      	strb	r3, [r7, #20]
        MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 1, 0, 0 );
20000764:	f107 0314 	add.w	r3, r7, #20
20000768:	f04f 0200 	mov.w	r2, #0
2000076c:	9200      	str	r2, [sp, #0]
2000076e:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000772:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000776:	4619      	mov	r1, r3
20000778:	f04f 0201 	mov.w	r2, #1
2000077c:	f04f 0300 	mov.w	r3, #0
20000780:	f002 fdf6 	bl	20003370 <MSS_SPI_transfer_block>

        /* Program page */
        wait_ready();
20000784:	f000 f9d8 	bl	20000b38 <wait_ready>

        cmd_buffer[0] = PROGRAM_PAGE_CMD;
20000788:	f04f 0302 	mov.w	r3, #2
2000078c:	753b      	strb	r3, [r7, #20]
        cmd_buffer[1] = (target_addr >> 16) & 0xFF;
2000078e:	6a3b      	ldr	r3, [r7, #32]
20000790:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000794:	b2db      	uxtb	r3, r3
20000796:	757b      	strb	r3, [r7, #21]
        cmd_buffer[2] = (target_addr >> 8 ) & 0xFF;
20000798:	6a3b      	ldr	r3, [r7, #32]
2000079a:	ea4f 2313 	mov.w	r3, r3, lsr #8
2000079e:	b2db      	uxtb	r3, r3
200007a0:	75bb      	strb	r3, [r7, #22]
        cmd_buffer[3] = target_addr & 0xFF;
200007a2:	6a3b      	ldr	r3, [r7, #32]
200007a4:	b2db      	uxtb	r3, r3
200007a6:	75fb      	strb	r3, [r7, #23]

        write_cmd_data
200007a8:	68ba      	ldr	r2, [r7, #8]
200007aa:	69bb      	ldr	r3, [r7, #24]
200007ac:	4413      	add	r3, r2
200007ae:	69fa      	ldr	r2, [r7, #28]
200007b0:	b291      	uxth	r1, r2
200007b2:	f107 0214 	add.w	r2, r7, #20
200007b6:	9100      	str	r1, [sp, #0]
200007b8:	f248 50f8 	movw	r0, #34296	; 0x85f8
200007bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200007c0:	4611      	mov	r1, r2
200007c2:	f04f 0204 	mov.w	r2, #4
200007c6:	f7ff fedd 	bl	20000584 <write_cmd_data>
            sizeof(cmd_buffer),
            &write_buffer[in_buffer_idx],
            nb_bytes_to_write
          );

        target_addr += nb_bytes_to_write;
200007ca:	6a3a      	ldr	r2, [r7, #32]
200007cc:	69fb      	ldr	r3, [r7, #28]
200007ce:	4413      	add	r3, r2
200007d0:	623b      	str	r3, [r7, #32]
        in_buffer_idx += nb_bytes_to_write;
200007d2:	69ba      	ldr	r2, [r7, #24]
200007d4:	69fb      	ldr	r3, [r7, #28]
200007d6:	4413      	add	r3, r2
200007d8:	61bb      	str	r3, [r7, #24]
    /**/
    in_buffer_idx = 0;
    nb_bytes_to_write = size_in_bytes;
    target_addr = address;

    while ( in_buffer_idx < size_in_bytes )
200007da:	69ba      	ldr	r2, [r7, #24]
200007dc:	687b      	ldr	r3, [r7, #4]
200007de:	429a      	cmp	r2, r3
200007e0:	d3aa      	bcc.n	20000738 <FLASH_program+0xc4>
        target_addr += nb_bytes_to_write;
        in_buffer_idx += nb_bytes_to_write;
    }

    /* Send Write Disable command. */
    cmd_buffer[0] = WRITE_DISABLE_CMD;
200007e2:	f04f 0304 	mov.w	r3, #4
200007e6:	753b      	strb	r3, [r7, #20]

    wait_ready();
200007e8:	f000 f9a6 	bl	20000b38 <wait_ready>

    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 1, 0, 0 );
200007ec:	f107 0314 	add.w	r3, r7, #20
200007f0:	f04f 0200 	mov.w	r2, #0
200007f4:	9200      	str	r2, [sp, #0]
200007f6:	f248 50f8 	movw	r0, #34296	; 0x85f8
200007fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
200007fe:	4619      	mov	r1, r3
20000800:	f04f 0201 	mov.w	r2, #1
20000804:	f04f 0300 	mov.w	r3, #0
20000808:	f002 fdb2 	bl	20003370 <MSS_SPI_transfer_block>
    MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
2000080c:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000810:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000814:	f04f 0100 	mov.w	r1, #0
20000818:	f002 fd62 	bl	200032e0 <MSS_SPI_clear_slave_select>
}
2000081c:	f107 0728 	add.w	r7, r7, #40	; 0x28
20000820:	46bd      	mov	sp, r7
20000822:	bd80      	pop	{r7, pc}

20000824 <flash_erase>:



void flash_erase(){
20000824:	b580      	push	{r7, lr}
20000826:	b084      	sub	sp, #16
20000828:	af02      	add	r7, sp, #8
	uint8_t erase_cmd[] = {0x60};
2000082a:	f04f 0360 	mov.w	r3, #96	; 0x60
2000082e:	713b      	strb	r3, [r7, #4]

	Flash_write_enable(WREN);
20000830:	f04f 0000 	mov.w	r0, #0
20000834:	f000 f836 	bl	200008a4 <Flash_write_enable>
	Flash_unblock_blocks(cmd);
20000838:	f245 1304 	movw	r3, #20740	; 0x5104
2000083c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000840:	781b      	ldrb	r3, [r3, #0]
20000842:	4618      	mov	r0, r3
20000844:	f000 f948 	bl	20000ad8 <Flash_unblock_blocks>

	Flash_write_enable(WREN);
20000848:	f04f 0000 	mov.w	r0, #0
2000084c:	f000 f82a 	bl	200008a4 <Flash_write_enable>

	MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000850:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000854:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000858:	f04f 0100 	mov.w	r1, #0
2000085c:	f002 fcbc 	bl	200031d8 <MSS_SPI_set_slave_select>
//	while(1){
//		SPI_block_write(&g_core_spi0, erase_cmd, 1, rx_buff, 1);
	wait_ready();
20000860:	f000 f96a 	bl	20000b38 <wait_ready>
		MSS_SPI_transfer_block(&g_mss_spi0, erase_cmd, sizeof(erase_cmd), rx_buf, 0);
20000864:	f107 0304 	add.w	r3, r7, #4
20000868:	f04f 0200 	mov.w	r2, #0
2000086c:	9200      	str	r2, [sp, #0]
2000086e:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000872:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000876:	4619      	mov	r1, r3
20000878:	f04f 0201 	mov.w	r2, #1
2000087c:	f245 23d0 	movw	r3, #21200	; 0x52d0
20000880:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000884:	f002 fd74 	bl	20003370 <MSS_SPI_transfer_block>
//	}
//	chk_busy();
		wait_ready();
20000888:	f000 f956 	bl	20000b38 <wait_ready>
	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
2000088c:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000890:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000894:	f04f 0100 	mov.w	r1, #0
20000898:	f002 fd22 	bl	200032e0 <MSS_SPI_clear_slave_select>
	  // After 20sec come out of infinite while loop

}
2000089c:	f107 0708 	add.w	r7, r7, #8
200008a0:	46bd      	mov	sp, r7
200008a2:	bd80      	pop	{r7, pc}

200008a4 <Flash_write_enable>:
//	chk_busy();

}


void Flash_write_enable(uint8_t task){
200008a4:	b580      	push	{r7, lr}
200008a6:	b084      	sub	sp, #16
200008a8:	af02      	add	r7, sp, #8
200008aa:	4603      	mov	r3, r0
200008ac:	71fb      	strb	r3, [r7, #7]

	if(task == WREN){
200008ae:	79fb      	ldrb	r3, [r7, #7]
200008b0:	2b00      	cmp	r3, #0
200008b2:	d125      	bne.n	20000900 <Flash_write_enable+0x5c>
		task = FLASH_WREN;
200008b4:	f04f 0306 	mov.w	r3, #6
200008b8:	71fb      	strb	r3, [r7, #7]
		MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);   //Write enable
200008ba:	f248 50f8 	movw	r0, #34296	; 0x85f8
200008be:	f2c2 0000 	movt	r0, #8192	; 0x2000
200008c2:	f04f 0100 	mov.w	r1, #0
200008c6:	f002 fc87 	bl	200031d8 <MSS_SPI_set_slave_select>
		//while(1){
		MSS_SPI_transfer_block(&g_mss_spi0, &task, sizeof(uint8_t), rx_buf, 0);
200008ca:	f107 0307 	add.w	r3, r7, #7
200008ce:	f04f 0200 	mov.w	r2, #0
200008d2:	9200      	str	r2, [sp, #0]
200008d4:	f248 50f8 	movw	r0, #34296	; 0x85f8
200008d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200008dc:	4619      	mov	r1, r3
200008de:	f04f 0201 	mov.w	r2, #1
200008e2:	f245 23d0 	movw	r3, #21200	; 0x52d0
200008e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008ea:	f002 fd41 	bl	20003370 <MSS_SPI_transfer_block>
	//}

		MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
200008ee:	f248 50f8 	movw	r0, #34296	; 0x85f8
200008f2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200008f6:	f04f 0100 	mov.w	r1, #0
200008fa:	f002 fcf1 	bl	200032e0 <MSS_SPI_clear_slave_select>
200008fe:	e024      	b.n	2000094a <Flash_write_enable+0xa6>
	}
	else{
		task = FLASH_WRDS;
20000900:	f04f 0304 	mov.w	r3, #4
20000904:	71fb      	strb	r3, [r7, #7]
		MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);   //Write enable
20000906:	f248 50f8 	movw	r0, #34296	; 0x85f8
2000090a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000090e:	f04f 0100 	mov.w	r1, #0
20000912:	f002 fc61 	bl	200031d8 <MSS_SPI_set_slave_select>
		//while(1){
		MSS_SPI_transfer_block(&g_mss_spi0, &task, sizeof(uint8_t), rx_buf, 0);
20000916:	f107 0307 	add.w	r3, r7, #7
2000091a:	f04f 0200 	mov.w	r2, #0
2000091e:	9200      	str	r2, [sp, #0]
20000920:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000924:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000928:	4619      	mov	r1, r3
2000092a:	f04f 0201 	mov.w	r2, #1
2000092e:	f245 23d0 	movw	r3, #21200	; 0x52d0
20000932:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000936:	f002 fd1b 	bl	20003370 <MSS_SPI_transfer_block>
	//}

		MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
2000093a:	f248 50f8 	movw	r0, #34296	; 0x85f8
2000093e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000942:	f04f 0100 	mov.w	r1, #0
20000946:	f002 fccb 	bl	200032e0 <MSS_SPI_clear_slave_select>
	}

	chk_busy();
2000094a:	f7ff fdd1 	bl	200004f0 <chk_busy>
}
2000094e:	f107 0708 	add.w	r7, r7, #8
20000952:	46bd      	mov	sp, r7
20000954:	bd80      	pop	{r7, pc}
20000956:	bf00      	nop

20000958 <flash_read>:

//	chk_busy();

}

uint8_t flash_read(uint32_t addr, uint8_t* read_data, uint32_t size){
20000958:	b580      	push	{r7, lr}
2000095a:	b088      	sub	sp, #32
2000095c:	af02      	add	r7, sp, #8
2000095e:	60f8      	str	r0, [r7, #12]
20000960:	60b9      	str	r1, [r7, #8]
20000962:	607a      	str	r2, [r7, #4]
	uint8_t read_cmd = 0x03;
20000964:	f04f 0303 	mov.w	r3, #3
20000968:	75fb      	strb	r3, [r7, #23]
	uint8_t cmd[4] = {read_cmd, ((addr & 0xffffff) >> 16), ((addr & 0xffff) >> 8), addr & 0xff};
2000096a:	68fb      	ldr	r3, [r7, #12]
2000096c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20000970:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000974:	b2d9      	uxtb	r1, r3
20000976:	68fb      	ldr	r3, [r7, #12]
20000978:	ea4f 4303 	mov.w	r3, r3, lsl #16
2000097c:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000980:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000984:	b2da      	uxtb	r2, r3
20000986:	68fb      	ldr	r3, [r7, #12]
20000988:	b2db      	uxtb	r3, r3
2000098a:	7df8      	ldrb	r0, [r7, #23]
2000098c:	7438      	strb	r0, [r7, #16]
2000098e:	7479      	strb	r1, [r7, #17]
20000990:	74ba      	strb	r2, [r7, #18]
20000992:	74fb      	strb	r3, [r7, #19]



	MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000994:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000998:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000099c:	f04f 0100 	mov.w	r1, #0
200009a0:	f002 fc1a 	bl	200031d8 <MSS_SPI_set_slave_select>

//	chk_busy();
	wait_ready();
200009a4:	f000 f8c8 	bl	20000b38 <wait_ready>

	MSS_SPI_transfer_block(&g_mss_spi0, cmd, sizeof(cmd), read_data, size);
200009a8:	687b      	ldr	r3, [r7, #4]
200009aa:	b29a      	uxth	r2, r3
200009ac:	f107 0310 	add.w	r3, r7, #16
200009b0:	9200      	str	r2, [sp, #0]
200009b2:	f248 50f8 	movw	r0, #34296	; 0x85f8
200009b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200009ba:	4619      	mov	r1, r3
200009bc:	f04f 0204 	mov.w	r2, #4
200009c0:	68bb      	ldr	r3, [r7, #8]
200009c2:	f002 fcd5 	bl	20003370 <MSS_SPI_transfer_block>

//	chk_busy();
	wait_ready();
200009c6:	f000 f8b7 	bl	20000b38 <wait_ready>

	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
200009ca:	f248 50f8 	movw	r0, #34296	; 0x85f8
200009ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
200009d2:	f04f 0100 	mov.w	r1, #0
200009d6:	f002 fc83 	bl	200032e0 <MSS_SPI_clear_slave_select>


	return 0;
200009da:	f04f 0300 	mov.w	r3, #0

}
200009de:	4618      	mov	r0, r3
200009e0:	f107 0718 	add.w	r7, r7, #24
200009e4:	46bd      	mov	sp, r7
200009e6:	bd80      	pop	{r7, pc}

200009e8 <flash_fast_read>:

void flash_fast_read(uint32_t addr, uint8_t* read_Data, uint32_t size){
200009e8:	b580      	push	{r7, lr}
200009ea:	b088      	sub	sp, #32
200009ec:	af02      	add	r7, sp, #8
200009ee:	60f8      	str	r0, [r7, #12]
200009f0:	60b9      	str	r1, [r7, #8]
200009f2:	607a      	str	r2, [r7, #4]
	uint8_t read_fast_cmd = 0x0B;
200009f4:	f04f 030b 	mov.w	r3, #11
200009f8:	75fb      	strb	r3, [r7, #23]
	uint8_t cmd[5] = {read_fast_cmd, ((addr & 0xffffff) >> 16), ((addr & 0xffff) >> 8), addr & 0xff, 0x00};
200009fa:	68fb      	ldr	r3, [r7, #12]
200009fc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20000a00:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000a04:	b2d9      	uxtb	r1, r3
20000a06:	68fb      	ldr	r3, [r7, #12]
20000a08:	ea4f 4303 	mov.w	r3, r3, lsl #16
20000a0c:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000a10:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000a14:	b2da      	uxtb	r2, r3
20000a16:	68fb      	ldr	r3, [r7, #12]
20000a18:	b2db      	uxtb	r3, r3
20000a1a:	7df8      	ldrb	r0, [r7, #23]
20000a1c:	7438      	strb	r0, [r7, #16]
20000a1e:	7479      	strb	r1, [r7, #17]
20000a20:	74ba      	strb	r2, [r7, #18]
20000a22:	74fb      	strb	r3, [r7, #19]
20000a24:	f04f 0300 	mov.w	r3, #0
20000a28:	753b      	strb	r3, [r7, #20]

	MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000a2a:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000a2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a32:	f04f 0100 	mov.w	r1, #0
20000a36:	f002 fbcf 	bl	200031d8 <MSS_SPI_set_slave_select>

//	chk_busy();
//	wait_ready();

	MSS_SPI_transfer_block(&g_mss_spi0, cmd, sizeof(cmd), read_Data, size);
20000a3a:	687b      	ldr	r3, [r7, #4]
20000a3c:	b29a      	uxth	r2, r3
20000a3e:	f107 0310 	add.w	r3, r7, #16
20000a42:	9200      	str	r2, [sp, #0]
20000a44:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000a48:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a4c:	4619      	mov	r1, r3
20000a4e:	f04f 0205 	mov.w	r2, #5
20000a52:	68bb      	ldr	r3, [r7, #8]
20000a54:	f002 fc8c 	bl	20003370 <MSS_SPI_transfer_block>

//	chk_busy();
//	wait_ready();

	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000a58:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000a5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a60:	f04f 0100 	mov.w	r1, #0
20000a64:	f002 fc3c 	bl	200032e0 <MSS_SPI_clear_slave_select>

}
20000a68:	f107 0718 	add.w	r7, r7, #24
20000a6c:	46bd      	mov	sp, r7
20000a6e:	bd80      	pop	{r7, pc}

20000a70 <Read_mgf_id>:

void Read_mgf_id(){
20000a70:	b580      	push	{r7, lr}
20000a72:	b084      	sub	sp, #16
20000a74:	af02      	add	r7, sp, #8
	uint8_t dummy[] = {0x90, 0x00, 0x00, 0x00};
20000a76:	f06f 036f 	mvn.w	r3, #111	; 0x6f
20000a7a:	703b      	strb	r3, [r7, #0]
20000a7c:	f04f 0300 	mov.w	r3, #0
20000a80:	707b      	strb	r3, [r7, #1]
20000a82:	f04f 0300 	mov.w	r3, #0
20000a86:	70bb      	strb	r3, [r7, #2]
20000a88:	f04f 0300 	mov.w	r3, #0
20000a8c:	70fb      	strb	r3, [r7, #3]
	MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000a8e:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000a92:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000a96:	f04f 0100 	mov.w	r1, #0
20000a9a:	f002 fb9d 	bl	200031d8 <MSS_SPI_set_slave_select>
	MSS_SPI_transfer_block(&g_mss_spi0, dummy , 4, rx_buf, 2); //Read mgf_id
20000a9e:	463b      	mov	r3, r7
20000aa0:	f04f 0202 	mov.w	r2, #2
20000aa4:	9200      	str	r2, [sp, #0]
20000aa6:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000aaa:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000aae:	4619      	mov	r1, r3
20000ab0:	f04f 0204 	mov.w	r2, #4
20000ab4:	f245 23d0 	movw	r3, #21200	; 0x52d0
20000ab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000abc:	f002 fc58 	bl	20003370 <MSS_SPI_transfer_block>
	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000ac0:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000ac4:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ac8:	f04f 0100 	mov.w	r1, #0
20000acc:	f002 fc08 	bl	200032e0 <MSS_SPI_clear_slave_select>

	uint8_t a;
}
20000ad0:	f107 0708 	add.w	r7, r7, #8
20000ad4:	46bd      	mov	sp, r7
20000ad6:	bd80      	pop	{r7, pc}

20000ad8 <Flash_unblock_blocks>:

void Flash_unblock_blocks(uint8_t cmd){
20000ad8:	b580      	push	{r7, lr}
20000ada:	b084      	sub	sp, #16
20000adc:	af02      	add	r7, sp, #8
20000ade:	4603      	mov	r3, r0
20000ae0:	71fb      	strb	r3, [r7, #7]

	MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000ae2:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000ae6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000aea:	f04f 0100 	mov.w	r1, #0
20000aee:	f002 fb73 	bl	200031d8 <MSS_SPI_set_slave_select>
	wait_ready();
20000af2:	f000 f821 	bl	20000b38 <wait_ready>
	MSS_SPI_transfer_block(&g_mss_spi0, &cmd , 1, rx_buf, 0); //Read mgf_id
20000af6:	f107 0307 	add.w	r3, r7, #7
20000afa:	f04f 0200 	mov.w	r2, #0
20000afe:	9200      	str	r2, [sp, #0]
20000b00:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000b04:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b08:	4619      	mov	r1, r3
20000b0a:	f04f 0201 	mov.w	r2, #1
20000b0e:	f245 23d0 	movw	r3, #21200	; 0x52d0
20000b12:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b16:	f002 fc2b 	bl	20003370 <MSS_SPI_transfer_block>
	wait_ready();
20000b1a:	f000 f80d 	bl	20000b38 <wait_ready>
	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000b1e:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000b22:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b26:	f04f 0100 	mov.w	r1, #0
20000b2a:	f002 fbd9 	bl	200032e0 <MSS_SPI_clear_slave_select>
}
20000b2e:	f107 0708 	add.w	r7, r7, #8
20000b32:	46bd      	mov	sp, r7
20000b34:	bd80      	pop	{r7, pc}
20000b36:	bf00      	nop

20000b38 <wait_ready>:


void wait_ready( void )
{
20000b38:	b580      	push	{r7, lr}
20000b3a:	b084      	sub	sp, #16
20000b3c:	af02      	add	r7, sp, #8
    uint8_t ready_bit;
    uint8_t command = READ_STATUS;
20000b3e:	f04f 0305 	mov.w	r3, #5
20000b42:	71bb      	strb	r3, [r7, #6]

    do {
        MSS_SPI_transfer_block( &g_mss_spi0, &command, sizeof(command), &ready_bit, sizeof(ready_bit) );
20000b44:	f107 0206 	add.w	r2, r7, #6
20000b48:	f107 0307 	add.w	r3, r7, #7
20000b4c:	f04f 0101 	mov.w	r1, #1
20000b50:	9100      	str	r1, [sp, #0]
20000b52:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000b56:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000b5a:	4611      	mov	r1, r2
20000b5c:	f04f 0201 	mov.w	r2, #1
20000b60:	f002 fc06 	bl	20003370 <MSS_SPI_transfer_block>
        ready_bit = ready_bit & READY_BIT_MASK;
20000b64:	79fb      	ldrb	r3, [r7, #7]
20000b66:	f003 0301 	and.w	r3, r3, #1
20000b6a:	71fb      	strb	r3, [r7, #7]
    } while( ready_bit == 1 );
20000b6c:	79fb      	ldrb	r3, [r7, #7]
20000b6e:	2b01      	cmp	r3, #1
20000b70:	d0e8      	beq.n	20000b44 <wait_ready+0xc>
}
20000b72:	f107 0708 	add.w	r7, r7, #8
20000b76:	46bd      	mov	sp, r7
20000b78:	bd80      	pop	{r7, pc}
20000b7a:	bf00      	nop

20000b7c <UART_Polled_Rx>:
(
    mss_uart_instance_t * this_uart,
    uint8_t * rx_buff,
    size_t buff_size
)
{
20000b7c:	b480      	push	{r7}
20000b7e:	b087      	sub	sp, #28
20000b80:	af00      	add	r7, sp, #0
20000b82:	60f8      	str	r0, [r7, #12]
20000b84:	60b9      	str	r1, [r7, #8]
20000b86:	607a      	str	r2, [r7, #4]
    size_t rx_size = 0U;
20000b88:	f04f 0300 	mov.w	r3, #0
20000b8c:	617b      	str	r3, [r7, #20]


    while( rx_size < buff_size )
20000b8e:	e016      	b.n	20000bbe <UART_Polled_Rx+0x42>
    {
       while ( ((this_uart->hw_reg->LSR) & 0x1) != 0U  )
       {
           rx_buff[rx_size] = this_uart->hw_reg->RBR;
20000b90:	68ba      	ldr	r2, [r7, #8]
20000b92:	697b      	ldr	r3, [r7, #20]
20000b94:	4413      	add	r3, r2
20000b96:	68fa      	ldr	r2, [r7, #12]
20000b98:	6812      	ldr	r2, [r2, #0]
20000b9a:	7812      	ldrb	r2, [r2, #0]
20000b9c:	b2d2      	uxtb	r2, r2
20000b9e:	701a      	strb	r2, [r3, #0]
           ++rx_size;
20000ba0:	697b      	ldr	r3, [r7, #20]
20000ba2:	f103 0301 	add.w	r3, r3, #1
20000ba6:	617b      	str	r3, [r7, #20]
20000ba8:	e000      	b.n	20000bac <UART_Polled_Rx+0x30>
    size_t rx_size = 0U;


    while( rx_size < buff_size )
    {
       while ( ((this_uart->hw_reg->LSR) & 0x1) != 0U  )
20000baa:	bf00      	nop
20000bac:	68fb      	ldr	r3, [r7, #12]
20000bae:	681b      	ldr	r3, [r3, #0]
20000bb0:	7d1b      	ldrb	r3, [r3, #20]
20000bb2:	b2db      	uxtb	r3, r3
20000bb4:	f003 0301 	and.w	r3, r3, #1
20000bb8:	b2db      	uxtb	r3, r3
20000bba:	2b00      	cmp	r3, #0
20000bbc:	d1e8      	bne.n	20000b90 <UART_Polled_Rx+0x14>
)
{
    size_t rx_size = 0U;


    while( rx_size < buff_size )
20000bbe:	697a      	ldr	r2, [r7, #20]
20000bc0:	687b      	ldr	r3, [r7, #4]
20000bc2:	429a      	cmp	r2, r3
20000bc4:	d3f1      	bcc.n	20000baa <UART_Polled_Rx+0x2e>
           rx_buff[rx_size] = this_uart->hw_reg->RBR;
           ++rx_size;
       }
    }

    return rx_size;
20000bc6:	697b      	ldr	r3, [r7, #20]
}
20000bc8:	4618      	mov	r0, r3
20000bca:	f107 071c 	add.w	r7, r7, #28
20000bce:	46bd      	mov	sp, r7
20000bd0:	bc80      	pop	{r7}
20000bd2:	4770      	bx	lr

20000bd4 <delay>:

void delay ( volatile unsigned int n)
{
20000bd4:	b480      	push	{r7}
20000bd6:	b083      	sub	sp, #12
20000bd8:	af00      	add	r7, sp, #0
20000bda:	6078      	str	r0, [r7, #4]
	while(n!=0)
20000bdc:	e003      	b.n	20000be6 <delay+0x12>
	{
		n--;
20000bde:	687b      	ldr	r3, [r7, #4]
20000be0:	f103 33ff 	add.w	r3, r3, #4294967295
20000be4:	607b      	str	r3, [r7, #4]
    return rx_size;
}

void delay ( volatile unsigned int n)
{
	while(n!=0)
20000be6:	687b      	ldr	r3, [r7, #4]
20000be8:	2b00      	cmp	r3, #0
20000bea:	d1f8      	bne.n	20000bde <delay+0xa>
	{
		n--;
	}
}
20000bec:	f107 070c 	add.w	r7, r7, #12
20000bf0:	46bd      	mov	sp, r7
20000bf2:	bc80      	pop	{r7}
20000bf4:	4770      	bx	lr
20000bf6:	bf00      	nop

20000bf8 <page_read_handler>:

uint32_t page_read_handler
(
		uint8_t const ** pp_next_page
)
{
20000bf8:	b580      	push	{r7, lr}
20000bfa:	b084      	sub	sp, #16
20000bfc:	af00      	add	r7, sp, #0
20000bfe:	6078      	str	r0, [r7, #4]

	uint32_t length;
	length = read_page_from_host_through_uart(g_page_buffer, BUFFER_SIZE);
20000c00:	f247 40e0 	movw	r0, #29920	; 0x74e0
20000c04:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000c08:	f44f 5180 	mov.w	r1, #4096	; 0x1000
20000c0c:	f000 fb72 	bl	200012f4 <read_page_from_host_through_uart>
20000c10:	4603      	mov	r3, r0
20000c12:	60fb      	str	r3, [r7, #12]
	*pp_next_page = g_page_buffer;
20000c14:	687a      	ldr	r2, [r7, #4]
20000c16:	f247 43e0 	movw	r3, #29920	; 0x74e0
20000c1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c1e:	6013      	str	r3, [r2, #0]

	return length;
20000c20:	68fb      	ldr	r3, [r7, #12]
}
20000c22:	4618      	mov	r0, r3
20000c24:	f107 0710 	add.w	r7, r7, #16
20000c28:	46bd      	mov	sp, r7
20000c2a:	bd80      	pop	{r7, pc}

20000c2c <write_to_spi>:

uint8_t write_to_spi(const void *buff,	/* Pointer to the data to be written */
		uint32_t btw			/* Number of bytes to write */

)
{
20000c2c:	b580      	push	{r7, lr}
20000c2e:	b086      	sub	sp, #24
20000c30:	af00      	add	r7, sp, #0
20000c32:	6078      	str	r0, [r7, #4]
20000c34:	6039      	str	r1, [r7, #0]
	volatile uint32_t ret= 0;
20000c36:	f04f 0300 	mov.w	r3, #0
20000c3a:	60fb      	str	r3, [r7, #12]
	const uint8_t *wbuff = (const uint8_t*)buff;
20000c3c:	687b      	ldr	r3, [r7, #4]
20000c3e:	613b      	str	r3, [r7, #16]
	uint32_t length = btw;
20000c40:	683b      	ldr	r3, [r7, #0]
20000c42:	617b      	str	r3, [r7, #20]
	if ((length%4) != 0)
20000c44:	697b      	ldr	r3, [r7, #20]
20000c46:	f003 0303 	and.w	r3, r3, #3
20000c4a:	2b00      	cmp	r3, #0
20000c4c:	d005      	beq.n	20000c5a <write_to_spi+0x2e>
	{
		length += (4-(length%4));
20000c4e:	697b      	ldr	r3, [r7, #20]
20000c50:	f023 0303 	bic.w	r3, r3, #3
20000c54:	f103 0304 	add.w	r3, r3, #4
20000c58:	617b      	str	r3, [r7, #20]
	}
	//memcpy(g_write_buf,wbuff,length);
	FLASH_program(Flash_Read_Addr+spi_offset,wbuff,length);
20000c5a:	f245 2354 	movw	r3, #21076	; 0x5254
20000c5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c62:	681a      	ldr	r2, [r3, #0]
20000c64:	f245 2358 	movw	r3, #21080	; 0x5258
20000c68:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c6c:	681b      	ldr	r3, [r3, #0]
20000c6e:	4413      	add	r3, r2
20000c70:	4618      	mov	r0, r3
20000c72:	6939      	ldr	r1, [r7, #16]
20000c74:	697a      	ldr	r2, [r7, #20]
20000c76:	f7ff fcfd 	bl	20000674 <FLASH_program>

	flash_read(Flash_Read_Addr+spi_offset,g_read_buf,length);
20000c7a:	f245 2354 	movw	r3, #21076	; 0x5254
20000c7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c82:	681a      	ldr	r2, [r3, #0]
20000c84:	f245 2358 	movw	r3, #21080	; 0x5258
20000c88:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c8c:	681b      	ldr	r3, [r3, #0]
20000c8e:	4413      	add	r3, r2
20000c90:	4618      	mov	r0, r3
20000c92:	f247 21e0 	movw	r1, #29408	; 0x72e0
20000c96:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000c9a:	697a      	ldr	r2, [r7, #20]
20000c9c:	f7ff fe5c 	bl	20000958 <flash_read>

	if (memcmp(g_read_buf,wbuff,length) != 0)
20000ca0:	f247 20e0 	movw	r0, #29408	; 0x72e0
20000ca4:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ca8:	6939      	ldr	r1, [r7, #16]
20000caa:	697a      	ldr	r2, [r7, #20]
20000cac:	f003 fed4 	bl	20004a58 <memcmp>
20000cb0:	4603      	mov	r3, r0
20000cb2:	2b00      	cmp	r3, #0
20000cb4:	d00e      	beq.n	20000cd4 <write_to_spi+0xa8>
	{
		MSS_UART_polled_tx(gp_my_uart,"F\t",2);
20000cb6:	f644 7364 	movw	r3, #20324	; 0x4f64
20000cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cbe:	681b      	ldr	r3, [r3, #0]
20000cc0:	4618      	mov	r0, r3
20000cc2:	f644 7168 	movw	r1, #20328	; 0x4f68
20000cc6:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000cca:	f04f 0202 	mov.w	r2, #2
20000cce:	f000 fd11 	bl	200016f4 <MSS_UART_polled_tx>
20000cd2:	e00d      	b.n	20000cf0 <write_to_spi+0xc4>
		//printf("o=%d ",spi_offset);

	}
	else
	{
		MSS_UART_polled_tx(gp_my_uart,"S\t",2);
20000cd4:	f644 7364 	movw	r3, #20324	; 0x4f64
20000cd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cdc:	681b      	ldr	r3, [r3, #0]
20000cde:	4618      	mov	r0, r3
20000ce0:	f644 716c 	movw	r1, #20332	; 0x4f6c
20000ce4:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000ce8:	f04f 0202 	mov.w	r2, #2
20000cec:	f000 fd02 	bl	200016f4 <MSS_UART_polled_tx>
	else
	{
		//printf("\t*\t");
	}
#endif
	spi_offset += length;
20000cf0:	f245 2358 	movw	r3, #21080	; 0x5258
20000cf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cf8:	681a      	ldr	r2, [r3, #0]
20000cfa:	697b      	ldr	r3, [r7, #20]
20000cfc:	441a      	add	r2, r3
20000cfe:	f245 2358 	movw	r3, #21080	; 0x5258
20000d02:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d06:	601a      	str	r2, [r3, #0]
//	if(spi_offset%10240 == 0)
//	{
//		MSS_UART_polled_tx(&g_mss_uart1,".",1);
//	}
	return ret;
20000d08:	68fb      	ldr	r3, [r7, #12]
20000d0a:	b2db      	uxtb	r3, r3
}
20000d0c:	4618      	mov	r0, r3
20000d0e:	f107 0718 	add.w	r7, r7, #24
20000d12:	46bd      	mov	sp, r7
20000d14:	bd80      	pop	{r7, pc}
20000d16:	bf00      	nop

20000d18 <main>:



int main()
{
20000d18:	b580      	push	{r7, lr}
20000d1a:	b09a      	sub	sp, #104	; 0x68
20000d1c:	af02      	add	r7, sp, #8
	nvm_status_t status;
	uint16_t length, i;
	uint8_t auth_status;
	uint8_t prog_status;
	i = 0;
20000d1e:	f04f 0300 	mov.w	r3, #0
20000d22:	877b      	strh	r3, [r7, #58]	; 0x3a
	uint8_t rx_buf[1];

    for(;i<16;i++){
20000d24:	e00b      	b.n	20000d3e <main+0x26>
    	rx_buff[i] = 0;
20000d26:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
20000d28:	f245 23e0 	movw	r3, #21216	; 0x52e0
20000d2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d30:	f04f 0100 	mov.w	r1, #0
20000d34:	5499      	strb	r1, [r3, r2]
	uint8_t auth_status;
	uint8_t prog_status;
	i = 0;
	uint8_t rx_buf[1];

    for(;i<16;i++){
20000d36:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
20000d38:	f103 0301 	add.w	r3, r3, #1
20000d3c:	877b      	strh	r3, [r7, #58]	; 0x3a
20000d3e:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
20000d40:	2b0f      	cmp	r3, #15
20000d42:	d9f0      	bls.n	20000d26 <main+0xe>
    	rx_buff[i] = 0;
    }
    i = 0;
20000d44:	f04f 0300 	mov.w	r3, #0
20000d48:	877b      	strh	r3, [r7, #58]	; 0x3a
    uint8_t dummy[2] = {0x90, 0xAB};
20000d4a:	f644 73c0 	movw	r3, #20416	; 0x4fc0
20000d4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d52:	881b      	ldrh	r3, [r3, #0]
20000d54:	863b      	strh	r3, [r7, #48]	; 0x30
    uint8_t msg[33] = "I have been recovered with 50MHZ\n";
20000d56:	f644 738c 	movw	r3, #20364	; 0x4f8c
20000d5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d5e:	f107 0c0c 	add.w	ip, r7, #12
20000d62:	469e      	mov	lr, r3
20000d64:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20000d68:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20000d6c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20000d70:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20000d74:	f8de 3000 	ldr.w	r3, [lr]
20000d78:	f88c 3000 	strb.w	r3, [ip]
    uint8_t wr_cmd[] = {0x20};
20000d7c:	f04f 0320 	mov.w	r3, #32
20000d80:	723b      	strb	r3, [r7, #8]
    uint8_t count;
	unsigned long long int Flash_read_address = 0x000000;
20000d82:	f04f 0200 	mov.w	r2, #0
20000d86:	f04f 0300 	mov.w	r3, #0
20000d8a:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
	unsigned long long int NVM_Write_Addr = 0x00000;
20000d8e:	f04f 0200 	mov.w	r2, #0
20000d92:	f04f 0300 	mov.w	r3, #0
20000d96:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
//	unsigned long long int NVM_Read_Addr = 0x60000000;

//	NVM_Read_Addr = 0x60000000;

    MSS_UART_init(gp_my_uart, MSS_UART_57600_BAUD, MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);
20000d9a:	f644 7364 	movw	r3, #20324	; 0x4f64
20000d9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000da2:	681b      	ldr	r3, [r3, #0]
20000da4:	4618      	mov	r0, r3
20000da6:	f44f 4161 	mov.w	r1, #57600	; 0xe100
20000daa:	f04f 0203 	mov.w	r2, #3
20000dae:	f000 fc5f 	bl	20001670 <MSS_UART_init>
//    NVM_Read_Addr += 1;
//    a = (uint32_t *) NVM_Read_Addr;
//    rx_buff[1] = a[0];
//    rx_buff[2] = a[2];
//    count = *a;
        uint8_t sr_read1 = READ_STAT_REG1;
20000db2:	f04f 0305 	mov.w	r3, #5
20000db6:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		uint8_t sr_read3 = READ_STAT_REG3;
20000dba:	f04f 0315 	mov.w	r3, #21
20000dbe:	f887 3058 	strb.w	r3, [r7, #88]	; 0x58

//while(1){
//	MSS_UART_polled_tx(gp_my_uart, msg, 33);
//}

		MSS_SYS_init(MSS_SYS_NO_EVENT_HANDLER);
20000dc2:	f04f 0000 	mov.w	r0, #0
20000dc6:	f001 f8c9 	bl	20001f5c <MSS_SYS_init>
		MSS_SPI_init( &g_mss_spi0 );
20000dca:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000dce:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000dd2:	f002 f80f 	bl	20002df4 <MSS_SPI_init>

		MSS_SPI_configure_master_mode
20000dd6:	f04f 0308 	mov.w	r3, #8
20000dda:	9300      	str	r3, [sp, #0]
20000ddc:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000de0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000de4:	f04f 0100 	mov.w	r1, #0
20000de8:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
20000dec:	f04f 0308 	mov.w	r3, #8
20000df0:	f002 f94a 	bl	20003088 <MSS_SPI_configure_master_mode>
				8u,
				8
			);
////////
//////		isp_status = MSS_SYS_start_isp(MSS_SYS_PROG_AUTHENTICATE, page_read_handler, isp_completion_handler);
		MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 ); // Slave SELECT signal asserted
20000df4:	f248 50f8 	movw	r0, #34296	; 0x85f8
20000df8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000dfc:	f04f 0100 	mov.w	r1, #0
20000e00:	f002 f9ea 	bl	200031d8 <MSS_SPI_set_slave_select>
//		Flash_write_enable(WREN);
		g_mss_spi0.hw_reg->CONTROL |= (0x04000000);
20000e04:	f248 53f8 	movw	r3, #34296	; 0x85f8
20000e08:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e0c:	681a      	ldr	r2, [r3, #0]
20000e0e:	f248 53f8 	movw	r3, #34296	; 0x85f8
20000e12:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e16:	681b      	ldr	r3, [r3, #0]
20000e18:	681b      	ldr	r3, [r3, #0]
20000e1a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
20000e1e:	6013      	str	r3, [r2, #0]
		delay(80000);
20000e20:	f643 0080 	movw	r0, #14464	; 0x3880
20000e24:	f2c0 0001 	movt	r0, #1
20000e28:	f7ff fed4 	bl	20000bd4 <delay>
//		{
//			MSS_UART_polled_tx_string(gp_my_uart,(const uint8_t * )"IAP operation is successful\n\r");
//
//		}

		prog_status = MSS_SYS_initiate_iap(MSS_SYS_PROG_PROGRAM, 0x000000);
20000e2c:	f04f 0001 	mov.w	r0, #1
20000e30:	f04f 0100 	mov.w	r1, #0
20000e34:	f001 fdee 	bl	20002a14 <MSS_SYS_initiate_iap>
20000e38:	4603      	mov	r3, r0
20000e3a:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
	//	MSS_SPI_transfer_block(&g_mss_spi0, CMD1, 1, rx_buf, 1); //Reset
	//	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);

	//	while(1){
		uint8_t device_id;
		uint8_t write_sr3[] = {0x11, 0x64};
20000e3e:	f644 73c4 	movw	r3, #20420	; 0x4fc4
20000e42:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e46:	881b      	ldrh	r3, [r3, #0]
20000e48:	80bb      	strh	r3, [r7, #4]

	Read_mgf_id();
20000e4a:	f7ff fe11 	bl	20000a70 <Read_mgf_id>

	flash_erase();
20000e4e:	f7ff fce9 	bl	20000824 <flash_erase>

	flash_fast_read(Flash_read_address, rx_buff, sizeof(rx_buff));
20000e52:	6c3b      	ldr	r3, [r7, #64]	; 0x40
20000e54:	4618      	mov	r0, r3
20000e56:	f245 21e0 	movw	r1, #21216	; 0x52e0
20000e5a:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000e5e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
20000e62:	f7ff fdc1 	bl	200009e8 <flash_fast_read>




      MSS_SYS_init(MSS_SYS_NO_EVENT_HANDLER);
20000e66:	f04f 0000 	mov.w	r0, #0
20000e6a:	f001 f877 	bl	20001f5c <MSS_SYS_init>
20000e6e:	e000      	b.n	20000e72 <main+0x15a>
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
              ;
           if(rx_buff[0] == 'h')
              MSS_UART_polled_tx( gp_my_uart, (const uint8_t * )"a", 1 );
           else
        	   goto START_HANDSHAKE;
20000e70:	bf00      	nop


      MSS_SYS_init(MSS_SYS_NO_EVENT_HANDLER);
      /* start the handshake with the host */
      START_HANDSHAKE:
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
20000e72:	f644 7364 	movw	r3, #20324	; 0x4f64
20000e76:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e7a:	681b      	ldr	r3, [r3, #0]
20000e7c:	4618      	mov	r0, r3
20000e7e:	f245 21e0 	movw	r1, #21216	; 0x52e0
20000e82:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000e86:	f04f 0201 	mov.w	r2, #1
20000e8a:	f7ff fe77 	bl	20000b7c <UART_Polled_Rx>
20000e8e:	4603      	mov	r3, r0
20000e90:	2b00      	cmp	r3, #0
20000e92:	d0ee      	beq.n	20000e72 <main+0x15a>
              ;
           if(rx_buff[0] == 'h')
20000e94:	f245 23e0 	movw	r3, #21216	; 0x52e0
20000e98:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e9c:	781b      	ldrb	r3, [r3, #0]
20000e9e:	2b68      	cmp	r3, #104	; 0x68
20000ea0:	d1e6      	bne.n	20000e70 <main+0x158>
              MSS_UART_polled_tx( gp_my_uart, (const uint8_t * )"a", 1 );
20000ea2:	f644 7364 	movw	r3, #20324	; 0x4f64
20000ea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000eaa:	681b      	ldr	r3, [r3, #0]
20000eac:	4618      	mov	r0, r3
20000eae:	f644 7170 	movw	r1, #20336	; 0x4f70
20000eb2:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000eb6:	f04f 0201 	mov.w	r2, #1
20000eba:	f000 fc1b 	bl	200016f4 <MSS_UART_polled_tx>
           else
        	   goto START_HANDSHAKE;
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
20000ebe:	f644 7364 	movw	r3, #20324	; 0x4f64
20000ec2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ec6:	681b      	ldr	r3, [r3, #0]
20000ec8:	4618      	mov	r0, r3
20000eca:	f245 21e0 	movw	r1, #21216	; 0x52e0
20000ece:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000ed2:	f04f 0201 	mov.w	r2, #1
20000ed6:	f7ff fe51 	bl	20000b7c <UART_Polled_Rx>
20000eda:	4603      	mov	r3, r0
20000edc:	2b00      	cmp	r3, #0
20000ede:	d0ee      	beq.n	20000ebe <main+0x1a6>
              ;
           if(rx_buff[0] == 'n')
20000ee0:	f245 23e0 	movw	r3, #21216	; 0x52e0
20000ee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ee8:	781b      	ldrb	r3, [r3, #0]
20000eea:	2b6e      	cmp	r3, #110	; 0x6e
20000eec:	d10d      	bne.n	20000f0a <main+0x1f2>
              MSS_UART_polled_tx( gp_my_uart, (const uint8_t * )"d", 1 );
20000eee:	f644 7364 	movw	r3, #20324	; 0x4f64
20000ef2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ef6:	681b      	ldr	r3, [r3, #0]
20000ef8:	4618      	mov	r0, r3
20000efa:	f644 7174 	movw	r1, #20340	; 0x4f74
20000efe:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000f02:	f04f 0201 	mov.w	r2, #1
20000f06:	f000 fbf5 	bl	200016f4 <MSS_UART_polled_tx>
           while(!(UART_Polled_Rx (gp_my_uart, rx_buff, 1 )))
20000f0a:	f644 7364 	movw	r3, #20324	; 0x4f64
20000f0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f12:	681b      	ldr	r3, [r3, #0]
20000f14:	4618      	mov	r0, r3
20000f16:	f245 21e0 	movw	r1, #21216	; 0x52e0
20000f1a:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000f1e:	f04f 0201 	mov.w	r2, #1
20000f22:	f7ff fe2b 	bl	20000b7c <UART_Polled_Rx>
20000f26:	4603      	mov	r3, r0
20000f28:	2b00      	cmp	r3, #0
20000f2a:	d0ee      	beq.n	20000f0a <main+0x1f2>
              ;
           if(rx_buff[0] == 's')
20000f2c:	f245 23e0 	movw	r3, #21216	; 0x52e0
20000f30:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f34:	781b      	ldrb	r3, [r3, #0]
20000f36:	2b73      	cmp	r3, #115	; 0x73
20000f38:	d10d      	bne.n	20000f56 <main+0x23e>
              MSS_UART_polled_tx( gp_my_uart, (const uint8_t * )"h", 1 );
20000f3a:	f644 7364 	movw	r3, #20324	; 0x4f64
20000f3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f42:	681b      	ldr	r3, [r3, #0]
20000f44:	4618      	mov	r0, r3
20000f46:	f644 7178 	movw	r1, #20344	; 0x4f78
20000f4a:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000f4e:	f04f 0201 	mov.w	r2, #1
20000f52:	f000 fbcf 	bl	200016f4 <MSS_UART_polled_tx>
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
20000f56:	f644 7364 	movw	r3, #20324	; 0x4f64
20000f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f5e:	681b      	ldr	r3, [r3, #0]
20000f60:	4618      	mov	r0, r3
20000f62:	f245 21e0 	movw	r1, #21216	; 0x52e0
20000f66:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000f6a:	f04f 0201 	mov.w	r2, #1
20000f6e:	f7ff fe05 	bl	20000b7c <UART_Polled_Rx>
20000f72:	4603      	mov	r3, r0
20000f74:	2b00      	cmp	r3, #0
20000f76:	d0ee      	beq.n	20000f56 <main+0x23e>
              ;
           if(rx_buff[0] == 'a')
20000f78:	f245 23e0 	movw	r3, #21216	; 0x52e0
20000f7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f80:	781b      	ldrb	r3, [r3, #0]
20000f82:	2b61      	cmp	r3, #97	; 0x61
20000f84:	d10d      	bne.n	20000fa2 <main+0x28a>
              MSS_UART_polled_tx( gp_my_uart, (const uint8_t * )"k", 1 );
20000f86:	f644 7364 	movw	r3, #20324	; 0x4f64
20000f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f8e:	681b      	ldr	r3, [r3, #0]
20000f90:	4618      	mov	r0, r3
20000f92:	f644 717c 	movw	r1, #20348	; 0x4f7c
20000f96:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000f9a:	f04f 0201 	mov.w	r2, #1
20000f9e:	f000 fba9 	bl	200016f4 <MSS_UART_polled_tx>
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
20000fa2:	f644 7364 	movw	r3, #20324	; 0x4f64
20000fa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000faa:	681b      	ldr	r3, [r3, #0]
20000fac:	4618      	mov	r0, r3
20000fae:	f245 21e0 	movw	r1, #21216	; 0x52e0
20000fb2:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000fb6:	f04f 0201 	mov.w	r2, #1
20000fba:	f7ff fddf 	bl	20000b7c <UART_Polled_Rx>
20000fbe:	4603      	mov	r3, r0
20000fc0:	2b00      	cmp	r3, #0
20000fc2:	d0ee      	beq.n	20000fa2 <main+0x28a>
              ;
           if(rx_buff[0] == 'e')
20000fc4:	f245 23e0 	movw	r3, #21216	; 0x52e0
20000fc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000fcc:	781b      	ldrb	r3, [r3, #0]
20000fce:	2b65      	cmp	r3, #101	; 0x65
20000fd0:	d10d      	bne.n	20000fee <main+0x2d6>
			{
		       MSS_UART_polled_tx( gp_my_uart, (const uint8_t * )"r", 1 );
20000fd2:	f644 7364 	movw	r3, #20324	; 0x4f64
20000fd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000fda:	681b      	ldr	r3, [r3, #0]
20000fdc:	4618      	mov	r0, r3
20000fde:	f644 7180 	movw	r1, #20352	; 0x4f80
20000fe2:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000fe6:	f04f 0201 	mov.w	r2, #1
20000fea:	f000 fb83 	bl	200016f4 <MSS_UART_polled_tx>
			}
           /* poll for starting Ack message from the host as an acknowledgment
                   that the host is ready to send file size */

			while(!(UART_Polled_Rx (gp_my_uart, rx_buff, 1 )))
20000fee:	f644 7364 	movw	r3, #20324	; 0x4f64
20000ff2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ff6:	681b      	ldr	r3, [r3, #0]
20000ff8:	4618      	mov	r0, r3
20000ffa:	f245 21e0 	movw	r1, #21216	; 0x52e0
20000ffe:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001002:	f04f 0201 	mov.w	r2, #1
20001006:	f7ff fdb9 	bl	20000b7c <UART_Polled_Rx>
2000100a:	4603      	mov	r3, r0
2000100c:	2b00      	cmp	r3, #0
2000100e:	d0ee      	beq.n	20000fee <main+0x2d6>
			   ;
			MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"a",1);
20001010:	f644 7364 	movw	r3, #20324	; 0x4f64
20001014:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001018:	681b      	ldr	r3, [r3, #0]
2000101a:	4618      	mov	r0, r3
2000101c:	f644 7170 	movw	r1, #20336	; 0x4f70
20001020:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001024:	f04f 0201 	mov.w	r2, #1
20001028:	f000 fb64 	bl	200016f4 <MSS_UART_polled_tx>
			/*poll for mode */
			MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"m",1);
2000102c:	f644 7364 	movw	r3, #20324	; 0x4f64
20001030:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001034:	681b      	ldr	r3, [r3, #0]
20001036:	4618      	mov	r0, r3
20001038:	f644 7184 	movw	r1, #20356	; 0x4f84
2000103c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001040:	f04f 0201 	mov.w	r2, #1
20001044:	f000 fb56 	bl	200016f4 <MSS_UART_polled_tx>
			while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
20001048:	f644 7364 	movw	r3, #20324	; 0x4f64
2000104c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001050:	681b      	ldr	r3, [r3, #0]
20001052:	4618      	mov	r0, r3
20001054:	f245 21e0 	movw	r1, #21216	; 0x52e0
20001058:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000105c:	f04f 0201 	mov.w	r2, #1
20001060:	f7ff fd8c 	bl	20000b7c <UART_Polled_Rx>
20001064:	4603      	mov	r3, r0
20001066:	2b00      	cmp	r3, #0
20001068:	d0ee      	beq.n	20001048 <main+0x330>
									  ;
		    g_mode  = rx_buff[0];
2000106a:	f245 23e0 	movw	r3, #21216	; 0x52e0
2000106e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001072:	781a      	ldrb	r2, [r3, #0]
20001074:	f245 2364 	movw	r3, #21092	; 0x5264
20001078:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000107c:	701a      	strb	r2, [r3, #0]
			/*poll for file size*/
			MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"z",1);
2000107e:	f644 7364 	movw	r3, #20324	; 0x4f64
20001082:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001086:	681b      	ldr	r3, [r3, #0]
20001088:	4618      	mov	r0, r3
2000108a:	f644 7188 	movw	r1, #20360	; 0x4f88
2000108e:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001092:	f04f 0201 	mov.w	r2, #1
20001096:	f000 fb2d 	bl	200016f4 <MSS_UART_polled_tx>
			while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 8 )))
2000109a:	f644 7364 	movw	r3, #20324	; 0x4f64
2000109e:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010a2:	681b      	ldr	r3, [r3, #0]
200010a4:	4618      	mov	r0, r3
200010a6:	f245 21e0 	movw	r1, #21216	; 0x52e0
200010aa:	f2c2 0100 	movt	r1, #8192	; 0x2000
200010ae:	f04f 0208 	mov.w	r2, #8
200010b2:	f7ff fd63 	bl	20000b7c <UART_Polled_Rx>
200010b6:	4603      	mov	r3, r0
200010b8:	2b00      	cmp	r3, #0
200010ba:	d0ee      	beq.n	2000109a <main+0x382>
			              ;
			g_file_size = atoi((const char*)rx_buff);
200010bc:	f245 20e0 	movw	r0, #21216	; 0x52e0
200010c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200010c4:	f003 fc9c 	bl	20004a00 <atoi>
200010c8:	4603      	mov	r3, r0
200010ca:	461a      	mov	r2, r3
200010cc:	f245 2368 	movw	r3, #21096	; 0x5268
200010d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010d4:	601a      	str	r2, [r3, #0]

			MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"a",1);
200010d6:	f644 7364 	movw	r3, #20324	; 0x4f64
200010da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010de:	681b      	ldr	r3, [r3, #0]
200010e0:	4618      	mov	r0, r3
200010e2:	f644 7170 	movw	r1, #20336	; 0x4f70
200010e6:	f2c2 0100 	movt	r1, #8192	; 0x2000
200010ea:	f04f 0201 	mov.w	r2, #1
200010ee:	f000 fb01 	bl	200016f4 <MSS_UART_polled_tx>

			ite_4096 = g_file_size / 4096;
200010f2:	f245 2368 	movw	r3, #21096	; 0x5268
200010f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010fa:	681b      	ldr	r3, [r3, #0]
200010fc:	ea4f 3313 	mov.w	r3, r3, lsr #12
20001100:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a


			switch(g_mode)
20001104:	f245 2364 	movw	r3, #21092	; 0x5264
20001108:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000110c:	781b      	ldrb	r3, [r3, #0]
2000110e:	2b31      	cmp	r3, #49	; 0x31
20001110:	d011      	beq.n	20001136 <main+0x41e>
20001112:	2b32      	cmp	r3, #50	; 0x32
20001114:	d01c      	beq.n	20001150 <main+0x438>
20001116:	2b30      	cmp	r3, #48	; 0x30
20001118:	d000      	beq.n	2000111c <main+0x404>
2000111a:	e0b3      	b.n	20001284 <main+0x56c>
			{
			case '0':
				MSS_SYS_start_isp(MSS_SYS_PROG_AUTHENTICATE,page_read_handler,isp_completion_handler);
2000111c:	f04f 0000 	mov.w	r0, #0
20001120:	f640 31f9 	movw	r1, #3065	; 0xbf9
20001124:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001128:	f241 2289 	movw	r2, #4745	; 0x1289
2000112c:	f2c2 0200 	movt	r2, #8192	; 0x2000
20001130:	f001 fbc6 	bl	200028c0 <MSS_SYS_start_isp>
				break;
20001134:	e0a6      	b.n	20001284 <main+0x56c>
			case '1':
				MSS_SYS_start_isp(MSS_SYS_PROG_PROGRAM,page_read_handler,isp_completion_handler);
20001136:	f04f 0001 	mov.w	r0, #1
2000113a:	f640 31f9 	movw	r1, #3065	; 0xbf9
2000113e:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001142:	f241 2289 	movw	r2, #4745	; 0x1289
20001146:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000114a:	f001 fbb9 	bl	200028c0 <MSS_SYS_start_isp>
				break;
2000114e:	e099      	b.n	20001284 <main+0x56c>
			case '2':

				MSS_SYS_init(MSS_SYS_NO_EVENT_HANDLER);
20001150:	f04f 0000 	mov.w	r0, #0
20001154:	f000 ff02 	bl	20001f5c <MSS_SYS_init>

//				length = read_page_from_host_through_uart(g_page_buffer, BUFFER_SIZE);
//				status = NVM_write(0x0, g_page_buffer, sizeof(g_page_buffer), NVM_DO_NOT_LOCK_PAGE);

				for(;i<ite_4096;i++){
20001158:	e015      	b.n	20001186 <main+0x46e>
					length = read_page_from_host_through_uart(prog_buf, BUFFER_SIZE);
2000115a:	f246 20e0 	movw	r0, #25312	; 0x62e0
2000115e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001162:	f44f 5180 	mov.w	r1, #4096	; 0x1000
20001166:	f000 f8c5 	bl	200012f4 <read_page_from_host_through_uart>
2000116a:	4603      	mov	r3, r0
2000116c:	873b      	strh	r3, [r7, #56]	; 0x38

					write_to_spi(prog_buf, BUFFER_SIZE);
2000116e:	f246 20e0 	movw	r0, #25312	; 0x62e0
20001172:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001176:	f44f 5180 	mov.w	r1, #4096	; 0x1000
2000117a:	f7ff fd57 	bl	20000c2c <write_to_spi>
				MSS_SYS_init(MSS_SYS_NO_EVENT_HANDLER);

//				length = read_page_from_host_through_uart(g_page_buffer, BUFFER_SIZE);
//				status = NVM_write(0x0, g_page_buffer, sizeof(g_page_buffer), NVM_DO_NOT_LOCK_PAGE);

				for(;i<ite_4096;i++){
2000117e:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
20001180:	f103 0301 	add.w	r3, r3, #1
20001184:	877b      	strh	r3, [r7, #58]	; 0x3a
20001186:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
20001188:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
2000118c:	429a      	cmp	r2, r3
2000118e:	d3e4      	bcc.n	2000115a <main+0x442>

					write_to_spi(prog_buf, BUFFER_SIZE);

				}

				i = 0;
20001190:	f04f 0300 	mov.w	r3, #0
20001194:	877b      	strh	r3, [r7, #58]	; 0x3a

				if(ite_4096 % 4096 != 0){
20001196:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
2000119a:	ea4f 5303 	mov.w	r3, r3, lsl #20
2000119e:	ea4f 5313 	mov.w	r3, r3, lsr #20
200011a2:	2b00      	cmp	r3, #0
200011a4:	d06e      	beq.n	20001284 <main+0x56c>
					if((g_file_size % 4096) < 256){
200011a6:	f245 2368 	movw	r3, #21096	; 0x5268
200011aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011ae:	681b      	ldr	r3, [r3, #0]
200011b0:	ea4f 5303 	mov.w	r3, r3, lsl #20
200011b4:	ea4f 5313 	mov.w	r3, r3, lsr #20
200011b8:	2bff      	cmp	r3, #255	; 0xff
200011ba:	d81b      	bhi.n	200011f4 <main+0x4dc>
						remain_bytes = g_file_size % 4096;
200011bc:	f245 2368 	movw	r3, #21096	; 0x5268
200011c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011c4:	681b      	ldr	r3, [r3, #0]
200011c6:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
						length = read_page_from_host_through_uart(prog_buf, remain_bytes);
200011ca:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
200011ce:	f246 20e0 	movw	r0, #25312	; 0x62e0
200011d2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200011d6:	4619      	mov	r1, r3
200011d8:	f000 f88c 	bl	200012f4 <read_page_from_host_through_uart>
200011dc:	4603      	mov	r3, r0
200011de:	873b      	strh	r3, [r7, #56]	; 0x38
						write_to_spi(prog_buf, remain_bytes);
200011e0:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
200011e4:	f246 20e0 	movw	r0, #25312	; 0x62e0
200011e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200011ec:	4619      	mov	r1, r3
200011ee:	f7ff fd1d 	bl	20000c2c <write_to_spi>
200011f2:	e047      	b.n	20001284 <main+0x56c>
					}
					else{
						ite_256 = (g_file_size % 4096) / 256;
200011f4:	f245 2368 	movw	r3, #21096	; 0x5268
200011f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011fc:	681b      	ldr	r3, [r3, #0]
200011fe:	ea4f 5303 	mov.w	r3, r3, lsl #20
20001202:	ea4f 5313 	mov.w	r3, r3, lsr #20
20001206:	ea4f 2313 	mov.w	r3, r3, lsr #8
2000120a:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
						remain_bytes = (g_file_size % 4096) % 256;
2000120e:	f245 2368 	movw	r3, #21096	; 0x5268
20001212:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001216:	681b      	ldr	r3, [r3, #0]
20001218:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
						for(;i<ite_256;i++){
2000121c:	e015      	b.n	2000124a <main+0x532>
							length = read_page_from_host_through_uart(prog_buf, 256);
2000121e:	f246 20e0 	movw	r0, #25312	; 0x62e0
20001222:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001226:	f44f 7180 	mov.w	r1, #256	; 0x100
2000122a:	f000 f863 	bl	200012f4 <read_page_from_host_through_uart>
2000122e:	4603      	mov	r3, r0
20001230:	873b      	strh	r3, [r7, #56]	; 0x38
							write_to_spi(prog_buf, 256);
20001232:	f246 20e0 	movw	r0, #25312	; 0x62e0
20001236:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000123a:	f44f 7180 	mov.w	r1, #256	; 0x100
2000123e:	f7ff fcf5 	bl	20000c2c <write_to_spi>
						write_to_spi(prog_buf, remain_bytes);
					}
					else{
						ite_256 = (g_file_size % 4096) / 256;
						remain_bytes = (g_file_size % 4096) % 256;
						for(;i<ite_256;i++){
20001242:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
20001244:	f103 0301 	add.w	r3, r3, #1
20001248:	877b      	strh	r3, [r7, #58]	; 0x3a
2000124a:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
2000124e:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
20001250:	429a      	cmp	r2, r3
20001252:	d3e4      	bcc.n	2000121e <main+0x506>
							length = read_page_from_host_through_uart(prog_buf, 256);
							write_to_spi(prog_buf, 256);
						}
						if(remain_bytes != 0){
20001254:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
20001258:	2b00      	cmp	r3, #0
2000125a:	d013      	beq.n	20001284 <main+0x56c>
							length = read_page_from_host_through_uart(prog_buf, remain_bytes);
2000125c:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
20001260:	f246 20e0 	movw	r0, #25312	; 0x62e0
20001264:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001268:	4619      	mov	r1, r3
2000126a:	f000 f843 	bl	200012f4 <read_page_from_host_through_uart>
2000126e:	4603      	mov	r3, r0
20001270:	873b      	strh	r3, [r7, #56]	; 0x38
							write_to_spi(prog_buf, remain_bytes);
20001272:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
20001276:	f246 20e0 	movw	r0, #25312	; 0x62e0
2000127a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000127e:	4619      	mov	r1, r3
20001280:	f7ff fcd4 	bl	20000c2c <write_to_spi>
				break;
			}
			while(1)
			{

			}
20001284:	e7fe      	b.n	20001284 <main+0x56c>
20001286:	bf00      	nop

20001288 <isp_completion_handler>:
/*==============================================================================
  ISP function to get status after completion of ISP operation.
 */

void isp_completion_handler(uint32_t value)
{
20001288:	b580      	push	{r7, lr}
2000128a:	b082      	sub	sp, #8
2000128c:	af00      	add	r7, sp, #0
2000128e:	6078      	str	r0, [r7, #4]
  if (value == MSS_SYS_SUCCESS)
20001290:	687b      	ldr	r3, [r7, #4]
20001292:	2b00      	cmp	r3, #0
20001294:	d10e      	bne.n	200012b4 <isp_completion_handler+0x2c>
  {

	  MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"p",1);
20001296:	f644 7364 	movw	r3, #20324	; 0x4f64
2000129a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000129e:	681b      	ldr	r3, [r3, #0]
200012a0:	4618      	mov	r0, r3
200012a2:	f644 71b0 	movw	r1, #20400	; 0x4fb0
200012a6:	f2c2 0100 	movt	r1, #8192	; 0x2000
200012aa:	f04f 0201 	mov.w	r2, #1
200012ae:	f000 fa21 	bl	200016f4 <MSS_UART_polled_tx>
200012b2:	e01a      	b.n	200012ea <isp_completion_handler+0x62>


  }
  else
  {
	  MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"q",1);
200012b4:	f644 7364 	movw	r3, #20324	; 0x4f64
200012b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200012bc:	681b      	ldr	r3, [r3, #0]
200012be:	4618      	mov	r0, r3
200012c0:	f644 71b4 	movw	r1, #20404	; 0x4fb4
200012c4:	f2c2 0100 	movt	r1, #8192	; 0x2000
200012c8:	f04f 0201 	mov.w	r2, #1
200012cc:	f000 fa12 	bl	200016f4 <MSS_UART_polled_tx>
	  MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )&value,8);
200012d0:	f644 7364 	movw	r3, #20324	; 0x4f64
200012d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200012d8:	681a      	ldr	r2, [r3, #0]
200012da:	f107 0304 	add.w	r3, r7, #4
200012de:	4610      	mov	r0, r2
200012e0:	4619      	mov	r1, r3
200012e2:	f04f 0208 	mov.w	r2, #8
200012e6:	f000 fa05 	bl	200016f4 <MSS_UART_polled_tx>
  }
}
200012ea:	f107 0708 	add.w	r7, r7, #8
200012ee:	46bd      	mov	sp, r7
200012f0:	bd80      	pop	{r7, pc}
200012f2:	bf00      	nop

200012f4 <read_page_from_host_through_uart>:
static uint32_t read_page_from_host_through_uart
(
    uint8_t * g_buffer,
    uint32_t length
)
{
200012f4:	b580      	push	{r7, lr}
200012f6:	b088      	sub	sp, #32
200012f8:	af00      	add	r7, sp, #0
200012fa:	6078      	str	r0, [r7, #4]
200012fc:	6039      	str	r1, [r7, #0]
    uint32_t num_bytes,factor,temp;

    num_bytes = length;
200012fe:	683b      	ldr	r3, [r7, #0]
20001300:	613b      	str	r3, [r7, #16]
    char crc;
    size_t rx_size = 0;
20001302:	f04f 0300 	mov.w	r3, #0
20001306:	61fb      	str	r3, [r7, #28]
   	uint8_t rx_buff[1];
    //Write Ack "b" to indicate beginning of the transaction from the target
    	if(g_bkup != g_src_image_target_address)
20001308:	f245 2360 	movw	r3, #21088	; 0x5260
2000130c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001310:	681a      	ldr	r2, [r3, #0]
20001312:	f245 235c 	movw	r3, #21084	; 0x525c
20001316:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000131a:	681b      	ldr	r3, [r3, #0]
2000131c:	429a      	cmp	r2, r3
2000131e:	d010      	beq.n	20001342 <read_page_from_host_through_uart+0x4e>
    	{
    		if(g_src_image_target_address == 0)
20001320:	f245 235c 	movw	r3, #21084	; 0x525c
20001324:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001328:	681b      	ldr	r3, [r3, #0]
2000132a:	2b00      	cmp	r3, #0
2000132c:	d109      	bne.n	20001342 <read_page_from_host_through_uart+0x4e>
    			g_src_image_target_address = g_bkup;
2000132e:	f245 2360 	movw	r3, #21088	; 0x5260
20001332:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001336:	681a      	ldr	r2, [r3, #0]
20001338:	f245 235c 	movw	r3, #21084	; 0x525c
2000133c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001340:	601a      	str	r2, [r3, #0]
    	}
    	if(g_src_image_target_address + length > g_file_size )
20001342:	f245 235c 	movw	r3, #21084	; 0x525c
20001346:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000134a:	681a      	ldr	r2, [r3, #0]
2000134c:	683b      	ldr	r3, [r7, #0]
2000134e:	441a      	add	r2, r3
20001350:	f245 2368 	movw	r3, #21096	; 0x5268
20001354:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001358:	681b      	ldr	r3, [r3, #0]
2000135a:	429a      	cmp	r2, r3
2000135c:	d90c      	bls.n	20001378 <read_page_from_host_through_uart+0x84>
	   {
    		num_bytes = g_file_size - g_src_image_target_address;
2000135e:	f245 2368 	movw	r3, #21096	; 0x5268
20001362:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001366:	681a      	ldr	r2, [r3, #0]
20001368:	f245 235c 	movw	r3, #21084	; 0x525c
2000136c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001370:	681b      	ldr	r3, [r3, #0]
20001372:	ebc3 0302 	rsb	r3, r3, r2
20001376:	613b      	str	r3, [r7, #16]
	   }
    	if(g_src_image_target_address>= g_file_size)
20001378:	f245 235c 	movw	r3, #21084	; 0x525c
2000137c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001380:	681a      	ldr	r2, [r3, #0]
20001382:	f245 2368 	movw	r3, #21096	; 0x5268
20001386:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000138a:	681b      	ldr	r3, [r3, #0]
2000138c:	429a      	cmp	r2, r3
2000138e:	d302      	bcc.n	20001396 <read_page_from_host_through_uart+0xa2>
    	{
    		return 0;
20001390:	f04f 0300 	mov.w	r3, #0
20001394:	e0e9      	b.n	2000156a <read_page_from_host_through_uart+0x276>
    	}
    	CRCFAIL:
           MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"b",1);
20001396:	f644 7364 	movw	r3, #20324	; 0x4f64
2000139a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000139e:	681b      	ldr	r3, [r3, #0]
200013a0:	4618      	mov	r0, r3
200013a2:	f644 71b8 	movw	r1, #20408	; 0x4fb8
200013a6:	f2c2 0100 	movt	r1, #8192	; 0x2000
200013aa:	f04f 0201 	mov.w	r2, #1
200013ae:	f000 f9a1 	bl	200016f4 <MSS_UART_polled_tx>
           //poll for Ack message from the host as an acknowledgment that the host is ready for receiving the transaction
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
200013b2:	f644 7364 	movw	r3, #20324	; 0x4f64
200013b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200013ba:	681a      	ldr	r2, [r3, #0]
200013bc:	f107 0308 	add.w	r3, r7, #8
200013c0:	4610      	mov	r0, r2
200013c2:	4619      	mov	r1, r3
200013c4:	f04f 0201 	mov.w	r2, #1
200013c8:	f7ff fbd8 	bl	20000b7c <UART_Polled_Rx>
200013cc:	4603      	mov	r3, r0
200013ce:	2b00      	cmp	r3, #0
200013d0:	d0ef      	beq.n	200013b2 <read_page_from_host_through_uart+0xbe>
           	;
           //transmit the address to the host
           temp = g_src_image_target_address/8;
200013d2:	f245 235c 	movw	r3, #21084	; 0x525c
200013d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200013da:	681b      	ldr	r3, [r3, #0]
200013dc:	ea4f 03d3 	mov.w	r3, r3, lsr #3
200013e0:	60fb      	str	r3, [r7, #12]
           if(rx_buff[0]== 'a')
200013e2:	7a3b      	ldrb	r3, [r7, #8]
200013e4:	2b61      	cmp	r3, #97	; 0x61
200013e6:	d10c      	bne.n	20001402 <read_page_from_host_through_uart+0x10e>
           MSS_UART_polled_tx( gp_my_uart,(const uint8_t * )&temp, 8 );
200013e8:	f644 7364 	movw	r3, #20324	; 0x4f64
200013ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
200013f0:	681a      	ldr	r2, [r3, #0]
200013f2:	f107 030c 	add.w	r3, r7, #12
200013f6:	4610      	mov	r0, r2
200013f8:	4619      	mov	r1, r3
200013fa:	f04f 0208 	mov.w	r2, #8
200013fe:	f000 f979 	bl	200016f4 <MSS_UART_polled_tx>
           //poll for Ack message from the host as an acknowledgment that the host received the address
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
20001402:	f644 7364 	movw	r3, #20324	; 0x4f64
20001406:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000140a:	681a      	ldr	r2, [r3, #0]
2000140c:	f107 0308 	add.w	r3, r7, #8
20001410:	4610      	mov	r0, r2
20001412:	4619      	mov	r1, r3
20001414:	f04f 0201 	mov.w	r2, #1
20001418:	f7ff fbb0 	bl	20000b7c <UART_Polled_Rx>
2000141c:	4603      	mov	r3, r0
2000141e:	2b00      	cmp	r3, #0
20001420:	d0ef      	beq.n	20001402 <read_page_from_host_through_uart+0x10e>
           	;
           //transmit the returnbytes to the host
           if(rx_buff[0]== 'a')
20001422:	7a3b      	ldrb	r3, [r7, #8]
20001424:	2b61      	cmp	r3, #97	; 0x61
20001426:	d10c      	bne.n	20001442 <read_page_from_host_through_uart+0x14e>
           MSS_UART_polled_tx( gp_my_uart,(const uint8_t * )&num_bytes, 4 );
20001428:	f644 7364 	movw	r3, #20324	; 0x4f64
2000142c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001430:	681a      	ldr	r2, [r3, #0]
20001432:	f107 0310 	add.w	r3, r7, #16
20001436:	4610      	mov	r0, r2
20001438:	4619      	mov	r1, r3
2000143a:	f04f 0204 	mov.w	r2, #4
2000143e:	f000 f959 	bl	200016f4 <MSS_UART_polled_tx>

           //poll for Ack message from the host as an acknowledgment that the host received the returnbytes
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
20001442:	f644 7364 	movw	r3, #20324	; 0x4f64
20001446:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000144a:	681a      	ldr	r2, [r3, #0]
2000144c:	f107 0308 	add.w	r3, r7, #8
20001450:	4610      	mov	r0, r2
20001452:	4619      	mov	r1, r3
20001454:	f04f 0201 	mov.w	r2, #1
20001458:	f7ff fb90 	bl	20000b7c <UART_Polled_Rx>
2000145c:	4603      	mov	r3, r0
2000145e:	2b00      	cmp	r3, #0
20001460:	d0ef      	beq.n	20001442 <read_page_from_host_through_uart+0x14e>
           	;

           //read the data from the host for the request number of bytes
           if(rx_buff[0]== 'a')
20001462:	7a3b      	ldrb	r3, [r7, #8]
20001464:	2b61      	cmp	r3, #97	; 0x61
20001466:	d10c      	bne.n	20001482 <read_page_from_host_through_uart+0x18e>
        	   rx_size = UART_Polled_Rx(gp_my_uart, g_buffer, num_bytes);
20001468:	f644 7364 	movw	r3, #20324	; 0x4f64
2000146c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001470:	681a      	ldr	r2, [r3, #0]
20001472:	693b      	ldr	r3, [r7, #16]
20001474:	4610      	mov	r0, r2
20001476:	6879      	ldr	r1, [r7, #4]
20001478:	461a      	mov	r2, r3
2000147a:	f7ff fb7f 	bl	20000b7c <UART_Polled_Rx>
2000147e:	4603      	mov	r3, r0
20001480:	61fb      	str	r3, [r7, #28]

           //send Ack message to indicate one transaction is done
           MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"a",1);
20001482:	f644 7364 	movw	r3, #20324	; 0x4f64
20001486:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000148a:	681b      	ldr	r3, [r3, #0]
2000148c:	4618      	mov	r0, r3
2000148e:	f644 7170 	movw	r1, #20336	; 0x4f70
20001492:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001496:	f04f 0201 	mov.w	r2, #1
2000149a:	f000 f92b 	bl	200016f4 <MSS_UART_polled_tx>
           //Recive 1-byte CRC for data of size num_bytes
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
2000149e:	f644 7364 	movw	r3, #20324	; 0x4f64
200014a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200014a6:	681a      	ldr	r2, [r3, #0]
200014a8:	f107 0308 	add.w	r3, r7, #8
200014ac:	4610      	mov	r0, r2
200014ae:	4619      	mov	r1, r3
200014b0:	f04f 0201 	mov.w	r2, #1
200014b4:	f7ff fb62 	bl	20000b7c <UART_Polled_Rx>
200014b8:	4603      	mov	r3, r0
200014ba:	2b00      	cmp	r3, #0
200014bc:	d0ef      	beq.n	2000149e <read_page_from_host_through_uart+0x1aa>
                      	;
           factor = 1;
200014be:	f04f 0301 	mov.w	r3, #1
200014c2:	617b      	str	r3, [r7, #20]
           crc = 0;
200014c4:	f04f 0300 	mov.w	r3, #0
200014c8:	76fb      	strb	r3, [r7, #27]
           while((num_bytes-1)/factor)
200014ca:	e00b      	b.n	200014e4 <read_page_from_host_through_uart+0x1f0>
           {
              crc = crc^g_buffer[factor];
200014cc:	687a      	ldr	r2, [r7, #4]
200014ce:	697b      	ldr	r3, [r7, #20]
200014d0:	4413      	add	r3, r2
200014d2:	781a      	ldrb	r2, [r3, #0]
200014d4:	7efb      	ldrb	r3, [r7, #27]
200014d6:	ea82 0303 	eor.w	r3, r2, r3
200014da:	76fb      	strb	r3, [r7, #27]
              factor = factor*2;
200014dc:	697b      	ldr	r3, [r7, #20]
200014de:	ea4f 0343 	mov.w	r3, r3, lsl #1
200014e2:	617b      	str	r3, [r7, #20]
           //Recive 1-byte CRC for data of size num_bytes
           while(!(UART_Polled_Rx ( gp_my_uart, rx_buff, 1 )))
                      	;
           factor = 1;
           crc = 0;
           while((num_bytes-1)/factor)
200014e4:	693b      	ldr	r3, [r7, #16]
200014e6:	f103 32ff 	add.w	r2, r3, #4294967295
200014ea:	697b      	ldr	r3, [r7, #20]
200014ec:	fbb2 f3f3 	udiv	r3, r2, r3
200014f0:	2b00      	cmp	r3, #0
200014f2:	d1eb      	bne.n	200014cc <read_page_from_host_through_uart+0x1d8>
           {
              crc = crc^g_buffer[factor];
              factor = factor*2;
           }
           if(crc == (char)rx_buff[0])
200014f4:	7a3b      	ldrb	r3, [r7, #8]
200014f6:	7efa      	ldrb	r2, [r7, #27]
200014f8:	429a      	cmp	r2, r3
200014fa:	d127      	bne.n	2000154c <read_page_from_host_through_uart+0x258>
           {
        	   g_src_image_target_address += rx_size;
200014fc:	f245 235c 	movw	r3, #21084	; 0x525c
20001500:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001504:	681a      	ldr	r2, [r3, #0]
20001506:	69fb      	ldr	r3, [r7, #28]
20001508:	441a      	add	r2, r3
2000150a:	f245 235c 	movw	r3, #21084	; 0x525c
2000150e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001512:	601a      	str	r2, [r3, #0]
        	   g_bkup = g_bkup + rx_size;
20001514:	f245 2360 	movw	r3, #21088	; 0x5260
20001518:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000151c:	681a      	ldr	r2, [r3, #0]
2000151e:	69fb      	ldr	r3, [r7, #28]
20001520:	441a      	add	r2, r3
20001522:	f245 2360 	movw	r3, #21088	; 0x5260
20001526:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000152a:	601a      	str	r2, [r3, #0]
        	   MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"a",1);
2000152c:	f644 7364 	movw	r3, #20324	; 0x4f64
20001530:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001534:	681b      	ldr	r3, [r3, #0]
20001536:	4618      	mov	r0, r3
20001538:	f644 7170 	movw	r1, #20336	; 0x4f70
2000153c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001540:	f04f 0201 	mov.w	r2, #1
20001544:	f000 f8d6 	bl	200016f4 <MSS_UART_polled_tx>
           {
        	   MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"n",1);
        	   goto CRCFAIL;
           }

      return rx_size;
20001548:	69fb      	ldr	r3, [r7, #28]
2000154a:	e00e      	b.n	2000156a <read_page_from_host_through_uart+0x276>
        	   g_bkup = g_bkup + rx_size;
        	   MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"a",1);
           }
           else
           {
        	   MSS_UART_polled_tx(gp_my_uart,(const uint8_t * )"n",1);
2000154c:	f644 7364 	movw	r3, #20324	; 0x4f64
20001550:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001554:	681b      	ldr	r3, [r3, #0]
20001556:	4618      	mov	r0, r3
20001558:	f644 71bc 	movw	r1, #20412	; 0x4fbc
2000155c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001560:	f04f 0201 	mov.w	r2, #1
20001564:	f000 f8c6 	bl	200016f4 <MSS_UART_polled_tx>
        	   goto CRCFAIL;
20001568:	e715      	b.n	20001396 <read_page_from_host_through_uart+0xa2>
           }

      return rx_size;
}
2000156a:	4618      	mov	r0, r3
2000156c:	f107 0720 	add.w	r7, r7, #32
20001570:	46bd      	mov	sp, r7
20001572:	bd80      	pop	{r7, pc}

20001574 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20001574:	b480      	push	{r7}
20001576:	b083      	sub	sp, #12
20001578:	af00      	add	r7, sp, #0
2000157a:	4603      	mov	r3, r0
2000157c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
2000157e:	f24e 1300 	movw	r3, #57600	; 0xe100
20001582:	f2ce 0300 	movt	r3, #57344	; 0xe000
20001586:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000158a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000158e:	79f9      	ldrb	r1, [r7, #7]
20001590:	f001 011f 	and.w	r1, r1, #31
20001594:	f04f 0001 	mov.w	r0, #1
20001598:	fa00 f101 	lsl.w	r1, r0, r1
2000159c:	f102 0260 	add.w	r2, r2, #96	; 0x60
200015a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200015a4:	f107 070c 	add.w	r7, r7, #12
200015a8:	46bd      	mov	sp, r7
200015aa:	bc80      	pop	{r7}
200015ac:	4770      	bx	lr
200015ae:	bf00      	nop

200015b0 <set_bit_reg8>:
static __INLINE void set_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
200015b0:	b480      	push	{r7}
200015b2:	b083      	sub	sp, #12
200015b4:	af00      	add	r7, sp, #0
200015b6:	6078      	str	r0, [r7, #4]
200015b8:	460b      	mov	r3, r1
200015ba:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x1;
200015bc:	687b      	ldr	r3, [r7, #4]
200015be:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
200015c2:	687b      	ldr	r3, [r7, #4]
200015c4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
200015c8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
200015cc:	ea4f 1343 	mov.w	r3, r3, lsl #5
200015d0:	441a      	add	r2, r3
200015d2:	78fb      	ldrb	r3, [r7, #3]
200015d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
200015d8:	4413      	add	r3, r2
200015da:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
200015de:	f04f 0201 	mov.w	r2, #1
200015e2:	601a      	str	r2, [r3, #0]
}
200015e4:	f107 070c 	add.w	r7, r7, #12
200015e8:	46bd      	mov	sp, r7
200015ea:	bc80      	pop	{r7}
200015ec:	4770      	bx	lr
200015ee:	bf00      	nop

200015f0 <clear_bit_reg8>:
static __INLINE void clear_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
200015f0:	b480      	push	{r7}
200015f2:	b083      	sub	sp, #12
200015f4:	af00      	add	r7, sp, #0
200015f6:	6078      	str	r0, [r7, #4]
200015f8:	460b      	mov	r3, r1
200015fa:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x0;
200015fc:	687b      	ldr	r3, [r7, #4]
200015fe:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20001602:	687b      	ldr	r3, [r7, #4]
20001604:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20001608:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
2000160c:	ea4f 1343 	mov.w	r3, r3, lsl #5
20001610:	441a      	add	r2, r3
20001612:	78fb      	ldrb	r3, [r7, #3]
20001614:	ea4f 0383 	mov.w	r3, r3, lsl #2
20001618:	4413      	add	r3, r2
2000161a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
2000161e:	f04f 0200 	mov.w	r2, #0
20001622:	601a      	str	r2, [r3, #0]
}
20001624:	f107 070c 	add.w	r7, r7, #12
20001628:	46bd      	mov	sp, r7
2000162a:	bc80      	pop	{r7}
2000162c:	4770      	bx	lr
2000162e:	bf00      	nop

20001630 <read_bit_reg8>:
static __INLINE uint8_t read_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    return (HW_REG_BIT(reg,bit));
}
static __INLINE uint8_t read_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20001630:	b480      	push	{r7}
20001632:	b083      	sub	sp, #12
20001634:	af00      	add	r7, sp, #0
20001636:	6078      	str	r0, [r7, #4]
20001638:	460b      	mov	r3, r1
2000163a:	70fb      	strb	r3, [r7, #3]
    return (HW_REG_BIT(reg,bit));
2000163c:	687b      	ldr	r3, [r7, #4]
2000163e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20001642:	687b      	ldr	r3, [r7, #4]
20001644:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20001648:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
2000164c:	ea4f 1343 	mov.w	r3, r3, lsl #5
20001650:	441a      	add	r2, r3
20001652:	78fb      	ldrb	r3, [r7, #3]
20001654:	ea4f 0383 	mov.w	r3, r3, lsl #2
20001658:	4413      	add	r3, r2
2000165a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
2000165e:	681b      	ldr	r3, [r3, #0]
20001660:	b2db      	uxtb	r3, r3
}
20001662:	4618      	mov	r0, r3
20001664:	f107 070c 	add.w	r7, r7, #12
20001668:	46bd      	mov	sp, r7
2000166a:	bc80      	pop	{r7}
2000166c:	4770      	bx	lr
2000166e:	bf00      	nop

20001670 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
20001670:	b580      	push	{r7, lr}
20001672:	b084      	sub	sp, #16
20001674:	af00      	add	r7, sp, #0
20001676:	60f8      	str	r0, [r7, #12]
20001678:	60b9      	str	r1, [r7, #8]
2000167a:	4613      	mov	r3, r2
2000167c:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
2000167e:	68fa      	ldr	r2, [r7, #12]
20001680:	f248 5334 	movw	r3, #34100	; 0x8534
20001684:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001688:	429a      	cmp	r2, r3
2000168a:	d007      	beq.n	2000169c <MSS_UART_init+0x2c>
2000168c:	68fa      	ldr	r2, [r7, #12]
2000168e:	f248 43f4 	movw	r3, #34036	; 0x84f4
20001692:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001696:	429a      	cmp	r2, r3
20001698:	d000      	beq.n	2000169c <MSS_UART_init+0x2c>
2000169a:	be00      	bkpt	0x0000

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
2000169c:	79fb      	ldrb	r3, [r7, #7]
2000169e:	68f8      	ldr	r0, [r7, #12]
200016a0:	68b9      	ldr	r1, [r7, #8]
200016a2:	461a      	mov	r2, r3
200016a4:	f000 f988 	bl	200019b8 <global_init>

    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
200016a8:	68fb      	ldr	r3, [r7, #12]
200016aa:	681b      	ldr	r3, [r3, #0]
200016ac:	f103 0330 	add.w	r3, r3, #48	; 0x30
200016b0:	4618      	mov	r0, r3
200016b2:	f04f 0103 	mov.w	r1, #3
200016b6:	f7ff ff9b 	bl	200015f0 <clear_bit_reg8>

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
200016ba:	68fb      	ldr	r3, [r7, #12]
200016bc:	681b      	ldr	r3, [r3, #0]
200016be:	f103 0334 	add.w	r3, r3, #52	; 0x34
200016c2:	4618      	mov	r0, r3
200016c4:	f04f 0102 	mov.w	r1, #2
200016c8:	f7ff ff92 	bl	200015f0 <clear_bit_reg8>

    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
200016cc:	68fb      	ldr	r3, [r7, #12]
200016ce:	681b      	ldr	r3, [r3, #0]
200016d0:	f103 0338 	add.w	r3, r3, #56	; 0x38
200016d4:	4618      	mov	r0, r3
200016d6:	f04f 0100 	mov.w	r1, #0
200016da:	f7ff ff89 	bl	200015f0 <clear_bit_reg8>

    /* set default tx handler for automated TX using interrupt in USART mode */
    this_uart->tx_handler = default_tx_handler;
200016de:	68fa      	ldr	r2, [r7, #12]
200016e0:	f641 6351 	movw	r3, #7761	; 0x1e51
200016e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016e8:	6253      	str	r3, [r2, #36]	; 0x24
}
200016ea:	f107 0710 	add.w	r7, r7, #16
200016ee:	46bd      	mov	sp, r7
200016f0:	bd80      	pop	{r7, pc}
200016f2:	bf00      	nop

200016f4 <MSS_UART_polled_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
200016f4:	b480      	push	{r7}
200016f6:	b089      	sub	sp, #36	; 0x24
200016f8:	af00      	add	r7, sp, #0
200016fa:	60f8      	str	r0, [r7, #12]
200016fc:	60b9      	str	r1, [r7, #8]
200016fe:	607a      	str	r2, [r7, #4]
    uint32_t char_idx = 0u;
20001700:	f04f 0300 	mov.w	r3, #0
20001704:	613b      	str	r3, [r7, #16]
    uint32_t size_sent;
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20001706:	68fa      	ldr	r2, [r7, #12]
20001708:	f248 5334 	movw	r3, #34100	; 0x8534
2000170c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001710:	429a      	cmp	r2, r3
20001712:	d007      	beq.n	20001724 <MSS_UART_polled_tx+0x30>
20001714:	68fa      	ldr	r2, [r7, #12]
20001716:	f248 43f4 	movw	r3, #34036	; 0x84f4
2000171a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000171e:	429a      	cmp	r2, r3
20001720:	d000      	beq.n	20001724 <MSS_UART_polled_tx+0x30>
20001722:	be00      	bkpt	0x0000
    ASSERT(pbuff != ( (uint8_t *)0));
20001724:	68bb      	ldr	r3, [r7, #8]
20001726:	2b00      	cmp	r3, #0
20001728:	d100      	bne.n	2000172c <MSS_UART_polled_tx+0x38>
2000172a:	be00      	bkpt	0x0000
    ASSERT(tx_size > 0u);
2000172c:	687b      	ldr	r3, [r7, #4]
2000172e:	2b00      	cmp	r3, #0
20001730:	d100      	bne.n	20001734 <MSS_UART_polled_tx+0x40>
20001732:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20001734:	68fa      	ldr	r2, [r7, #12]
20001736:	f248 5334 	movw	r3, #34100	; 0x8534
2000173a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000173e:	429a      	cmp	r2, r3
20001740:	d006      	beq.n	20001750 <MSS_UART_polled_tx+0x5c>
20001742:	68fa      	ldr	r2, [r7, #12]
20001744:	f248 43f4 	movw	r3, #34036	; 0x84f4
20001748:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000174c:	429a      	cmp	r2, r3
2000174e:	d13d      	bne.n	200017cc <MSS_UART_polled_tx+0xd8>
20001750:	68bb      	ldr	r3, [r7, #8]
20001752:	2b00      	cmp	r3, #0
20001754:	d03a      	beq.n	200017cc <MSS_UART_polled_tx+0xd8>
20001756:	687b      	ldr	r3, [r7, #4]
20001758:	2b00      	cmp	r3, #0
2000175a:	d037      	beq.n	200017cc <MSS_UART_polled_tx+0xd8>
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
2000175c:	68fb      	ldr	r3, [r7, #12]
2000175e:	681b      	ldr	r3, [r3, #0]
20001760:	7d1b      	ldrb	r3, [r3, #20]
20001762:	76fb      	strb	r3, [r7, #27]
            this_uart->status |= status;
20001764:	68fb      	ldr	r3, [r7, #12]
20001766:	7b5a      	ldrb	r2, [r3, #13]
20001768:	7efb      	ldrb	r3, [r7, #27]
2000176a:	ea42 0303 	orr.w	r3, r2, r3
2000176e:	b2da      	uxtb	r2, r3
20001770:	68fb      	ldr	r3, [r7, #12]
20001772:	735a      	strb	r2, [r3, #13]

            /* Check if TX FIFO is empty. */
            if(status & MSS_UART_THRE)
20001774:	7efb      	ldrb	r3, [r7, #27]
20001776:	f003 0320 	and.w	r3, r3, #32
2000177a:	2b00      	cmp	r3, #0
2000177c:	d023      	beq.n	200017c6 <MSS_UART_polled_tx+0xd2>
            {
                uint32_t fill_size = TX_FIFO_SIZE;
2000177e:	f04f 0310 	mov.w	r3, #16
20001782:	61fb      	str	r3, [r7, #28]

                /* Calculate the number of bytes to transmit. */
                if(tx_size < TX_FIFO_SIZE)
20001784:	687b      	ldr	r3, [r7, #4]
20001786:	2b0f      	cmp	r3, #15
20001788:	d801      	bhi.n	2000178e <MSS_UART_polled_tx+0x9a>
                {
                    fill_size = tx_size;
2000178a:	687b      	ldr	r3, [r7, #4]
2000178c:	61fb      	str	r3, [r7, #28]
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
2000178e:	f04f 0300 	mov.w	r3, #0
20001792:	617b      	str	r3, [r7, #20]
20001794:	e00e      	b.n	200017b4 <MSS_UART_polled_tx+0xc0>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
20001796:	68fb      	ldr	r3, [r7, #12]
20001798:	681b      	ldr	r3, [r3, #0]
2000179a:	68b9      	ldr	r1, [r7, #8]
2000179c:	693a      	ldr	r2, [r7, #16]
2000179e:	440a      	add	r2, r1
200017a0:	7812      	ldrb	r2, [r2, #0]
200017a2:	701a      	strb	r2, [r3, #0]
                    char_idx++;
200017a4:	693b      	ldr	r3, [r7, #16]
200017a6:	f103 0301 	add.w	r3, r3, #1
200017aa:	613b      	str	r3, [r7, #16]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
200017ac:	697b      	ldr	r3, [r7, #20]
200017ae:	f103 0301 	add.w	r3, r3, #1
200017b2:	617b      	str	r3, [r7, #20]
200017b4:	697a      	ldr	r2, [r7, #20]
200017b6:	69fb      	ldr	r3, [r7, #28]
200017b8:	429a      	cmp	r2, r3
200017ba:	d3ec      	bcc.n	20001796 <MSS_UART_polled_tx+0xa2>
                    this_uart->hw_reg->THR = pbuff[char_idx];
                    char_idx++;
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
200017bc:	687a      	ldr	r2, [r7, #4]
200017be:	697b      	ldr	r3, [r7, #20]
200017c0:	ebc3 0302 	rsb	r3, r3, r2
200017c4:	607b      	str	r3, [r7, #4]
            }
        } while(tx_size);
200017c6:	687b      	ldr	r3, [r7, #4]
200017c8:	2b00      	cmp	r3, #0
200017ca:	d1c7      	bne.n	2000175c <MSS_UART_polled_tx+0x68>
    }
}
200017cc:	f107 0724 	add.w	r7, r7, #36	; 0x24
200017d0:	46bd      	mov	sp, r7
200017d2:	bc80      	pop	{r7}
200017d4:	4770      	bx	lr
200017d6:	bf00      	nop

200017d8 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler(void)
#else
void UART0_IRQHandler(void)
#endif
{
200017d8:	4668      	mov	r0, sp
200017da:	f020 0107 	bic.w	r1, r0, #7
200017de:	468d      	mov	sp, r1
200017e0:	b589      	push	{r0, r3, r7, lr}
200017e2:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart0);
200017e4:	f248 5034 	movw	r0, #34100	; 0x8534
200017e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200017ec:	f000 fa1a 	bl	20001c24 <MSS_UART_isr>
}
200017f0:	46bd      	mov	sp, r7
200017f2:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
200017f6:	4685      	mov	sp, r0
200017f8:	4770      	bx	lr
200017fa:	bf00      	nop

200017fc <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler(void)
#else
void UART1_IRQHandler(void)
#endif
{
200017fc:	4668      	mov	r0, sp
200017fe:	f020 0107 	bic.w	r1, r0, #7
20001802:	468d      	mov	sp, r1
20001804:	b589      	push	{r0, r3, r7, lr}
20001806:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart1);
20001808:	f248 40f4 	movw	r0, #34036	; 0x84f4
2000180c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001810:	f000 fa08 	bl	20001c24 <MSS_UART_isr>
}
20001814:	46bd      	mov	sp, r7
20001816:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
2000181a:	4685      	mov	sp, r0
2000181c:	4770      	bx	lr
2000181e:	bf00      	nop

20001820 <config_baud_divisors>:
config_baud_divisors
(
    mss_uart_instance_t * this_uart,
    uint32_t baudrate    
)
{
20001820:	b580      	push	{r7, lr}
20001822:	b088      	sub	sp, #32
20001824:	af00      	add	r7, sp, #0
20001826:	6078      	str	r0, [r7, #4]
20001828:	6039      	str	r1, [r7, #0]
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
2000182a:	687a      	ldr	r2, [r7, #4]
2000182c:	f248 5334 	movw	r3, #34100	; 0x8534
20001830:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001834:	429a      	cmp	r2, r3
20001836:	d007      	beq.n	20001848 <config_baud_divisors+0x28>
20001838:	687a      	ldr	r2, [r7, #4]
2000183a:	f248 43f4 	movw	r3, #34036	; 0x84f4
2000183e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001842:	429a      	cmp	r2, r3
20001844:	d000      	beq.n	20001848 <config_baud_divisors+0x28>
20001846:	be00      	bkpt	0x0000
    
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
20001848:	687a      	ldr	r2, [r7, #4]
2000184a:	f248 5334 	movw	r3, #34100	; 0x8534
2000184e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001852:	429a      	cmp	r2, r3
20001854:	d007      	beq.n	20001866 <config_baud_divisors+0x46>
20001856:	687a      	ldr	r2, [r7, #4]
20001858:	f248 43f4 	movw	r3, #34036	; 0x84f4
2000185c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001860:	429a      	cmp	r2, r3
20001862:	f040 80a4 	bne.w	200019ae <config_baud_divisors+0x18e>
        uint32_t baud_value_by_64;
        uint32_t baud_value_by_128;
        uint32_t fractional_baud_value;
        uint32_t pclk_freq;

        this_uart->baudrate = baudrate;
20001866:	687b      	ldr	r3, [r7, #4]
20001868:	683a      	ldr	r2, [r7, #0]
2000186a:	609a      	str	r2, [r3, #8]

        /* Force the value of the CMSIS global variables holding the various system
          * clock frequencies to be updated. */
        SystemCoreClockUpdate();
2000186c:	f002 f8ea 	bl	20003a44 <SystemCoreClockUpdate>
        if(this_uart == &g_mss_uart0)
20001870:	687a      	ldr	r2, [r7, #4]
20001872:	f248 5334 	movw	r3, #34100	; 0x8534
20001876:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000187a:	429a      	cmp	r2, r3
2000187c:	d106      	bne.n	2000188c <config_baud_divisors+0x6c>
        {
            pclk_freq = g_FrequencyPCLK0;
2000187e:	f245 1330 	movw	r3, #20784	; 0x5130
20001882:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001886:	681b      	ldr	r3, [r3, #0]
20001888:	61fb      	str	r3, [r7, #28]
2000188a:	e005      	b.n	20001898 <config_baud_divisors+0x78>
        }
        else
        {
            pclk_freq = g_FrequencyPCLK1;
2000188c:	f245 1334 	movw	r3, #20788	; 0x5134
20001890:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001894:	681b      	ldr	r3, [r3, #0]
20001896:	61fb      	str	r3, [r7, #28]
        /*
         * Compute baud value based on requested baud rate and PCLK frequency.
         * The baud value is computed using the following equation:
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
20001898:	69fb      	ldr	r3, [r7, #28]
2000189a:	ea4f 02c3 	mov.w	r2, r3, lsl #3
2000189e:	683b      	ldr	r3, [r7, #0]
200018a0:	fbb2 f3f3 	udiv	r3, r2, r3
200018a4:	617b      	str	r3, [r7, #20]
        baud_value_by_64 = baud_value_by_128 / 2u;
200018a6:	697b      	ldr	r3, [r7, #20]
200018a8:	ea4f 0353 	mov.w	r3, r3, lsr #1
200018ac:	613b      	str	r3, [r7, #16]
        baud_value = baud_value_by_64 / 64u;
200018ae:	693b      	ldr	r3, [r7, #16]
200018b0:	ea4f 1393 	mov.w	r3, r3, lsr #6
200018b4:	60fb      	str	r3, [r7, #12]
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
200018b6:	68fb      	ldr	r3, [r7, #12]
200018b8:	ea4f 1383 	mov.w	r3, r3, lsl #6
200018bc:	693a      	ldr	r2, [r7, #16]
200018be:	ebc3 0302 	rsb	r3, r3, r2
200018c2:	61bb      	str	r3, [r7, #24]
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
200018c4:	68fb      	ldr	r3, [r7, #12]
200018c6:	ea4f 13c3 	mov.w	r3, r3, lsl #7
200018ca:	697a      	ldr	r2, [r7, #20]
200018cc:	ebc3 0202 	rsb	r2, r3, r2
200018d0:	69bb      	ldr	r3, [r7, #24]
200018d2:	ea4f 0343 	mov.w	r3, r3, lsl #1
200018d6:	ebc3 0302 	rsb	r3, r3, r2
200018da:	69ba      	ldr	r2, [r7, #24]
200018dc:	4413      	add	r3, r2
200018de:	61bb      	str	r3, [r7, #24]
        
        /* Assert if integer baud value fits in 16-bit. */
        ASSERT(baud_value <= UINT16_MAX);
200018e0:	68fa      	ldr	r2, [r7, #12]
200018e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
200018e6:	429a      	cmp	r2, r3
200018e8:	d900      	bls.n	200018ec <config_baud_divisors+0xcc>
200018ea:	be00      	bkpt	0x0000
    
        if(baud_value <= (uint32_t)UINT16_MAX)
200018ec:	68fa      	ldr	r2, [r7, #12]
200018ee:	f64f 73ff 	movw	r3, #65535	; 0xffff
200018f2:	429a      	cmp	r2, r3
200018f4:	d85b      	bhi.n	200019ae <config_baud_divisors+0x18e>
        {
            if(baud_value > 1u)
200018f6:	68fb      	ldr	r3, [r7, #12]
200018f8:	2b01      	cmp	r3, #1
200018fa:	d931      	bls.n	20001960 <config_baud_divisors+0x140>
            {
                /* 
                 * Use Frational baud rate divisors
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
200018fc:	687b      	ldr	r3, [r7, #4]
200018fe:	681b      	ldr	r3, [r3, #0]
20001900:	f103 030c 	add.w	r3, r3, #12
20001904:	4618      	mov	r0, r3
20001906:	f04f 0107 	mov.w	r1, #7
2000190a:	f7ff fe51 	bl	200015b0 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
2000190e:	687b      	ldr	r3, [r7, #4]
20001910:	681b      	ldr	r3, [r3, #0]
20001912:	68fa      	ldr	r2, [r7, #12]
20001914:	ea4f 2212 	mov.w	r2, r2, lsr #8
20001918:	b2d2      	uxtb	r2, r2
2000191a:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
2000191c:	687b      	ldr	r3, [r7, #4]
2000191e:	681b      	ldr	r3, [r3, #0]
20001920:	68fa      	ldr	r2, [r7, #12]
20001922:	b2d2      	uxtb	r2, r2
20001924:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20001926:	687b      	ldr	r3, [r7, #4]
20001928:	681b      	ldr	r3, [r3, #0]
2000192a:	f103 030c 	add.w	r3, r3, #12
2000192e:	4618      	mov	r0, r3
20001930:	f04f 0107 	mov.w	r1, #7
20001934:	f7ff fe5c 	bl	200015f0 <clear_bit_reg8>
        
                /* Enable Fractional baud rate */
                set_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
20001938:	687b      	ldr	r3, [r7, #4]
2000193a:	681b      	ldr	r3, [r3, #0]
2000193c:	f103 0330 	add.w	r3, r3, #48	; 0x30
20001940:	4618      	mov	r0, r3
20001942:	f04f 0107 	mov.w	r1, #7
20001946:	f7ff fe33 	bl	200015b0 <set_bit_reg8>
        
                /* Load the fractional baud rate register */
                ASSERT(fractional_baud_value <= (uint32_t)UINT8_MAX);
2000194a:	69bb      	ldr	r3, [r7, #24]
2000194c:	2bff      	cmp	r3, #255	; 0xff
2000194e:	d900      	bls.n	20001952 <config_baud_divisors+0x132>
20001950:	be00      	bkpt	0x0000
                this_uart->hw_reg->DFR = (uint8_t)fractional_baud_value;
20001952:	687b      	ldr	r3, [r7, #4]
20001954:	681b      	ldr	r3, [r3, #0]
20001956:	69ba      	ldr	r2, [r7, #24]
20001958:	b2d2      	uxtb	r2, r2
2000195a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
2000195e:	e026      	b.n	200019ae <config_baud_divisors+0x18e>
            {
                /*
                 * Do NOT use Frational baud rate divisors.
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20001960:	687b      	ldr	r3, [r7, #4]
20001962:	681b      	ldr	r3, [r3, #0]
20001964:	f103 030c 	add.w	r3, r3, #12
20001968:	4618      	mov	r0, r3
2000196a:	f04f 0107 	mov.w	r1, #7
2000196e:	f7ff fe1f 	bl	200015b0 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
20001972:	687b      	ldr	r3, [r7, #4]
20001974:	681b      	ldr	r3, [r3, #0]
20001976:	68fa      	ldr	r2, [r7, #12]
20001978:	ea4f 2212 	mov.w	r2, r2, lsr #8
2000197c:	b2d2      	uxtb	r2, r2
2000197e:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
20001980:	687b      	ldr	r3, [r7, #4]
20001982:	681b      	ldr	r3, [r3, #0]
20001984:	68fa      	ldr	r2, [r7, #12]
20001986:	b2d2      	uxtb	r2, r2
20001988:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
2000198a:	687b      	ldr	r3, [r7, #4]
2000198c:	681b      	ldr	r3, [r3, #0]
2000198e:	f103 030c 	add.w	r3, r3, #12
20001992:	4618      	mov	r0, r3
20001994:	f04f 0107 	mov.w	r1, #7
20001998:	f7ff fe2a 	bl	200015f0 <clear_bit_reg8>
                
                /* Disable Fractional baud rate */
                clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
2000199c:	687b      	ldr	r3, [r7, #4]
2000199e:	681b      	ldr	r3, [r3, #0]
200019a0:	f103 0330 	add.w	r3, r3, #48	; 0x30
200019a4:	4618      	mov	r0, r3
200019a6:	f04f 0107 	mov.w	r1, #7
200019aa:	f7ff fe21 	bl	200015f0 <clear_bit_reg8>
            }
        }
    }
}
200019ae:	f107 0720 	add.w	r7, r7, #32
200019b2:	46bd      	mov	sp, r7
200019b4:	bd80      	pop	{r7, pc}
200019b6:	bf00      	nop

200019b8 <global_init>:
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
200019b8:	b580      	push	{r7, lr}
200019ba:	b084      	sub	sp, #16
200019bc:	af00      	add	r7, sp, #0
200019be:	60f8      	str	r0, [r7, #12]
200019c0:	60b9      	str	r1, [r7, #8]
200019c2:	4613      	mov	r3, r2
200019c4:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
200019c6:	68fa      	ldr	r2, [r7, #12]
200019c8:	f248 5334 	movw	r3, #34100	; 0x8534
200019cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019d0:	429a      	cmp	r2, r3
200019d2:	d007      	beq.n	200019e4 <global_init+0x2c>
200019d4:	68fa      	ldr	r2, [r7, #12]
200019d6:	f248 43f4 	movw	r3, #34036	; 0x84f4
200019da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019de:	429a      	cmp	r2, r3
200019e0:	d000      	beq.n	200019e4 <global_init+0x2c>
200019e2:	be00      	bkpt	0x0000

    if(this_uart == &g_mss_uart0)
200019e4:	68fa      	ldr	r2, [r7, #12]
200019e6:	f248 5334 	movw	r3, #34100	; 0x8534
200019ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019ee:	429a      	cmp	r2, r3
200019f0:	d124      	bne.n	20001a3c <global_init+0x84>
    {
        this_uart->hw_reg = UART0;
200019f2:	68fb      	ldr	r3, [r7, #12]
200019f4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
200019f8:	601a      	str	r2, [r3, #0]
        this_uart->irqn = UART0_IRQn;
200019fa:	68fb      	ldr	r3, [r7, #12]
200019fc:	f04f 020a 	mov.w	r2, #10
20001a00:	711a      	strb	r2, [r3, #4]
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
20001a02:	f248 0300 	movw	r3, #32768	; 0x8000
20001a06:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001a0a:	f248 0200 	movw	r2, #32768	; 0x8000
20001a0e:	f2c4 0203 	movt	r2, #16387	; 0x4003
20001a12:	6c92      	ldr	r2, [r2, #72]	; 0x48
20001a14:	f042 0280 	orr.w	r2, r2, #128	; 0x80
20001a18:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ(UART0_IRQn);
20001a1a:	f04f 000a 	mov.w	r0, #10
20001a1e:	f7ff fda9 	bl	20001574 <NVIC_ClearPendingIRQ>
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
20001a22:	f248 0300 	movw	r3, #32768	; 0x8000
20001a26:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001a2a:	f248 0200 	movw	r2, #32768	; 0x8000
20001a2e:	f2c4 0203 	movt	r2, #16387	; 0x4003
20001a32:	6c92      	ldr	r2, [r2, #72]	; 0x48
20001a34:	f022 0280 	bic.w	r2, r2, #128	; 0x80
20001a38:	649a      	str	r2, [r3, #72]	; 0x48
20001a3a:	e025      	b.n	20001a88 <global_init+0xd0>
    }
    else
    {
        this_uart->hw_reg = UART1;
20001a3c:	68fa      	ldr	r2, [r7, #12]
20001a3e:	f240 0300 	movw	r3, #0
20001a42:	f2c4 0301 	movt	r3, #16385	; 0x4001
20001a46:	6013      	str	r3, [r2, #0]
        this_uart->irqn = UART1_IRQn;
20001a48:	68fb      	ldr	r3, [r7, #12]
20001a4a:	f04f 020b 	mov.w	r2, #11
20001a4e:	711a      	strb	r2, [r3, #4]
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
20001a50:	f248 0300 	movw	r3, #32768	; 0x8000
20001a54:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001a58:	f248 0200 	movw	r2, #32768	; 0x8000
20001a5c:	f2c4 0203 	movt	r2, #16387	; 0x4003
20001a60:	6c92      	ldr	r2, [r2, #72]	; 0x48
20001a62:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20001a66:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
20001a68:	f04f 000b 	mov.w	r0, #11
20001a6c:	f7ff fd82 	bl	20001574 <NVIC_ClearPendingIRQ>
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
20001a70:	f248 0300 	movw	r3, #32768	; 0x8000
20001a74:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001a78:	f248 0200 	movw	r2, #32768	; 0x8000
20001a7c:	f2c4 0203 	movt	r2, #16387	; 0x4003
20001a80:	6c92      	ldr	r2, [r2, #72]	; 0x48
20001a82:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20001a86:	649a      	str	r2, [r3, #72]	; 0x48
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;
20001a88:	68fb      	ldr	r3, [r7, #12]
20001a8a:	681b      	ldr	r3, [r3, #0]
20001a8c:	f04f 0200 	mov.w	r2, #0
20001a90:	711a      	strb	r2, [r3, #4]

    /* FIFO configuration */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE;
20001a92:	68fb      	ldr	r3, [r7, #12]
20001a94:	681b      	ldr	r3, [r3, #0]
20001a96:	f04f 0200 	mov.w	r2, #0
20001a9a:	721a      	strb	r2, [r3, #8]
    /* clear receiver FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_RX_FIFO);
20001a9c:	68fb      	ldr	r3, [r7, #12]
20001a9e:	681b      	ldr	r3, [r3, #0]
20001aa0:	f103 0308 	add.w	r3, r3, #8
20001aa4:	4618      	mov	r0, r3
20001aa6:	f04f 0101 	mov.w	r1, #1
20001aaa:	f7ff fd81 	bl	200015b0 <set_bit_reg8>
    /* clear transmitter FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_TX_FIFO);
20001aae:	68fb      	ldr	r3, [r7, #12]
20001ab0:	681b      	ldr	r3, [r3, #0]
20001ab2:	f103 0308 	add.w	r3, r3, #8
20001ab6:	4618      	mov	r0, r3
20001ab8:	f04f 0102 	mov.w	r1, #2
20001abc:	f7ff fd78 	bl	200015b0 <set_bit_reg8>

    /* set default READY mode : Mode 0*/
    /* enable RXRDYN and TXRDYN pins. The earlier FCR write to set the TX FIFO
     * trigger level inadvertently disabled the FCR_RXRDY_TXRDYN_EN bit. */
    set_bit_reg8(&this_uart->hw_reg->FCR,RXRDY_TXRDYN_EN);
20001ac0:	68fb      	ldr	r3, [r7, #12]
20001ac2:	681b      	ldr	r3, [r3, #0]
20001ac4:	f103 0308 	add.w	r3, r3, #8
20001ac8:	4618      	mov	r0, r3
20001aca:	f04f 0100 	mov.w	r1, #0
20001ace:	f7ff fd6f 	bl	200015b0 <set_bit_reg8>

    /* disable loopback : local * remote */
    clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
20001ad2:	68fb      	ldr	r3, [r7, #12]
20001ad4:	681b      	ldr	r3, [r3, #0]
20001ad6:	f103 0310 	add.w	r3, r3, #16
20001ada:	4618      	mov	r0, r3
20001adc:	f04f 0104 	mov.w	r1, #4
20001ae0:	f7ff fd86 	bl	200015f0 <clear_bit_reg8>
    clear_bit_reg8(&this_uart->hw_reg->MCR,RLOOP);
20001ae4:	68fb      	ldr	r3, [r7, #12]
20001ae6:	681b      	ldr	r3, [r3, #0]
20001ae8:	f103 0310 	add.w	r3, r3, #16
20001aec:	4618      	mov	r0, r3
20001aee:	f04f 0105 	mov.w	r1, #5
20001af2:	f7ff fd7d 	bl	200015f0 <clear_bit_reg8>

    /* set default TX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX);
20001af6:	68fb      	ldr	r3, [r7, #12]
20001af8:	681b      	ldr	r3, [r3, #0]
20001afa:	f103 0334 	add.w	r3, r3, #52	; 0x34
20001afe:	4618      	mov	r0, r3
20001b00:	f04f 0101 	mov.w	r1, #1
20001b04:	f7ff fd74 	bl	200015f0 <clear_bit_reg8>
    /* set default RX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX);
20001b08:	68fb      	ldr	r3, [r7, #12]
20001b0a:	681b      	ldr	r3, [r3, #0]
20001b0c:	f103 0334 	add.w	r3, r3, #52	; 0x34
20001b10:	4618      	mov	r0, r3
20001b12:	f04f 0100 	mov.w	r1, #0
20001b16:	f7ff fd6b 	bl	200015f0 <clear_bit_reg8>

    /* default AFM : disabled */
    clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
20001b1a:	68fb      	ldr	r3, [r7, #12]
20001b1c:	681b      	ldr	r3, [r3, #0]
20001b1e:	f103 0338 	add.w	r3, r3, #56	; 0x38
20001b22:	4618      	mov	r0, r3
20001b24:	f04f 0101 	mov.w	r1, #1
20001b28:	f7ff fd62 	bl	200015f0 <clear_bit_reg8>

    /* disable TX time gaurd */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ETTG); 
20001b2c:	68fb      	ldr	r3, [r7, #12]
20001b2e:	681b      	ldr	r3, [r3, #0]
20001b30:	f103 0330 	add.w	r3, r3, #48	; 0x30
20001b34:	4618      	mov	r0, r3
20001b36:	f04f 0105 	mov.w	r1, #5
20001b3a:	f7ff fd59 	bl	200015f0 <clear_bit_reg8>

    /* set default RX timeout */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ERTO); 
20001b3e:	68fb      	ldr	r3, [r7, #12]
20001b40:	681b      	ldr	r3, [r3, #0]
20001b42:	f103 0330 	add.w	r3, r3, #48	; 0x30
20001b46:	4618      	mov	r0, r3
20001b48:	f04f 0106 	mov.w	r1, #6
20001b4c:	f7ff fd50 	bl	200015f0 <clear_bit_reg8>

    /* disable fractional baud-rate */
    clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR); 
20001b50:	68fb      	ldr	r3, [r7, #12]
20001b52:	681b      	ldr	r3, [r3, #0]
20001b54:	f103 0330 	add.w	r3, r3, #48	; 0x30
20001b58:	4618      	mov	r0, r3
20001b5a:	f04f 0107 	mov.w	r1, #7
20001b5e:	f7ff fd47 	bl	200015f0 <clear_bit_reg8>

    /* disable single wire mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2,ESWM);
20001b62:	68fb      	ldr	r3, [r7, #12]
20001b64:	681b      	ldr	r3, [r3, #0]
20001b66:	f103 0338 	add.w	r3, r3, #56	; 0x38
20001b6a:	4618      	mov	r0, r3
20001b6c:	f04f 0103 	mov.w	r1, #3
20001b70:	f7ff fd3e 	bl	200015f0 <clear_bit_reg8>

    /* set filter to minimum value */
    this_uart->hw_reg->GFR = 0u;
20001b74:	68fb      	ldr	r3, [r7, #12]
20001b76:	681b      	ldr	r3, [r3, #0]
20001b78:	f04f 0200 	mov.w	r2, #0
20001b7c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    /* set default TX time gaurd */
    this_uart->hw_reg->TTG = 0u;
20001b80:	68fb      	ldr	r3, [r7, #12]
20001b82:	681b      	ldr	r3, [r3, #0]
20001b84:	f04f 0200 	mov.w	r2, #0
20001b88:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* set default RX timeout */
    this_uart->hw_reg->RTO = 0u;
20001b8c:	68fb      	ldr	r3, [r7, #12]
20001b8e:	681b      	ldr	r3, [r3, #0]
20001b90:	f04f 0200 	mov.w	r2, #0
20001b94:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    
    /* 
     * Configure baud rate divisors. This uses the frational baud rate divisor
     * where possible to provide the most accurate baud rat possible.
     */
    config_baud_divisors(this_uart, baud_rate);
20001b98:	68f8      	ldr	r0, [r7, #12]
20001b9a:	68b9      	ldr	r1, [r7, #8]
20001b9c:	f7ff fe40 	bl	20001820 <config_baud_divisors>

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
20001ba0:	68fb      	ldr	r3, [r7, #12]
20001ba2:	681b      	ldr	r3, [r3, #0]
20001ba4:	79fa      	ldrb	r2, [r7, #7]
20001ba6:	731a      	strb	r2, [r3, #12]

    /* Instance setup */
    this_uart->baudrate = baud_rate;
20001ba8:	68fb      	ldr	r3, [r7, #12]
20001baa:	68ba      	ldr	r2, [r7, #8]
20001bac:	609a      	str	r2, [r3, #8]
    this_uart->lineconfig = line_config;
20001bae:	68fb      	ldr	r3, [r7, #12]
20001bb0:	79fa      	ldrb	r2, [r7, #7]
20001bb2:	731a      	strb	r2, [r3, #12]
    this_uart->tx_buff_size = TX_COMPLETE;
20001bb4:	68fb      	ldr	r3, [r7, #12]
20001bb6:	f04f 0200 	mov.w	r2, #0
20001bba:	615a      	str	r2, [r3, #20]
    this_uart->tx_buffer = (const uint8_t *)0;
20001bbc:	68fb      	ldr	r3, [r7, #12]
20001bbe:	f04f 0200 	mov.w	r2, #0
20001bc2:	611a      	str	r2, [r3, #16]
    this_uart->tx_idx = 0u;
20001bc4:	68fb      	ldr	r3, [r7, #12]
20001bc6:	f04f 0200 	mov.w	r2, #0
20001bca:	619a      	str	r2, [r3, #24]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
20001bcc:	68fb      	ldr	r3, [r7, #12]
20001bce:	f04f 0200 	mov.w	r2, #0
20001bd2:	621a      	str	r2, [r3, #32]
    this_uart->tx_handler       = NULL_HANDLER;
20001bd4:	68fb      	ldr	r3, [r7, #12]
20001bd6:	f04f 0200 	mov.w	r2, #0
20001bda:	625a      	str	r2, [r3, #36]	; 0x24
    this_uart->linests_handler  = NULL_HANDLER;
20001bdc:	68fb      	ldr	r3, [r7, #12]
20001bde:	f04f 0200 	mov.w	r2, #0
20001be2:	61da      	str	r2, [r3, #28]
    this_uart->modemsts_handler = NULL_HANDLER;
20001be4:	68fb      	ldr	r3, [r7, #12]
20001be6:	f04f 0200 	mov.w	r2, #0
20001bea:	629a      	str	r2, [r3, #40]	; 0x28
    this_uart->rto_handler      = NULL_HANDLER;    
20001bec:	68fb      	ldr	r3, [r7, #12]
20001bee:	f04f 0200 	mov.w	r2, #0
20001bf2:	62da      	str	r2, [r3, #44]	; 0x2c
    this_uart->nack_handler     = NULL_HANDLER;   
20001bf4:	68fb      	ldr	r3, [r7, #12]
20001bf6:	f04f 0200 	mov.w	r2, #0
20001bfa:	631a      	str	r2, [r3, #48]	; 0x30
    this_uart->pid_pei_handler  = NULL_HANDLER;
20001bfc:	68fb      	ldr	r3, [r7, #12]
20001bfe:	f04f 0200 	mov.w	r2, #0
20001c02:	635a      	str	r2, [r3, #52]	; 0x34
    this_uart->break_handler    = NULL_HANDLER;    
20001c04:	68fb      	ldr	r3, [r7, #12]
20001c06:	f04f 0200 	mov.w	r2, #0
20001c0a:	639a      	str	r2, [r3, #56]	; 0x38
    this_uart->sync_handler     = NULL_HANDLER;   
20001c0c:	68fb      	ldr	r3, [r7, #12]
20001c0e:	f04f 0200 	mov.w	r2, #0
20001c12:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Initialize the sticky status */
    this_uart->status = 0u;
20001c14:	68fb      	ldr	r3, [r7, #12]
20001c16:	f04f 0200 	mov.w	r2, #0
20001c1a:	735a      	strb	r2, [r3, #13]
}
20001c1c:	f107 0710 	add.w	r7, r7, #16
20001c20:	46bd      	mov	sp, r7
20001c22:	bd80      	pop	{r7, pc}

20001c24 <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
20001c24:	b580      	push	{r7, lr}
20001c26:	b084      	sub	sp, #16
20001c28:	af00      	add	r7, sp, #0
20001c2a:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20001c2c:	687a      	ldr	r2, [r7, #4]
20001c2e:	f248 5334 	movw	r3, #34100	; 0x8534
20001c32:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c36:	429a      	cmp	r2, r3
20001c38:	d007      	beq.n	20001c4a <MSS_UART_isr+0x26>
20001c3a:	687a      	ldr	r2, [r7, #4]
20001c3c:	f248 43f4 	movw	r3, #34036	; 0x84f4
20001c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c44:	429a      	cmp	r2, r3
20001c46:	d000      	beq.n	20001c4a <MSS_UART_isr+0x26>
20001c48:	be00      	bkpt	0x0000

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
20001c4a:	687a      	ldr	r2, [r7, #4]
20001c4c:	f248 5334 	movw	r3, #34100	; 0x8534
20001c50:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c54:	429a      	cmp	r2, r3
20001c56:	d007      	beq.n	20001c68 <MSS_UART_isr+0x44>
20001c58:	687a      	ldr	r2, [r7, #4]
20001c5a:	f248 43f4 	movw	r3, #34036	; 0x84f4
20001c5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c62:	429a      	cmp	r2, r3
20001c64:	f040 80ef 	bne.w	20001e46 <MSS_UART_isr+0x222>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
20001c68:	687b      	ldr	r3, [r7, #4]
20001c6a:	681b      	ldr	r3, [r3, #0]
20001c6c:	7a1b      	ldrb	r3, [r3, #8]
20001c6e:	b2db      	uxtb	r3, r3
20001c70:	f003 030f 	and.w	r3, r3, #15
20001c74:	73fb      	strb	r3, [r7, #15]

        switch (iirf)
20001c76:	7bfb      	ldrb	r3, [r7, #15]
20001c78:	2b0c      	cmp	r3, #12
20001c7a:	f200 80d7 	bhi.w	20001e2c <MSS_UART_isr+0x208>
20001c7e:	a201      	add	r2, pc, #4	; (adr r2, 20001c84 <MSS_UART_isr+0x60>)
20001c80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001c84:	20001cb9 	.word	0x20001cb9
20001c88:	20001e2d 	.word	0x20001e2d
20001c8c:	20001cd7 	.word	0x20001cd7
20001c90:	20001d31 	.word	0x20001d31
20001c94:	20001cf5 	.word	0x20001cf5
20001c98:	20001e2d 	.word	0x20001e2d
20001c9c:	20001d13 	.word	0x20001d13
20001ca0:	20001e2d 	.word	0x20001e2d
20001ca4:	20001e2d 	.word	0x20001e2d
20001ca8:	20001e2d 	.word	0x20001e2d
20001cac:	20001e2d 	.word	0x20001e2d
20001cb0:	20001e2d 	.word	0x20001e2d
20001cb4:	20001cf5 	.word	0x20001cf5
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->modemsts_handler);
20001cb8:	687b      	ldr	r3, [r7, #4]
20001cba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20001cbc:	2b00      	cmp	r3, #0
20001cbe:	d100      	bne.n	20001cc2 <MSS_UART_isr+0x9e>
20001cc0:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->modemsts_handler)
20001cc2:	687b      	ldr	r3, [r7, #4]
20001cc4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20001cc6:	2b00      	cmp	r3, #0
20001cc8:	f000 80b2 	beq.w	20001e30 <MSS_UART_isr+0x20c>
                {
                   (*(this_uart->modemsts_handler))(this_uart);
20001ccc:	687b      	ldr	r3, [r7, #4]
20001cce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20001cd0:	6878      	ldr	r0, [r7, #4]
20001cd2:	4798      	blx	r3
                }
            }
            break;
20001cd4:	e0b7      	b.n	20001e46 <MSS_UART_isr+0x222>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT(NULL_HANDLER != this_uart->tx_handler);
20001cd6:	687b      	ldr	r3, [r7, #4]
20001cd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001cda:	2b00      	cmp	r3, #0
20001cdc:	d100      	bne.n	20001ce0 <MSS_UART_isr+0xbc>
20001cde:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->tx_handler)
20001ce0:	687b      	ldr	r3, [r7, #4]
20001ce2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001ce4:	2b00      	cmp	r3, #0
20001ce6:	f000 80a5 	beq.w	20001e34 <MSS_UART_isr+0x210>
                {
                    (*(this_uart->tx_handler))(this_uart);
20001cea:	687b      	ldr	r3, [r7, #4]
20001cec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001cee:	6878      	ldr	r0, [r7, #4]
20001cf0:	4798      	blx	r3
                }
            }
            break;
20001cf2:	e0a8      	b.n	20001e46 <MSS_UART_isr+0x222>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT(NULL_HANDLER != this_uart->rx_handler);
20001cf4:	687b      	ldr	r3, [r7, #4]
20001cf6:	6a1b      	ldr	r3, [r3, #32]
20001cf8:	2b00      	cmp	r3, #0
20001cfa:	d100      	bne.n	20001cfe <MSS_UART_isr+0xda>
20001cfc:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->rx_handler)
20001cfe:	687b      	ldr	r3, [r7, #4]
20001d00:	6a1b      	ldr	r3, [r3, #32]
20001d02:	2b00      	cmp	r3, #0
20001d04:	f000 8098 	beq.w	20001e38 <MSS_UART_isr+0x214>
                {
                    (*(this_uart->rx_handler))(this_uart);
20001d08:	687b      	ldr	r3, [r7, #4]
20001d0a:	6a1b      	ldr	r3, [r3, #32]
20001d0c:	6878      	ldr	r0, [r7, #4]
20001d0e:	4798      	blx	r3
                }
            }
            break;
20001d10:	e099      	b.n	20001e46 <MSS_UART_isr+0x222>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->linests_handler);
20001d12:	687b      	ldr	r3, [r7, #4]
20001d14:	69db      	ldr	r3, [r3, #28]
20001d16:	2b00      	cmp	r3, #0
20001d18:	d100      	bne.n	20001d1c <MSS_UART_isr+0xf8>
20001d1a:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->linests_handler)
20001d1c:	687b      	ldr	r3, [r7, #4]
20001d1e:	69db      	ldr	r3, [r3, #28]
20001d20:	2b00      	cmp	r3, #0
20001d22:	f000 808b 	beq.w	20001e3c <MSS_UART_isr+0x218>
                {
                   (*(this_uart->linests_handler))(this_uart);
20001d26:	687b      	ldr	r3, [r7, #4]
20001d28:	69db      	ldr	r3, [r3, #28]
20001d2a:	6878      	ldr	r0, [r7, #4]
20001d2c:	4798      	blx	r3
                }
            }
            break;
20001d2e:	e08a      	b.n	20001e46 <MSS_UART_isr+0x222>
            case IIRF_MMI:
            {
                /* Identify multimode interrupts and handle */

                /* Receiver time-out interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ERTOI))
20001d30:	687b      	ldr	r3, [r7, #4]
20001d32:	681b      	ldr	r3, [r3, #0]
20001d34:	f103 0328 	add.w	r3, r3, #40	; 0x28
20001d38:	4618      	mov	r0, r3
20001d3a:	f04f 0100 	mov.w	r1, #0
20001d3e:	f7ff fc77 	bl	20001630 <read_bit_reg8>
20001d42:	4603      	mov	r3, r0
20001d44:	2b00      	cmp	r3, #0
20001d46:	d00c      	beq.n	20001d62 <MSS_UART_isr+0x13e>
                {
                    ASSERT(NULL_HANDLER != this_uart->rto_handler);
20001d48:	687b      	ldr	r3, [r7, #4]
20001d4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001d4c:	2b00      	cmp	r3, #0
20001d4e:	d100      	bne.n	20001d52 <MSS_UART_isr+0x12e>
20001d50:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->rto_handler)
20001d52:	687b      	ldr	r3, [r7, #4]
20001d54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001d56:	2b00      	cmp	r3, #0
20001d58:	d003      	beq.n	20001d62 <MSS_UART_isr+0x13e>
                    {
                        (*(this_uart->rto_handler))(this_uart);
20001d5a:	687b      	ldr	r3, [r7, #4]
20001d5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001d5e:	6878      	ldr	r0, [r7, #4]
20001d60:	4798      	blx	r3
                    }
                }
                /* NACK interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ENACKI))
20001d62:	687b      	ldr	r3, [r7, #4]
20001d64:	681b      	ldr	r3, [r3, #0]
20001d66:	f103 0328 	add.w	r3, r3, #40	; 0x28
20001d6a:	4618      	mov	r0, r3
20001d6c:	f04f 0101 	mov.w	r1, #1
20001d70:	f7ff fc5e 	bl	20001630 <read_bit_reg8>
20001d74:	4603      	mov	r3, r0
20001d76:	2b00      	cmp	r3, #0
20001d78:	d00c      	beq.n	20001d94 <MSS_UART_isr+0x170>
                {
                    ASSERT(NULL_HANDLER != this_uart->nack_handler);
20001d7a:	687b      	ldr	r3, [r7, #4]
20001d7c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001d7e:	2b00      	cmp	r3, #0
20001d80:	d100      	bne.n	20001d84 <MSS_UART_isr+0x160>
20001d82:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->nack_handler)
20001d84:	687b      	ldr	r3, [r7, #4]
20001d86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001d88:	2b00      	cmp	r3, #0
20001d8a:	d003      	beq.n	20001d94 <MSS_UART_isr+0x170>
                    {
                        (*(this_uart->nack_handler))(this_uart);
20001d8c:	687b      	ldr	r3, [r7, #4]
20001d8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001d90:	6878      	ldr	r0, [r7, #4]
20001d92:	4798      	blx	r3
                    }
                }

                /* PID parity error interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,EPID_PEI))
20001d94:	687b      	ldr	r3, [r7, #4]
20001d96:	681b      	ldr	r3, [r3, #0]
20001d98:	f103 0328 	add.w	r3, r3, #40	; 0x28
20001d9c:	4618      	mov	r0, r3
20001d9e:	f04f 0102 	mov.w	r1, #2
20001da2:	f7ff fc45 	bl	20001630 <read_bit_reg8>
20001da6:	4603      	mov	r3, r0
20001da8:	2b00      	cmp	r3, #0
20001daa:	d00c      	beq.n	20001dc6 <MSS_UART_isr+0x1a2>
                {
                    ASSERT(NULL_HANDLER != this_uart->pid_pei_handler);
20001dac:	687b      	ldr	r3, [r7, #4]
20001dae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001db0:	2b00      	cmp	r3, #0
20001db2:	d100      	bne.n	20001db6 <MSS_UART_isr+0x192>
20001db4:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->pid_pei_handler)
20001db6:	687b      	ldr	r3, [r7, #4]
20001db8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001dba:	2b00      	cmp	r3, #0
20001dbc:	d003      	beq.n	20001dc6 <MSS_UART_isr+0x1a2>
                    {
                        (*(this_uart->pid_pei_handler))(this_uart);
20001dbe:	687b      	ldr	r3, [r7, #4]
20001dc0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001dc2:	6878      	ldr	r0, [r7, #4]
20001dc4:	4798      	blx	r3
                    }
                }

                /* LIN break detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINBI))
20001dc6:	687b      	ldr	r3, [r7, #4]
20001dc8:	681b      	ldr	r3, [r3, #0]
20001dca:	f103 0328 	add.w	r3, r3, #40	; 0x28
20001dce:	4618      	mov	r0, r3
20001dd0:	f04f 0103 	mov.w	r1, #3
20001dd4:	f7ff fc2c 	bl	20001630 <read_bit_reg8>
20001dd8:	4603      	mov	r3, r0
20001dda:	2b00      	cmp	r3, #0
20001ddc:	d00c      	beq.n	20001df8 <MSS_UART_isr+0x1d4>
                {
                    ASSERT(NULL_HANDLER != this_uart->break_handler);
20001dde:	687b      	ldr	r3, [r7, #4]
20001de0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20001de2:	2b00      	cmp	r3, #0
20001de4:	d100      	bne.n	20001de8 <MSS_UART_isr+0x1c4>
20001de6:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->break_handler)
20001de8:	687b      	ldr	r3, [r7, #4]
20001dea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20001dec:	2b00      	cmp	r3, #0
20001dee:	d003      	beq.n	20001df8 <MSS_UART_isr+0x1d4>
                    {
                        (*(this_uart->break_handler))(this_uart);
20001df0:	687b      	ldr	r3, [r7, #4]
20001df2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20001df4:	6878      	ldr	r0, [r7, #4]
20001df6:	4798      	blx	r3
                    }
                }

                /* LIN Sync detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINSI))
20001df8:	687b      	ldr	r3, [r7, #4]
20001dfa:	681b      	ldr	r3, [r3, #0]
20001dfc:	f103 0328 	add.w	r3, r3, #40	; 0x28
20001e00:	4618      	mov	r0, r3
20001e02:	f04f 0104 	mov.w	r1, #4
20001e06:	f7ff fc13 	bl	20001630 <read_bit_reg8>
20001e0a:	4603      	mov	r3, r0
20001e0c:	2b00      	cmp	r3, #0
20001e0e:	d017      	beq.n	20001e40 <MSS_UART_isr+0x21c>
                {
                    ASSERT(NULL_HANDLER != this_uart->sync_handler);
20001e10:	687b      	ldr	r3, [r7, #4]
20001e12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20001e14:	2b00      	cmp	r3, #0
20001e16:	d100      	bne.n	20001e1a <MSS_UART_isr+0x1f6>
20001e18:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->sync_handler)
20001e1a:	687b      	ldr	r3, [r7, #4]
20001e1c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20001e1e:	2b00      	cmp	r3, #0
20001e20:	d010      	beq.n	20001e44 <MSS_UART_isr+0x220>
                    {
                        (*(this_uart->sync_handler))(this_uart);
20001e22:	687b      	ldr	r3, [r7, #4]
20001e24:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20001e26:	6878      	ldr	r0, [r7, #4]
20001e28:	4798      	blx	r3
                    }
                }
                break;
20001e2a:	e00c      	b.n	20001e46 <MSS_UART_isr+0x222>
            }

            default:
            {
                ASSERT(INVALID_INTERRUPT);
20001e2c:	be00      	bkpt	0x0000
20001e2e:	e00a      	b.n	20001e46 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->modemsts_handler)
                {
                   (*(this_uart->modemsts_handler))(this_uart);
                }
            }
            break;
20001e30:	bf00      	nop
20001e32:	e008      	b.n	20001e46 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->tx_handler)
                {
                    (*(this_uart->tx_handler))(this_uart);
                }
            }
            break;
20001e34:	bf00      	nop
20001e36:	e006      	b.n	20001e46 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->rx_handler)
                {
                    (*(this_uart->rx_handler))(this_uart);
                }
            }
            break;
20001e38:	bf00      	nop
20001e3a:	e004      	b.n	20001e46 <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->linests_handler)
                {
                   (*(this_uart->linests_handler))(this_uart);
                }
            }
            break;
20001e3c:	bf00      	nop
20001e3e:	e002      	b.n	20001e46 <MSS_UART_isr+0x222>
                    if(NULL_HANDLER != this_uart->sync_handler)
                    {
                        (*(this_uart->sync_handler))(this_uart);
                    }
                }
                break;
20001e40:	bf00      	nop
20001e42:	e000      	b.n	20001e46 <MSS_UART_isr+0x222>
20001e44:	bf00      	nop
                ASSERT(INVALID_INTERRUPT);
            }
            break;
        }
    }
}
20001e46:	f107 0710 	add.w	r7, r7, #16
20001e4a:	46bd      	mov	sp, r7
20001e4c:	bd80      	pop	{r7, pc}
20001e4e:	bf00      	nop

20001e50 <default_tx_handler>:
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
20001e50:	b580      	push	{r7, lr}
20001e52:	b086      	sub	sp, #24
20001e54:	af00      	add	r7, sp, #0
20001e56:	6078      	str	r0, [r7, #4]
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20001e58:	687a      	ldr	r2, [r7, #4]
20001e5a:	f248 5334 	movw	r3, #34100	; 0x8534
20001e5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e62:	429a      	cmp	r2, r3
20001e64:	d007      	beq.n	20001e76 <default_tx_handler+0x26>
20001e66:	687a      	ldr	r2, [r7, #4]
20001e68:	f248 43f4 	movw	r3, #34036	; 0x84f4
20001e6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e70:	429a      	cmp	r2, r3
20001e72:	d000      	beq.n	20001e76 <default_tx_handler+0x26>
20001e74:	be00      	bkpt	0x0000
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
20001e76:	687b      	ldr	r3, [r7, #4]
20001e78:	691b      	ldr	r3, [r3, #16]
20001e7a:	2b00      	cmp	r3, #0
20001e7c:	d100      	bne.n	20001e80 <default_tx_handler+0x30>
20001e7e:	be00      	bkpt	0x0000
    ASSERT(0u < this_uart->tx_buff_size);
20001e80:	687b      	ldr	r3, [r7, #4]
20001e82:	695b      	ldr	r3, [r3, #20]
20001e84:	2b00      	cmp	r3, #0
20001e86:	d100      	bne.n	20001e8a <default_tx_handler+0x3a>
20001e88:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20001e8a:	687a      	ldr	r2, [r7, #4]
20001e8c:	f248 5334 	movw	r3, #34100	; 0x8534
20001e90:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e94:	429a      	cmp	r2, r3
20001e96:	d006      	beq.n	20001ea6 <default_tx_handler+0x56>
20001e98:	687a      	ldr	r2, [r7, #4]
20001e9a:	f248 43f4 	movw	r3, #34036	; 0x84f4
20001e9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ea2:	429a      	cmp	r2, r3
20001ea4:	d155      	bne.n	20001f52 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
20001ea6:	687b      	ldr	r3, [r7, #4]
20001ea8:	691b      	ldr	r3, [r3, #16]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20001eaa:	2b00      	cmp	r3, #0
20001eac:	d051      	beq.n	20001f52 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
20001eae:	687b      	ldr	r3, [r7, #4]
20001eb0:	695b      	ldr	r3, [r3, #20]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20001eb2:	2b00      	cmp	r3, #0
20001eb4:	d04d      	beq.n	20001f52 <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
20001eb6:	687b      	ldr	r3, [r7, #4]
20001eb8:	681b      	ldr	r3, [r3, #0]
20001eba:	7d1b      	ldrb	r3, [r3, #20]
20001ebc:	72fb      	strb	r3, [r7, #11]
        this_uart->status |= status;
20001ebe:	687b      	ldr	r3, [r7, #4]
20001ec0:	7b5a      	ldrb	r2, [r3, #13]
20001ec2:	7afb      	ldrb	r3, [r7, #11]
20001ec4:	ea42 0303 	orr.w	r3, r2, r3
20001ec8:	b2da      	uxtb	r2, r3
20001eca:	687b      	ldr	r3, [r7, #4]
20001ecc:	735a      	strb	r2, [r3, #13]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if(status & MSS_UART_THRE)
20001ece:	7afb      	ldrb	r3, [r7, #11]
20001ed0:	f003 0320 	and.w	r3, r3, #32
20001ed4:	2b00      	cmp	r3, #0
20001ed6:	d029      	beq.n	20001f2c <default_tx_handler+0xdc>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
20001ed8:	f04f 0310 	mov.w	r3, #16
20001edc:	613b      	str	r3, [r7, #16]
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
20001ede:	687b      	ldr	r3, [r7, #4]
20001ee0:	695a      	ldr	r2, [r3, #20]
20001ee2:	687b      	ldr	r3, [r7, #4]
20001ee4:	699b      	ldr	r3, [r3, #24]
20001ee6:	ebc3 0302 	rsb	r3, r3, r2
20001eea:	617b      	str	r3, [r7, #20]

            /* Calculate the number of bytes to transmit. */
            if(tx_remain < TX_FIFO_SIZE)
20001eec:	697b      	ldr	r3, [r7, #20]
20001eee:	2b0f      	cmp	r3, #15
20001ef0:	d801      	bhi.n	20001ef6 <default_tx_handler+0xa6>
            {
                fill_size = tx_remain;
20001ef2:	697b      	ldr	r3, [r7, #20]
20001ef4:	613b      	str	r3, [r7, #16]
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
20001ef6:	f04f 0300 	mov.w	r3, #0
20001efa:	60fb      	str	r3, [r7, #12]
20001efc:	e012      	b.n	20001f24 <default_tx_handler+0xd4>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
20001efe:	687b      	ldr	r3, [r7, #4]
20001f00:	681b      	ldr	r3, [r3, #0]
20001f02:	687a      	ldr	r2, [r7, #4]
20001f04:	6911      	ldr	r1, [r2, #16]
20001f06:	687a      	ldr	r2, [r7, #4]
20001f08:	6992      	ldr	r2, [r2, #24]
20001f0a:	440a      	add	r2, r1
20001f0c:	7812      	ldrb	r2, [r2, #0]
20001f0e:	701a      	strb	r2, [r3, #0]
                ++this_uart->tx_idx;
20001f10:	687b      	ldr	r3, [r7, #4]
20001f12:	699b      	ldr	r3, [r3, #24]
20001f14:	f103 0201 	add.w	r2, r3, #1
20001f18:	687b      	ldr	r3, [r7, #4]
20001f1a:	619a      	str	r2, [r3, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
20001f1c:	68fb      	ldr	r3, [r7, #12]
20001f1e:	f103 0301 	add.w	r3, r3, #1
20001f22:	60fb      	str	r3, [r7, #12]
20001f24:	68fa      	ldr	r2, [r7, #12]
20001f26:	693b      	ldr	r3, [r7, #16]
20001f28:	429a      	cmp	r2, r3
20001f2a:	d3e8      	bcc.n	20001efe <default_tx_handler+0xae>
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
20001f2c:	687b      	ldr	r3, [r7, #4]
20001f2e:	699a      	ldr	r2, [r3, #24]
20001f30:	687b      	ldr	r3, [r7, #4]
20001f32:	695b      	ldr	r3, [r3, #20]
20001f34:	429a      	cmp	r2, r3
20001f36:	d10c      	bne.n	20001f52 <default_tx_handler+0x102>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
20001f38:	687b      	ldr	r3, [r7, #4]
20001f3a:	f04f 0200 	mov.w	r2, #0
20001f3e:	615a      	str	r2, [r3, #20]
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
20001f40:	687b      	ldr	r3, [r7, #4]
20001f42:	681b      	ldr	r3, [r3, #0]
20001f44:	f103 0304 	add.w	r3, r3, #4
20001f48:	4618      	mov	r0, r3
20001f4a:	f04f 0101 	mov.w	r1, #1
20001f4e:	f7ff fb4f 	bl	200015f0 <clear_bit_reg8>
        }
    }
}
20001f52:	f107 0718 	add.w	r7, r7, #24
20001f56:	46bd      	mov	sp, r7
20001f58:	bd80      	pop	{r7, pc}
20001f5a:	bf00      	nop

20001f5c <MSS_SYS_init>:

/*==============================================================================
 * See mss_sys_services.h for details.
 */
void MSS_SYS_init(sys_serv_async_event_handler_t event_handler)
{   
20001f5c:	b580      	push	{r7, lr}
20001f5e:	b082      	sub	sp, #8
20001f60:	af00      	add	r7, sp, #0
20001f62:	6078      	str	r0, [r7, #4]
    g_event_handler = event_handler;
20001f64:	f245 2370 	movw	r3, #21104	; 0x5270
20001f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f6c:	687a      	ldr	r2, [r7, #4]
20001f6e:	601a      	str	r2, [r3, #0]
    g_last_response_length = 0u;
20001f70:	f245 236e 	movw	r3, #21102	; 0x526e
20001f74:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f78:	f04f 0200 	mov.w	r2, #0
20001f7c:	801a      	strh	r2, [r3, #0]
    g_request_in_progress = 0u;
20001f7e:	f245 236c 	movw	r3, #21100	; 0x526c
20001f82:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f86:	f04f 0200 	mov.w	r2, #0
20001f8a:	701a      	strb	r2, [r3, #0]
    
    /*
     * Set a default good value for g_initial_mssddr_facc1_cr used to control
     * the clock dividers coming in and out of Flash*Freeze.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
20001f8c:	f248 0300 	movw	r3, #32768	; 0x8000
20001f90:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001f94:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
20001f98:	f245 2378 	movw	r3, #21112	; 0x5278
20001f9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001fa0:	601a      	str	r2, [r3, #0]
    
    /*
     * Initialize the COMBLK used to communicate with the System Controller.
     */
    MSS_COMBLK_init(asynchronous_event_handler, g_response);
20001fa2:	f641 70c1 	movw	r0, #8129	; 0x1fc1
20001fa6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001faa:	f245 2174 	movw	r1, #21108	; 0x5274
20001fae:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001fb2:	f001 fef7 	bl	20003da4 <MSS_COMBLK_init>
}
20001fb6:	f107 0708 	add.w	r7, r7, #8
20001fba:	46bd      	mov	sp, r7
20001fbc:	bd80      	pop	{r7, pc}
20001fbe:	bf00      	nop

20001fc0 <asynchronous_event_handler>:
#define TAMPER_HARDWARE_MONITOR_ERROR_OPCODE_RANGE_MAX   0xB7u

#define FACC_GLMUX_SEL_MASK         0x00001000u
#define DELAY_MORE_THAN_10US        5000U
static void asynchronous_event_handler(uint8_t event_opcode)
{
20001fc0:	b580      	push	{r7, lr}
20001fc2:	b086      	sub	sp, #24
20001fc4:	af00      	add	r7, sp, #0
20001fc6:	4603      	mov	r3, r0
20001fc8:	71fb      	strb	r3, [r7, #7]
    if (event_opcode == FLASH_FREEZE_SHUTDOWN_OPCODE)
20001fca:	79fb      	ldrb	r3, [r7, #7]
20001fcc:	2be0      	cmp	r3, #224	; 0xe0
20001fce:	d12b      	bne.n	20002028 <asynchronous_event_handler+0x68>
        /*
         * Wait for the System Controller to switch the system's clock
         * from the main clock to the  standby clock. This should take place
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
20001fd0:	f241 3388 	movw	r3, #5000	; 0x1388
20001fd4:	60fb      	str	r3, [r7, #12]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
20001fd6:	f248 0300 	movw	r3, #32768	; 0x8000
20001fda:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001fde:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20001fe2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20001fe6:	613b      	str	r3, [r7, #16]
            --timeout;
20001fe8:	68fb      	ldr	r3, [r7, #12]
20001fea:	f103 33ff 	add.w	r3, r3, #4294967295
20001fee:	60fb      	str	r3, [r7, #12]
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
20001ff0:	693b      	ldr	r3, [r7, #16]
20001ff2:	2b00      	cmp	r3, #0
20001ff4:	d102      	bne.n	20001ffc <asynchronous_event_handler+0x3c>
20001ff6:	68fb      	ldr	r3, [r7, #12]
20001ff8:	2b00      	cmp	r3, #0
20001ffa:	d1ec      	bne.n	20001fd6 <asynchronous_event_handler+0x16>

        /* Call the user's event handler. */
        if(g_event_handler != 0)
20001ffc:	f245 2370 	movw	r3, #21104	; 0x5270
20002000:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002004:	681b      	ldr	r3, [r3, #0]
20002006:	2b00      	cmp	r3, #0
20002008:	d068      	beq.n	200020dc <asynchronous_event_handler+0x11c>
        {
            g_event_handler(event_opcode, g_response[1]);
2000200a:	f245 2370 	movw	r3, #21104	; 0x5270
2000200e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002012:	681a      	ldr	r2, [r3, #0]
20002014:	f245 2374 	movw	r3, #21108	; 0x5274
20002018:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000201c:	785b      	ldrb	r3, [r3, #1]
2000201e:	79f9      	ldrb	r1, [r7, #7]
20002020:	4608      	mov	r0, r1
20002022:	4619      	mov	r1, r3
20002024:	4790      	blx	r2
20002026:	e05c      	b.n	200020e2 <asynchronous_event_handler+0x122>
        }
    }
    else if (event_opcode == FLASH_FREEZE_EXIT_OPCODE)
20002028:	79fb      	ldrb	r3, [r7, #7]
2000202a:	2be1      	cmp	r3, #225	; 0xe1
2000202c:	d12d      	bne.n	2000208a <asynchronous_event_handler+0xca>
        /*
         * Wait for the System Controller to switch the system's clock
         * from the standby clock to the main clock. This should take place
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
2000202e:	f241 3388 	movw	r3, #5000	; 0x1388
20002032:	60bb      	str	r3, [r7, #8]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
20002034:	f248 0300 	movw	r3, #32768	; 0x8000
20002038:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000203c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20002040:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20002044:	617b      	str	r3, [r7, #20]
            --timeout;
20002046:	68bb      	ldr	r3, [r7, #8]
20002048:	f103 33ff 	add.w	r3, r3, #4294967295
2000204c:	60bb      	str	r3, [r7, #8]
        }
        while ((running_on_standby_clock != 0U) && (timeout != 0U));
2000204e:	697b      	ldr	r3, [r7, #20]
20002050:	2b00      	cmp	r3, #0
20002052:	d002      	beq.n	2000205a <asynchronous_event_handler+0x9a>
20002054:	68bb      	ldr	r3, [r7, #8]
20002056:	2b00      	cmp	r3, #0
20002058:	d1ec      	bne.n	20002034 <asynchronous_event_handler+0x74>
        
        /* Restore the clock dividers values of FACC1 register. */
        revert_clk_config();
2000205a:	f000 fa7b 	bl	20002554 <revert_clk_config>
        
        if(g_event_handler != 0)
2000205e:	f245 2370 	movw	r3, #21104	; 0x5270
20002062:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002066:	681b      	ldr	r3, [r3, #0]
20002068:	2b00      	cmp	r3, #0
2000206a:	d039      	beq.n	200020e0 <asynchronous_event_handler+0x120>
        {
            /* Call the user's event handler. */
            g_event_handler(event_opcode, g_response[1]);
2000206c:	f245 2370 	movw	r3, #21104	; 0x5270
20002070:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002074:	681a      	ldr	r2, [r3, #0]
20002076:	f245 2374 	movw	r3, #21108	; 0x5274
2000207a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000207e:	785b      	ldrb	r3, [r3, #1]
20002080:	79f9      	ldrb	r1, [r7, #7]
20002082:	4608      	mov	r0, r1
20002084:	4619      	mov	r1, r3
20002086:	4790      	blx	r2
20002088:	e02b      	b.n	200020e2 <asynchronous_event_handler+0x122>
        }
    }
    else
    {
        if ((event_opcode == POR_DIGEST_ERROR_OPCODE) || \
2000208a:	79fb      	ldrb	r3, [r7, #7]
2000208c:	2bf1      	cmp	r3, #241	; 0xf1
2000208e:	d00f      	beq.n	200020b0 <asynchronous_event_handler+0xf0>
            ((event_opcode >= TAMPER_ATTEMPT_DETECT_OPCODE_RANGE_MIN) && \
20002090:	79fb      	ldrb	r3, [r7, #7]
            g_event_handler(event_opcode, g_response[1]);
        }
    }
    else
    {
        if ((event_opcode == POR_DIGEST_ERROR_OPCODE) || \
20002092:	b25b      	sxtb	r3, r3
20002094:	2b00      	cmp	r3, #0
20002096:	da02      	bge.n	2000209e <asynchronous_event_handler+0xde>
20002098:	79fb      	ldrb	r3, [r7, #7]
2000209a:	2b9f      	cmp	r3, #159	; 0x9f
2000209c:	d908      	bls.n	200020b0 <asynchronous_event_handler+0xf0>
2000209e:	79fb      	ldrb	r3, [r7, #7]
200020a0:	2ba0      	cmp	r3, #160	; 0xa0
200020a2:	d005      	beq.n	200020b0 <asynchronous_event_handler+0xf0>
200020a4:	79fb      	ldrb	r3, [r7, #7]
200020a6:	2bb0      	cmp	r3, #176	; 0xb0
200020a8:	d91b      	bls.n	200020e2 <asynchronous_event_handler+0x122>
200020aa:	79fb      	ldrb	r3, [r7, #7]
200020ac:	2bb7      	cmp	r3, #183	; 0xb7
200020ae:	d818      	bhi.n	200020e2 <asynchronous_event_handler+0x122>
            /* 
             * Inform to the application that new asynchronous message is received, 
             * only if application call-back function is registered during 
             * initialization. 
             */
            if(g_event_handler != 0)
200020b0:	f245 2370 	movw	r3, #21104	; 0x5270
200020b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200020b8:	681b      	ldr	r3, [r3, #0]
200020ba:	2b00      	cmp	r3, #0
200020bc:	d011      	beq.n	200020e2 <asynchronous_event_handler+0x122>
            {
                /* Call the user's event handler. */
                g_event_handler(event_opcode, g_response[1]);
200020be:	f245 2370 	movw	r3, #21104	; 0x5270
200020c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200020c6:	681a      	ldr	r2, [r3, #0]
200020c8:	f245 2374 	movw	r3, #21108	; 0x5274
200020cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200020d0:	785b      	ldrb	r3, [r3, #1]
200020d2:	79f9      	ldrb	r1, [r7, #7]
200020d4:	4608      	mov	r0, r1
200020d6:	4619      	mov	r1, r3
200020d8:	4790      	blx	r2
200020da:	e002      	b.n	200020e2 <asynchronous_event_handler+0x122>
        while ((running_on_standby_clock == 0U) && (timeout != 0U));

        /* Call the user's event handler. */
        if(g_event_handler != 0)
        {
            g_event_handler(event_opcode, g_response[1]);
200020dc:	bf00      	nop
200020de:	e000      	b.n	200020e2 <asynchronous_event_handler+0x122>
        revert_clk_config();
        
        if(g_event_handler != 0)
        {
            /* Call the user's event handler. */
            g_event_handler(event_opcode, g_response[1]);
200020e0:	bf00      	nop
                /* Call the user's event handler. */
                g_event_handler(event_opcode, g_response[1]);
            }
        }
    }
}
200020e2:	f107 0718 	add.w	r7, r7, #24
200020e6:	46bd      	mov	sp, r7
200020e8:	bd80      	pop	{r7, pc}
200020ea:	bf00      	nop

200020ec <determine_seq>:
 */
uint32_t divisor[4] = {0x00};
volatile uint8_t ind = 0;

static uint8_t* determine_seq(uint8_t val, uint8_t* len)
{
200020ec:	b480      	push	{r7}
200020ee:	b085      	sub	sp, #20
200020f0:	af00      	add	r7, sp, #0
200020f2:	4603      	mov	r3, r0
200020f4:	6039      	str	r1, [r7, #0]
200020f6:	71fb      	strb	r3, [r7, #7]
    uint8_t*seq;
    
    switch(val)
200020f8:	79fb      	ldrb	r3, [r7, #7]
200020fa:	2b06      	cmp	r3, #6
200020fc:	d84c      	bhi.n	20002198 <determine_seq+0xac>
200020fe:	a201      	add	r2, pc, #4	; (adr r2, 20002104 <determine_seq+0x18>)
20002100:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20002104:	20002121 	.word	0x20002121
20002108:	20002135 	.word	0x20002135
2000210c:	20002149 	.word	0x20002149
20002110:	20002199 	.word	0x20002199
20002114:	2000215d 	.word	0x2000215d
20002118:	20002171 	.word	0x20002171
2000211c:	20002185 	.word	0x20002185
    {
        case 0:
                seq = &div1_seq[0];
20002120:	f245 1308 	movw	r3, #20744	; 0x5108
20002124:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002128:	60fb      	str	r3, [r7, #12]
                *len = 4;
2000212a:	683b      	ldr	r3, [r7, #0]
2000212c:	f04f 0204 	mov.w	r2, #4
20002130:	701a      	strb	r2, [r3, #0]
            break;
20002132:	e038      	b.n	200021a6 <determine_seq+0xba>

        case 1:
                seq = &div2_seq[0];
20002134:	f245 130c 	movw	r3, #20748	; 0x510c
20002138:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000213c:	60fb      	str	r3, [r7, #12]
                *len = 3;
2000213e:	683b      	ldr	r3, [r7, #0]
20002140:	f04f 0203 	mov.w	r2, #3
20002144:	701a      	strb	r2, [r3, #0]
            break;
20002146:	e02e      	b.n	200021a6 <determine_seq+0xba>

        case 2:
                seq = &div4_seq[0];
20002148:	f245 1310 	movw	r3, #20752	; 0x5110
2000214c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002150:	60fb      	str	r3, [r7, #12]
                *len = 5;
20002152:	683b      	ldr	r3, [r7, #0]
20002154:	f04f 0205 	mov.w	r2, #5
20002158:	701a      	strb	r2, [r3, #0]
            break;
2000215a:	e024      	b.n	200021a6 <determine_seq+0xba>

        case 4:
                seq = &div8_seq[0];
2000215c:	f245 1318 	movw	r3, #20760	; 0x5118
20002160:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002164:	60fb      	str	r3, [r7, #12]
                *len = 3;
20002166:	683b      	ldr	r3, [r7, #0]
20002168:	f04f 0203 	mov.w	r2, #3
2000216c:	701a      	strb	r2, [r3, #0]
            break;
2000216e:	e01a      	b.n	200021a6 <determine_seq+0xba>

        case 5:
                seq = &div16_seq[0];
20002170:	f245 131c 	movw	r3, #20764	; 0x511c
20002174:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002178:	60fb      	str	r3, [r7, #12]
                *len = 2;
2000217a:	683b      	ldr	r3, [r7, #0]
2000217c:	f04f 0202 	mov.w	r2, #2
20002180:	701a      	strb	r2, [r3, #0]
            break;
20002182:	e010      	b.n	200021a6 <determine_seq+0xba>

        case 6:
                seq = &div32_seq[0];
20002184:	f245 1320 	movw	r3, #20768	; 0x5120
20002188:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000218c:	60fb      	str	r3, [r7, #12]
                *len = 2;
2000218e:	683b      	ldr	r3, [r7, #0]
20002190:	f04f 0202 	mov.w	r2, #2
20002194:	701a      	strb	r2, [r3, #0]
            break;
20002196:	e006      	b.n	200021a6 <determine_seq+0xba>

        default:
                *len = 0;
20002198:	683b      	ldr	r3, [r7, #0]
2000219a:	f04f 0200 	mov.w	r2, #0
2000219e:	701a      	strb	r2, [r3, #0]
                seq = NULL;
200021a0:	f04f 0300 	mov.w	r3, #0
200021a4:	60fb      	str	r3, [r7, #12]
            break;
    }
    
    return seq;
200021a6:	68fb      	ldr	r3, [r7, #12]
}
200021a8:	4618      	mov	r0, r3
200021aa:	f107 0714 	add.w	r7, r7, #20
200021ae:	46bd      	mov	sp, r7
200021b0:	bc80      	pop	{r7}
200021b2:	4770      	bx	lr

200021b4 <clk_switching_fix>:
 * divisor values of fclk, pclk0, pclk1 and clk_fic64, and if the divisor 
 * values are equal to each other, then firmware will send requested command to 
 * system controller otherwise return CLOCK_SWITCHING_ERROR error.
 */
static uint8_t clk_switching_fix(void)
{
200021b4:	b580      	push	{r7, lr}
200021b6:	b088      	sub	sp, #32
200021b8:	af00      	add	r7, sp, #0
    uint8_t* sequence;
    uint8_t len;
    volatile uint32_t g_mssddr_facc1_cr =  SYSREG->MSSDDR_FACC1_CR;
200021ba:	f248 0300 	movw	r3, #32768	; 0x8000
200021be:	f2c4 0303 	movt	r3, #16387	; 0x4003
200021c2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200021c6:	607b      	str	r3, [r7, #4]
    uint32_t var = 0;
200021c8:	f04f 0300 	mov.w	r3, #0
200021cc:	613b      	str	r3, [r7, #16]
    uint32_t temp = 0;
200021ce:	f04f 0300 	mov.w	r3, #0
200021d2:	617b      	str	r3, [r7, #20]
    uint32_t device_version;
    uint8_t status = CLOCK_SWITCHING_SUCCESS;
200021d4:	f04f 0300 	mov.w	r3, #0
200021d8:	77fb      	strb	r3, [r7, #31]
    
    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
200021da:	f248 0300 	movw	r3, #32768	; 0x8000
200021de:	f2c4 0303 	movt	r3, #16387	; 0x4003
200021e2:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
200021e6:	ea4f 4303 	mov.w	r3, r3, lsl #16
200021ea:	ea4f 4313 	mov.w	r3, r3, lsr #16
200021ee:	61bb      	str	r3, [r7, #24]

    /* For 10/25/50/90/150 devices */
    if((0xF802u == device_version) || \
200021f0:	69ba      	ldr	r2, [r7, #24]
200021f2:	f64f 0302 	movw	r3, #63490	; 0xf802
200021f6:	429a      	cmp	r2, r3
200021f8:	d013      	beq.n	20002222 <clk_switching_fix+0x6e>
200021fa:	69ba      	ldr	r2, [r7, #24]
200021fc:	f64f 0303 	movw	r3, #63491	; 0xf803
20002200:	429a      	cmp	r2, r3
20002202:	d00e      	beq.n	20002222 <clk_switching_fix+0x6e>
20002204:	69ba      	ldr	r2, [r7, #24]
20002206:	f64f 0304 	movw	r3, #63492	; 0xf804
2000220a:	429a      	cmp	r2, r3
2000220c:	d009      	beq.n	20002222 <clk_switching_fix+0x6e>
2000220e:	69ba      	ldr	r2, [r7, #24]
20002210:	f64f 0307 	movw	r3, #63495	; 0xf807
20002214:	429a      	cmp	r2, r3
20002216:	d004      	beq.n	20002222 <clk_switching_fix+0x6e>
20002218:	69ba      	ldr	r2, [r7, #24]
2000221a:	f64f 0306 	movw	r3, #63494	; 0xf806
2000221e:	429a      	cmp	r2, r3
20002220:	d11b      	bne.n	2000225a <clk_switching_fix+0xa6>
    {
        /* Dynamically divides down fclk, pclk0, pclk1 and clk_fic64
         * to the divided by 32 versions and M3_CLK, PCLK0, PCLK1, 
         * CLK_FIC64 all driven from CLK_STANDBY clock.
         */
        SYSREG->MSSDDR_FACC1_CR = (SYSREG->MSSDDR_FACC1_CR & CONFIG_CLOCK_DIV_MASK) | \
20002222:	f248 0100 	movw	r1, #32768	; 0x8000
20002226:	f2c4 0103 	movt	r1, #16387	; 0x4003
2000222a:	f248 0300 	movw	r3, #32768	; 0x8000
2000222e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002232:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20002236:	f24e 1203 	movw	r2, #57603	; 0xe103
2000223a:	f6cf 72c7 	movt	r2, #65479	; 0xffc7
2000223e:	ea03 0202 	and.w	r2, r3, r2
20002242:	f641 43d8 	movw	r3, #7384	; 0x1cd8
20002246:	f2c0 0330 	movt	r3, #48	; 0x30
2000224a:	ea42 0303 	orr.w	r3, r2, r3
2000224e:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
                                   CONFIG_CLOCK_DIV_32_RATIO;
        status = CLOCK_SWITCHING_SUCCESS;
20002252:	f04f 0300 	mov.w	r3, #0
20002256:	77fb      	strb	r3, [r7, #31]
    uint8_t status = CLOCK_SWITCHING_SUCCESS;
    
    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);

    /* For 10/25/50/90/150 devices */
    if((0xF802u == device_version) || \
20002258:	e175      	b.n	20002546 <clk_switching_fix+0x392>
    
    /* For 05 devices
     * When modifying clock divisor settings on M2S005, it is necessary to 
     * sequence them, depending on the starting configuration.
     */
    else if(0xF805u == device_version)
2000225a:	69ba      	ldr	r2, [r7, #24]
2000225c:	f64f 0305 	movw	r3, #63493	; 0xf805
20002260:	429a      	cmp	r2, r3
20002262:	f040 8116 	bne.w	20002492 <clk_switching_fix+0x2de>
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
20002266:	687b      	ldr	r3, [r7, #4]
20002268:	ea4f 0393 	mov.w	r3, r3, lsr #2
2000226c:	f003 0207 	and.w	r2, r3, #7
20002270:	f245 237c 	movw	r3, #21116	; 0x527c
20002274:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002278:	601a      	str	r2, [r3, #0]
        sequence = determine_seq(divisor[0], &len);
2000227a:	f245 237c 	movw	r3, #21116	; 0x527c
2000227e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002282:	681b      	ldr	r3, [r3, #0]
20002284:	b2da      	uxtb	r2, r3
20002286:	f107 030b 	add.w	r3, r7, #11
2000228a:	4610      	mov	r0, r2
2000228c:	4619      	mov	r1, r3
2000228e:	f7ff ff2d 	bl	200020ec <determine_seq>
20002292:	4603      	mov	r3, r0
20002294:	60fb      	str	r3, [r7, #12]

        for(var = 1; var < len; var++)
20002296:	f04f 0301 	mov.w	r3, #1
2000229a:	613b      	str	r3, [r7, #16]
2000229c:	e01f      	b.n	200022de <clk_switching_fix+0x12a>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
2000229e:	f248 0300 	movw	r3, #32768	; 0x8000
200022a2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200022a6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200022aa:	617b      	str	r3, [r7, #20]
            temp &= 0xFFFFFFE3u;
200022ac:	697b      	ldr	r3, [r7, #20]
200022ae:	f023 031c 	bic.w	r3, r3, #28
200022b2:	617b      	str	r3, [r7, #20]
            temp |= ((uint32_t)(sequence[var]) << 2);
200022b4:	68fa      	ldr	r2, [r7, #12]
200022b6:	693b      	ldr	r3, [r7, #16]
200022b8:	4413      	add	r3, r2
200022ba:	781b      	ldrb	r3, [r3, #0]
200022bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
200022c0:	697a      	ldr	r2, [r7, #20]
200022c2:	ea42 0303 	orr.w	r3, r2, r3
200022c6:	617b      	str	r3, [r7, #20]
            SYSREG->MSSDDR_FACC1_CR = temp;
200022c8:	f248 0300 	movw	r3, #32768	; 0x8000
200022cc:	f2c4 0303 	movt	r3, #16387	; 0x4003
200022d0:	697a      	ldr	r2, [r7, #20]
200022d2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
200022d6:	693b      	ldr	r3, [r7, #16]
200022d8:	f103 0301 	add.w	r3, r3, #1
200022dc:	613b      	str	r3, [r7, #16]
200022de:	7afb      	ldrb	r3, [r7, #11]
200022e0:	461a      	mov	r2, r3
200022e2:	693b      	ldr	r3, [r7, #16]
200022e4:	429a      	cmp	r2, r3
200022e6:	d8da      	bhi.n	2000229e <clk_switching_fix+0xea>
            temp |= ((uint32_t)(sequence[var]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
200022e8:	687b      	ldr	r3, [r7, #4]
200022ea:	ea4f 1353 	mov.w	r3, r3, lsr #5
200022ee:	f003 0207 	and.w	r2, r3, #7
200022f2:	f245 237c 	movw	r3, #21116	; 0x527c
200022f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200022fa:	605a      	str	r2, [r3, #4]
        sequence = determine_seq(divisor[1], &len);
200022fc:	f245 237c 	movw	r3, #21116	; 0x527c
20002300:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002304:	685b      	ldr	r3, [r3, #4]
20002306:	b2da      	uxtb	r2, r3
20002308:	f107 030b 	add.w	r3, r7, #11
2000230c:	4610      	mov	r0, r2
2000230e:	4619      	mov	r1, r3
20002310:	f7ff feec 	bl	200020ec <determine_seq>
20002314:	4603      	mov	r3, r0
20002316:	60fb      	str	r3, [r7, #12]

        for(var = 1; var < len; var++)
20002318:	f04f 0301 	mov.w	r3, #1
2000231c:	613b      	str	r3, [r7, #16]
2000231e:	e01f      	b.n	20002360 <clk_switching_fix+0x1ac>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20002320:	f248 0300 	movw	r3, #32768	; 0x8000
20002324:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002328:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2000232c:	617b      	str	r3, [r7, #20]
            temp &= 0xFFFFFF1Fu;
2000232e:	697b      	ldr	r3, [r7, #20]
20002330:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
20002334:	617b      	str	r3, [r7, #20]
            temp |= ((uint32_t)(sequence[var]) << 5);
20002336:	68fa      	ldr	r2, [r7, #12]
20002338:	693b      	ldr	r3, [r7, #16]
2000233a:	4413      	add	r3, r2
2000233c:	781b      	ldrb	r3, [r3, #0]
2000233e:	ea4f 1343 	mov.w	r3, r3, lsl #5
20002342:	697a      	ldr	r2, [r7, #20]
20002344:	ea42 0303 	orr.w	r3, r2, r3
20002348:	617b      	str	r3, [r7, #20]
            SYSREG->MSSDDR_FACC1_CR = temp;
2000234a:	f248 0300 	movw	r3, #32768	; 0x8000
2000234e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002352:	697a      	ldr	r2, [r7, #20]
20002354:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
20002358:	693b      	ldr	r3, [r7, #16]
2000235a:	f103 0301 	add.w	r3, r3, #1
2000235e:	613b      	str	r3, [r7, #16]
20002360:	7afb      	ldrb	r3, [r7, #11]
20002362:	461a      	mov	r2, r3
20002364:	693b      	ldr	r3, [r7, #16]
20002366:	429a      	cmp	r2, r3
20002368:	d8da      	bhi.n	20002320 <clk_switching_fix+0x16c>
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
2000236a:	687b      	ldr	r3, [r7, #4]
2000236c:	ea4f 2353 	mov.w	r3, r3, lsr #9
20002370:	f003 0207 	and.w	r2, r3, #7
20002374:	f245 237c 	movw	r3, #21116	; 0x527c
20002378:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000237c:	609a      	str	r2, [r3, #8]
        sequence = determine_seq(divisor[2], &len);
2000237e:	f245 237c 	movw	r3, #21116	; 0x527c
20002382:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002386:	689b      	ldr	r3, [r3, #8]
20002388:	b2da      	uxtb	r2, r3
2000238a:	f107 030b 	add.w	r3, r7, #11
2000238e:	4610      	mov	r0, r2
20002390:	4619      	mov	r1, r3
20002392:	f7ff feab 	bl	200020ec <determine_seq>
20002396:	4603      	mov	r3, r0
20002398:	60fb      	str	r3, [r7, #12]
        
        for(var = 1; var < len; var++)
2000239a:	f04f 0301 	mov.w	r3, #1
2000239e:	613b      	str	r3, [r7, #16]
200023a0:	e01f      	b.n	200023e2 <clk_switching_fix+0x22e>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
200023a2:	f248 0300 	movw	r3, #32768	; 0x8000
200023a6:	f2c4 0303 	movt	r3, #16387	; 0x4003
200023aa:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200023ae:	617b      	str	r3, [r7, #20]
            temp &= 0xFFFFF1FFu;
200023b0:	697b      	ldr	r3, [r7, #20]
200023b2:	f423 6360 	bic.w	r3, r3, #3584	; 0xe00
200023b6:	617b      	str	r3, [r7, #20]
            temp |= ((uint32_t)(sequence[var]) << 9);
200023b8:	68fa      	ldr	r2, [r7, #12]
200023ba:	693b      	ldr	r3, [r7, #16]
200023bc:	4413      	add	r3, r2
200023be:	781b      	ldrb	r3, [r3, #0]
200023c0:	ea4f 2343 	mov.w	r3, r3, lsl #9
200023c4:	697a      	ldr	r2, [r7, #20]
200023c6:	ea42 0303 	orr.w	r3, r2, r3
200023ca:	617b      	str	r3, [r7, #20]
            SYSREG->MSSDDR_FACC1_CR = temp;
200023cc:	f248 0300 	movw	r3, #32768	; 0x8000
200023d0:	f2c4 0303 	movt	r3, #16387	; 0x4003
200023d4:	697a      	ldr	r2, [r7, #20]
200023d6:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
200023da:	693b      	ldr	r3, [r7, #16]
200023dc:	f103 0301 	add.w	r3, r3, #1
200023e0:	613b      	str	r3, [r7, #16]
200023e2:	7afb      	ldrb	r3, [r7, #11]
200023e4:	461a      	mov	r2, r3
200023e6:	693b      	ldr	r3, [r7, #16]
200023e8:	429a      	cmp	r2, r3
200023ea:	d8da      	bhi.n	200023a2 <clk_switching_fix+0x1ee>
            temp |= ((uint32_t)(sequence[var]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
200023ec:	687b      	ldr	r3, [r7, #4]
200023ee:	ea4f 43d3 	mov.w	r3, r3, lsr #19
200023f2:	f003 0207 	and.w	r2, r3, #7
200023f6:	f245 237c 	movw	r3, #21116	; 0x527c
200023fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200023fe:	60da      	str	r2, [r3, #12]
        sequence = determine_seq(divisor[3], &len);
20002400:	f245 237c 	movw	r3, #21116	; 0x527c
20002404:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002408:	68db      	ldr	r3, [r3, #12]
2000240a:	b2da      	uxtb	r2, r3
2000240c:	f107 030b 	add.w	r3, r7, #11
20002410:	4610      	mov	r0, r2
20002412:	4619      	mov	r1, r3
20002414:	f7ff fe6a 	bl	200020ec <determine_seq>
20002418:	4603      	mov	r3, r0
2000241a:	60fb      	str	r3, [r7, #12]
        for(var = 1; var < len; var++)
2000241c:	f04f 0301 	mov.w	r3, #1
20002420:	613b      	str	r3, [r7, #16]
20002422:	e01f      	b.n	20002464 <clk_switching_fix+0x2b0>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20002424:	f248 0300 	movw	r3, #32768	; 0x8000
20002428:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000242c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20002430:	617b      	str	r3, [r7, #20]
            temp &= 0xFFC7FFFFu;
20002432:	697b      	ldr	r3, [r7, #20]
20002434:	f423 1360 	bic.w	r3, r3, #3670016	; 0x380000
20002438:	617b      	str	r3, [r7, #20]
            temp |= ((uint32_t)(sequence[var]) << 19);
2000243a:	68fa      	ldr	r2, [r7, #12]
2000243c:	693b      	ldr	r3, [r7, #16]
2000243e:	4413      	add	r3, r2
20002440:	781b      	ldrb	r3, [r3, #0]
20002442:	ea4f 43c3 	mov.w	r3, r3, lsl #19
20002446:	697a      	ldr	r2, [r7, #20]
20002448:	ea42 0303 	orr.w	r3, r2, r3
2000244c:	617b      	str	r3, [r7, #20]
            SYSREG->MSSDDR_FACC1_CR = temp;
2000244e:	f248 0300 	movw	r3, #32768	; 0x8000
20002452:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002456:	697a      	ldr	r2, [r7, #20]
20002458:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
2000245c:	693b      	ldr	r3, [r7, #16]
2000245e:	f103 0301 	add.w	r3, r3, #1
20002462:	613b      	str	r3, [r7, #16]
20002464:	7afb      	ldrb	r3, [r7, #11]
20002466:	461a      	mov	r2, r3
20002468:	693b      	ldr	r3, [r7, #16]
2000246a:	429a      	cmp	r2, r3
2000246c:	d8da      	bhi.n	20002424 <clk_switching_fix+0x270>

        /* Set the value of FACC_GLMUX_SEL bitfield of FACC1 register to 1 so 
         * that M3_CLK, PCLK0, PCLK1, CLK_FIC64 all driven from CLK_STANDBY
         * clock.
         */
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR | 0x00001000u;
2000246e:	f248 0300 	movw	r3, #32768	; 0x8000
20002472:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002476:	f248 0200 	movw	r2, #32768	; 0x8000
2000247a:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000247e:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20002482:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
20002486:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        
        status = CLOCK_SWITCHING_SUCCESS;
2000248a:	f04f 0300 	mov.w	r3, #0
2000248e:	77fb      	strb	r3, [r7, #31]
20002490:	e059      	b.n	20002546 <clk_switching_fix+0x392>
    }
    /* For 060 devices */
    else if(0xF808u == device_version)
20002492:	69ba      	ldr	r2, [r7, #24]
20002494:	f64f 0308 	movw	r3, #63496	; 0xf808
20002498:	429a      	cmp	r2, r3
2000249a:	d154      	bne.n	20002546 <clk_switching_fix+0x392>
    {
        /* The divisor setting should be such that all the divisor should be 
         * equal to each other and set to divide by 1,2,4,8, and 16 (but not 32)
         */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
2000249c:	687b      	ldr	r3, [r7, #4]
2000249e:	ea4f 0393 	mov.w	r3, r3, lsr #2
200024a2:	f003 0207 	and.w	r2, r3, #7
200024a6:	f245 237c 	movw	r3, #21116	; 0x527c
200024aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024ae:	601a      	str	r2, [r3, #0]
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
200024b0:	687b      	ldr	r3, [r7, #4]
200024b2:	ea4f 1353 	mov.w	r3, r3, lsr #5
200024b6:	f003 0207 	and.w	r2, r3, #7
200024ba:	f245 237c 	movw	r3, #21116	; 0x527c
200024be:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024c2:	605a      	str	r2, [r3, #4]
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
200024c4:	687b      	ldr	r3, [r7, #4]
200024c6:	ea4f 2353 	mov.w	r3, r3, lsr #9
200024ca:	f003 0207 	and.w	r2, r3, #7
200024ce:	f245 237c 	movw	r3, #21116	; 0x527c
200024d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024d6:	609a      	str	r2, [r3, #8]
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
200024d8:	687b      	ldr	r3, [r7, #4]
200024da:	ea4f 43d3 	mov.w	r3, r3, lsr #19
200024de:	f003 0207 	and.w	r2, r3, #7
200024e2:	f245 237c 	movw	r3, #21116	; 0x527c
200024e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024ea:	60da      	str	r2, [r3, #12]
       
        for(var = 1; var < 4; var++)
200024ec:	f04f 0301 	mov.w	r3, #1
200024f0:	613b      	str	r3, [r7, #16]
200024f2:	e025      	b.n	20002540 <clk_switching_fix+0x38c>
        {
            if((divisor[var] != divisor[0]) || \
200024f4:	693a      	ldr	r2, [r7, #16]
200024f6:	f245 237c 	movw	r3, #21116	; 0x527c
200024fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024fe:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
20002502:	f245 237c 	movw	r3, #21116	; 0x527c
20002506:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000250a:	681b      	ldr	r3, [r3, #0]
2000250c:	429a      	cmp	r2, r3
2000250e:	d10f      	bne.n	20002530 <clk_switching_fix+0x37c>
               (divisor[0] > 5) || (divisor[var] > 5))
20002510:	f245 237c 	movw	r3, #21116	; 0x527c
20002514:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002518:	681b      	ldr	r3, [r3, #0]
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
2000251a:	2b05      	cmp	r3, #5
2000251c:	d808      	bhi.n	20002530 <clk_switching_fix+0x37c>
               (divisor[0] > 5) || (divisor[var] > 5))
2000251e:	693a      	ldr	r2, [r7, #16]
20002520:	f245 237c 	movw	r3, #21116	; 0x527c
20002524:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002528:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
2000252c:	2b05      	cmp	r3, #5
2000252e:	d903      	bls.n	20002538 <clk_switching_fix+0x384>
               (divisor[0] > 5) || (divisor[var] > 5))
            {
                /* If the divisor value does meet the criteria, log the clock 
                 * switching error.
                 */
                status = CLOCK_SWITCHING_ERROR;
20002530:	f04f 0301 	mov.w	r3, #1
20002534:	77fb      	strb	r3, [r7, #31]
                break;
20002536:	e006      	b.n	20002546 <clk_switching_fix+0x392>
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
20002538:	693b      	ldr	r3, [r7, #16]
2000253a:	f103 0301 	add.w	r3, r3, #1
2000253e:	613b      	str	r3, [r7, #16]
20002540:	693b      	ldr	r3, [r7, #16]
20002542:	2b03      	cmp	r3, #3
20002544:	d9d6      	bls.n	200024f4 <clk_switching_fix+0x340>
    else
    {
         /* Do Nothing. */
    }
    
    return status;
20002546:	7ffb      	ldrb	r3, [r7, #31]
}
20002548:	4618      	mov	r0, r3
2000254a:	f107 0720 	add.w	r7, r7, #32
2000254e:	46bd      	mov	sp, r7
20002550:	bd80      	pop	{r7, pc}
20002552:	bf00      	nop

20002554 <revert_clk_config>:
/* SAR 80563 - Workaround for Glitchless Clock Multiplexer Switching Issue
 * Revert back original values of various divisor in FACC1 register after 
 * completing the fabric digest check/IAP/Flash Freeze service. 
 */
static void revert_clk_config(void)
{
20002554:	b580      	push	{r7, lr}
20002556:	b086      	sub	sp, #24
20002558:	af00      	add	r7, sp, #0
    uint8_t* sequence;
    uint8_t len;
    uint8_t var = 0;
2000255a:	f04f 0300 	mov.w	r3, #0
2000255e:	73fb      	strb	r3, [r7, #15]
    uint32_t temp = 0;
20002560:	f04f 0300 	mov.w	r3, #0
20002564:	613b      	str	r3, [r7, #16]
    uint32_t device_version;

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
20002566:	f248 0300 	movw	r3, #32768	; 0x8000
2000256a:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000256e:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
20002572:	ea4f 4303 	mov.w	r3, r3, lsl #16
20002576:	ea4f 4313 	mov.w	r3, r3, lsr #16
2000257a:	617b      	str	r3, [r7, #20]

    /* Revert back values for 10/25/50/90/150 devices */
    if((0xF802u == device_version) || (0xF803u == device_version) || \
2000257c:	697a      	ldr	r2, [r7, #20]
2000257e:	f64f 0302 	movw	r3, #63490	; 0xf802
20002582:	429a      	cmp	r2, r3
20002584:	d013      	beq.n	200025ae <revert_clk_config+0x5a>
20002586:	697a      	ldr	r2, [r7, #20]
20002588:	f64f 0303 	movw	r3, #63491	; 0xf803
2000258c:	429a      	cmp	r2, r3
2000258e:	d00e      	beq.n	200025ae <revert_clk_config+0x5a>
20002590:	697a      	ldr	r2, [r7, #20]
20002592:	f64f 0304 	movw	r3, #63492	; 0xf804
20002596:	429a      	cmp	r2, r3
20002598:	d009      	beq.n	200025ae <revert_clk_config+0x5a>
2000259a:	697a      	ldr	r2, [r7, #20]
2000259c:	f64f 0307 	movw	r3, #63495	; 0xf807
200025a0:	429a      	cmp	r2, r3
200025a2:	d004      	beq.n	200025ae <revert_clk_config+0x5a>
200025a4:	697a      	ldr	r2, [r7, #20]
200025a6:	f64f 0306 	movw	r3, #63494	; 0xf806
200025aa:	429a      	cmp	r2, r3
200025ac:	d10b      	bne.n	200025c6 <revert_clk_config+0x72>
       (0xF804u == device_version)||(0xF807u == device_version) ||   \
       (0xF806u == device_version))
    {
        /* Restore the MSS clock dividers to their normal operations value. */
        SYSREG->MSSDDR_FACC1_CR = g_initial_mssddr_facc1_cr;
200025ae:	f248 0300 	movw	r3, #32768	; 0x8000
200025b2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200025b6:	f245 2278 	movw	r2, #21112	; 0x5278
200025ba:	f2c2 0200 	movt	r2, #8192	; 0x2000
200025be:	6812      	ldr	r2, [r2, #0]
200025c0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    uint32_t device_version;

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);

    /* Revert back values for 10/25/50/90/150 devices */
    if((0xF802u == device_version) || (0xF803u == device_version) || \
200025c4:	e0eb      	b.n	2000279e <revert_clk_config+0x24a>
        /* Restore the MSS clock dividers to their normal operations value. */
        SYSREG->MSSDDR_FACC1_CR = g_initial_mssddr_facc1_cr;
    }

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
200025c6:	697a      	ldr	r2, [r7, #20]
200025c8:	f64f 0305 	movw	r3, #63493	; 0xf805
200025cc:	429a      	cmp	r2, r3
200025ce:	f040 80e6 	bne.w	2000279e <revert_clk_config+0x24a>
    {
        sequence = determine_seq(divisor[0], &len);
200025d2:	f245 237c 	movw	r3, #21116	; 0x527c
200025d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200025da:	681b      	ldr	r3, [r3, #0]
200025dc:	b2da      	uxtb	r2, r3
200025de:	f107 0307 	add.w	r3, r7, #7
200025e2:	4610      	mov	r0, r2
200025e4:	4619      	mov	r1, r3
200025e6:	f7ff fd81 	bl	200020ec <determine_seq>
200025ea:	4603      	mov	r3, r0
200025ec:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
200025ee:	79fb      	ldrb	r3, [r7, #7]
200025f0:	73fb      	strb	r3, [r7, #15]
200025f2:	e021      	b.n	20002638 <revert_clk_config+0xe4>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
200025f4:	f248 0300 	movw	r3, #32768	; 0x8000
200025f8:	f2c4 0303 	movt	r3, #16387	; 0x4003
200025fc:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20002600:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFFFE3u;
20002602:	693b      	ldr	r3, [r7, #16]
20002604:	f023 031c 	bic.w	r3, r3, #28
20002608:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
2000260a:	7bfb      	ldrb	r3, [r7, #15]
2000260c:	f103 32ff 	add.w	r2, r3, #4294967295
20002610:	68bb      	ldr	r3, [r7, #8]
20002612:	4413      	add	r3, r2
20002614:	781b      	ldrb	r3, [r3, #0]
20002616:	ea4f 0383 	mov.w	r3, r3, lsl #2
2000261a:	693a      	ldr	r2, [r7, #16]
2000261c:	ea42 0303 	orr.w	r3, r2, r3
20002620:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
20002622:	f248 0300 	movw	r3, #32768	; 0x8000
20002626:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000262a:	693a      	ldr	r2, [r7, #16]
2000262c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
20002630:	7bfb      	ldrb	r3, [r7, #15]
20002632:	f103 33ff 	add.w	r3, r3, #4294967295
20002636:	73fb      	strb	r3, [r7, #15]
20002638:	7bfb      	ldrb	r3, [r7, #15]
2000263a:	2b00      	cmp	r3, #0
2000263c:	d1da      	bne.n	200025f4 <revert_clk_config+0xa0>
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
2000263e:	f245 237c 	movw	r3, #21116	; 0x527c
20002642:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002646:	685b      	ldr	r3, [r3, #4]
20002648:	b2da      	uxtb	r2, r3
2000264a:	f107 0307 	add.w	r3, r7, #7
2000264e:	4610      	mov	r0, r2
20002650:	4619      	mov	r1, r3
20002652:	f7ff fd4b 	bl	200020ec <determine_seq>
20002656:	4603      	mov	r3, r0
20002658:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
2000265a:	79fb      	ldrb	r3, [r7, #7]
2000265c:	73fb      	strb	r3, [r7, #15]
2000265e:	e021      	b.n	200026a4 <revert_clk_config+0x150>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20002660:	f248 0300 	movw	r3, #32768	; 0x8000
20002664:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002668:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2000266c:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFFF1Fu;
2000266e:	693b      	ldr	r3, [r7, #16]
20002670:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
20002674:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
20002676:	7bfb      	ldrb	r3, [r7, #15]
20002678:	f103 32ff 	add.w	r2, r3, #4294967295
2000267c:	68bb      	ldr	r3, [r7, #8]
2000267e:	4413      	add	r3, r2
20002680:	781b      	ldrb	r3, [r3, #0]
20002682:	ea4f 1343 	mov.w	r3, r3, lsl #5
20002686:	693a      	ldr	r2, [r7, #16]
20002688:	ea42 0303 	orr.w	r3, r2, r3
2000268c:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
2000268e:	f248 0300 	movw	r3, #32768	; 0x8000
20002692:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002696:	693a      	ldr	r2, [r7, #16]
20002698:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
2000269c:	7bfb      	ldrb	r3, [r7, #15]
2000269e:	f103 33ff 	add.w	r3, r3, #4294967295
200026a2:	73fb      	strb	r3, [r7, #15]
200026a4:	7bfb      	ldrb	r3, [r7, #15]
200026a6:	2b00      	cmp	r3, #0
200026a8:	d1da      	bne.n	20002660 <revert_clk_config+0x10c>
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
200026aa:	f245 237c 	movw	r3, #21116	; 0x527c
200026ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200026b2:	689b      	ldr	r3, [r3, #8]
200026b4:	b2da      	uxtb	r2, r3
200026b6:	f107 0307 	add.w	r3, r7, #7
200026ba:	4610      	mov	r0, r2
200026bc:	4619      	mov	r1, r3
200026be:	f7ff fd15 	bl	200020ec <determine_seq>
200026c2:	4603      	mov	r3, r0
200026c4:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
200026c6:	79fb      	ldrb	r3, [r7, #7]
200026c8:	73fb      	strb	r3, [r7, #15]
200026ca:	e021      	b.n	20002710 <revert_clk_config+0x1bc>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
200026cc:	f248 0300 	movw	r3, #32768	; 0x8000
200026d0:	f2c4 0303 	movt	r3, #16387	; 0x4003
200026d4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200026d8:	613b      	str	r3, [r7, #16]
            temp &= 0xFFFFF1FFu;
200026da:	693b      	ldr	r3, [r7, #16]
200026dc:	f423 6360 	bic.w	r3, r3, #3584	; 0xe00
200026e0:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
200026e2:	7bfb      	ldrb	r3, [r7, #15]
200026e4:	f103 32ff 	add.w	r2, r3, #4294967295
200026e8:	68bb      	ldr	r3, [r7, #8]
200026ea:	4413      	add	r3, r2
200026ec:	781b      	ldrb	r3, [r3, #0]
200026ee:	ea4f 2343 	mov.w	r3, r3, lsl #9
200026f2:	693a      	ldr	r2, [r7, #16]
200026f4:	ea42 0303 	orr.w	r3, r2, r3
200026f8:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
200026fa:	f248 0300 	movw	r3, #32768	; 0x8000
200026fe:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002702:	693a      	ldr	r2, [r7, #16]
20002704:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
20002708:	7bfb      	ldrb	r3, [r7, #15]
2000270a:	f103 33ff 	add.w	r3, r3, #4294967295
2000270e:	73fb      	strb	r3, [r7, #15]
20002710:	7bfb      	ldrb	r3, [r7, #15]
20002712:	2b00      	cmp	r3, #0
20002714:	d1da      	bne.n	200026cc <revert_clk_config+0x178>
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
20002716:	f245 237c 	movw	r3, #21116	; 0x527c
2000271a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000271e:	68db      	ldr	r3, [r3, #12]
20002720:	b2da      	uxtb	r2, r3
20002722:	f107 0307 	add.w	r3, r7, #7
20002726:	4610      	mov	r0, r2
20002728:	4619      	mov	r1, r3
2000272a:	f7ff fcdf 	bl	200020ec <determine_seq>
2000272e:	4603      	mov	r3, r0
20002730:	60bb      	str	r3, [r7, #8]
        for(var = len; var > 0; var--)
20002732:	79fb      	ldrb	r3, [r7, #7]
20002734:	73fb      	strb	r3, [r7, #15]
20002736:	e021      	b.n	2000277c <revert_clk_config+0x228>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
20002738:	f248 0300 	movw	r3, #32768	; 0x8000
2000273c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002740:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20002744:	613b      	str	r3, [r7, #16]
            temp &= 0xFFC7FFFFu;
20002746:	693b      	ldr	r3, [r7, #16]
20002748:	f423 1360 	bic.w	r3, r3, #3670016	; 0x380000
2000274c:	613b      	str	r3, [r7, #16]
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
2000274e:	7bfb      	ldrb	r3, [r7, #15]
20002750:	f103 32ff 	add.w	r2, r3, #4294967295
20002754:	68bb      	ldr	r3, [r7, #8]
20002756:	4413      	add	r3, r2
20002758:	781b      	ldrb	r3, [r3, #0]
2000275a:	ea4f 43c3 	mov.w	r3, r3, lsl #19
2000275e:	693a      	ldr	r2, [r7, #16]
20002760:	ea42 0303 	orr.w	r3, r2, r3
20002764:	613b      	str	r3, [r7, #16]
            SYSREG->MSSDDR_FACC1_CR = temp;
20002766:	f248 0300 	movw	r3, #32768	; 0x8000
2000276a:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000276e:	693a      	ldr	r2, [r7, #16]
20002770:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
20002774:	7bfb      	ldrb	r3, [r7, #15]
20002776:	f103 33ff 	add.w	r3, r3, #4294967295
2000277a:	73fb      	strb	r3, [r7, #15]
2000277c:	7bfb      	ldrb	r3, [r7, #15]
2000277e:	2b00      	cmp	r3, #0
20002780:	d1da      	bne.n	20002738 <revert_clk_config+0x1e4>
        
        /* Set the value of FACC_GLMUX_SEL bitfield of FACC1 register to 0 so 
         * that M3_CLK, PCLK0, PCLK1, CLK_FIC64 all driven from stage 2 
         * dividers (from CLK_SRC).
         */
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & 0xFFFFEFFFu;
20002782:	f248 0300 	movw	r3, #32768	; 0x8000
20002786:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000278a:	f248 0200 	movw	r2, #32768	; 0x8000
2000278e:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002792:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20002796:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2000279a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    }
    else
    {
        /* Do Nothing. */
    }
}
2000279e:	f107 0718 	add.w	r7, r7, #24
200027a2:	46bd      	mov	sp, r7
200027a4:	bd80      	pop	{r7, pc}
200027a6:	bf00      	nop

200027a8 <isp_page_read_handler>:

static uint32_t isp_page_read_handler
(
    uint8_t const ** pp_next_page
)
{
200027a8:	b580      	push	{r7, lr}
200027aa:	b086      	sub	sp, #24
200027ac:	af00      	add	r7, sp, #0
200027ae:	6078      	str	r0, [r7, #4]
    uint32_t remaining_length = 0;
200027b0:	f04f 0300 	mov.w	r3, #0
200027b4:	613b      	str	r3, [r7, #16]
    uint32_t running_on_standby_clock;
    volatile uint32_t timeout;
    
    if((g_mode !=  MSS_SYS_PROG_AUTHENTICATE) & (wait_for_clock_switch == 1))
200027b6:	f245 239c 	movw	r3, #21148	; 0x529c
200027ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027be:	781b      	ldrb	r3, [r3, #0]
200027c0:	2b00      	cmp	r3, #0
200027c2:	bf0c      	ite	eq
200027c4:	2300      	moveq	r3, #0
200027c6:	2301      	movne	r3, #1
200027c8:	b2da      	uxtb	r2, r3
200027ca:	f245 1328 	movw	r3, #20776	; 0x5128
200027ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
200027d2:	781b      	ldrb	r3, [r3, #0]
200027d4:	2b01      	cmp	r3, #1
200027d6:	bf14      	ite	ne
200027d8:	2300      	movne	r3, #0
200027da:	2301      	moveq	r3, #1
200027dc:	b2db      	uxtb	r3, r3
200027de:	ea02 0303 	and.w	r3, r2, r3
200027e2:	b2db      	uxtb	r3, r3
200027e4:	2b00      	cmp	r3, #0
200027e6:	d01c      	beq.n	20002822 <isp_page_read_handler+0x7a>
    {
        timeout = DELAY_MORE_THAN_10US;
200027e8:	f241 3388 	movw	r3, #5000	; 0x1388
200027ec:	60fb      	str	r3, [r7, #12]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
200027ee:	f248 0300 	movw	r3, #32768	; 0x8000
200027f2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200027f6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200027fa:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
200027fe:	617b      	str	r3, [r7, #20]
            --timeout;
20002800:	68fb      	ldr	r3, [r7, #12]
20002802:	f103 33ff 	add.w	r3, r3, #4294967295
20002806:	60fb      	str	r3, [r7, #12]
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
20002808:	697b      	ldr	r3, [r7, #20]
2000280a:	2b00      	cmp	r3, #0
2000280c:	d102      	bne.n	20002814 <isp_page_read_handler+0x6c>
2000280e:	68fb      	ldr	r3, [r7, #12]
20002810:	2b00      	cmp	r3, #0
20002812:	d1ec      	bne.n	200027ee <isp_page_read_handler+0x46>
        wait_for_clock_switch = 0;
20002814:	f245 1328 	movw	r3, #20776	; 0x5128
20002818:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000281c:	f04f 0200 	mov.w	r2, #0
20002820:	701a      	strb	r2, [r3, #0]
    }
    
    if(g_isp_page_read_handler != 0)
20002822:	f245 2394 	movw	r3, #21140	; 0x5294
20002826:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000282a:	681b      	ldr	r3, [r3, #0]
2000282c:	2b00      	cmp	r3, #0
2000282e:	d008      	beq.n	20002842 <isp_page_read_handler+0x9a>
    {
        remaining_length = g_isp_page_read_handler(pp_next_page);
20002830:	f245 2394 	movw	r3, #21140	; 0x5294
20002834:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002838:	681b      	ldr	r3, [r3, #0]
2000283a:	6878      	ldr	r0, [r7, #4]
2000283c:	4798      	blx	r3
2000283e:	4603      	mov	r3, r0
20002840:	613b      	str	r3, [r7, #16]
    }
    
    return remaining_length;
20002842:	693b      	ldr	r3, [r7, #16]
}
20002844:	4618      	mov	r0, r3
20002846:	f107 0718 	add.w	r7, r7, #24
2000284a:	46bd      	mov	sp, r7
2000284c:	bd80      	pop	{r7, pc}
2000284e:	bf00      	nop

20002850 <isp_sys_completion_handler>:
static void isp_sys_completion_handler
(
    uint8_t * p_response, 
    uint16_t length
)
{    
20002850:	b580      	push	{r7, lr}
20002852:	b082      	sub	sp, #8
20002854:	af00      	add	r7, sp, #0
20002856:	6078      	str	r0, [r7, #4]
20002858:	460b      	mov	r3, r1
2000285a:	807b      	strh	r3, [r7, #2]
    if(g_mode != MSS_SYS_PROG_AUTHENTICATE)
2000285c:	f245 239c 	movw	r3, #21148	; 0x529c
20002860:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002864:	781b      	ldrb	r3, [r3, #0]
20002866:	2b00      	cmp	r3, #0
20002868:	d014      	beq.n	20002894 <isp_sys_completion_handler+0x44>
    {
        /*
         * Restore the eNVM's frequency range to the values used before ISP was
         * started.
         */
        SYSREG->ENVM_CR = g_initial_envm_cr;
2000286a:	f248 0300 	movw	r3, #32768	; 0x8000
2000286e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002872:	f245 1224 	movw	r2, #20772	; 0x5124
20002876:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000287a:	6812      	ldr	r2, [r2, #0]
2000287c:	60da      	str	r2, [r3, #12]
      
        /*
         * Restore the MSS DDR FACC 2 configuration to the values used before ISP 
         * was started.
         */
        SYSREG->MSSDDR_FACC2_CR = g_initial_mssddr_facc2_cr;
2000287e:	f248 0300 	movw	r3, #32768	; 0x8000
20002882:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002886:	f245 2298 	movw	r2, #21144	; 0x5298
2000288a:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000288e:	6812      	ldr	r2, [r2, #0]
20002890:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    }
    
    if(g_isp_completion_handler != 0)
20002894:	f245 2390 	movw	r3, #21136	; 0x5290
20002898:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000289c:	681b      	ldr	r3, [r3, #0]
2000289e:	2b00      	cmp	r3, #0
200028a0:	d00a      	beq.n	200028b8 <isp_sys_completion_handler+0x68>
    {
        g_isp_completion_handler(p_response[1]);
200028a2:	f245 2390 	movw	r3, #21136	; 0x5290
200028a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200028aa:	681b      	ldr	r3, [r3, #0]
200028ac:	687a      	ldr	r2, [r7, #4]
200028ae:	f102 0201 	add.w	r2, r2, #1
200028b2:	7812      	ldrb	r2, [r2, #0]
200028b4:	4610      	mov	r0, r2
200028b6:	4798      	blx	r3
    }
}
200028b8:	f107 0708 	add.w	r7, r7, #8
200028bc:	46bd      	mov	sp, r7
200028be:	bd80      	pop	{r7, pc}

200028c0 <MSS_SYS_start_isp>:
(
    uint8_t mode,
    comblk_page_handler_t page_read_handler,
    sys_serv_isp_complete_handler_t isp_completion_handler
)
{
200028c0:	b580      	push	{r7, lr}
200028c2:	b088      	sub	sp, #32
200028c4:	af02      	add	r7, sp, #8
200028c6:	4603      	mov	r3, r0
200028c8:	60b9      	str	r1, [r7, #8]
200028ca:	607a      	str	r2, [r7, #4]
200028cc:	73fb      	strb	r3, [r7, #15]
    uint8_t isp_prog_request[2];
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
200028ce:	f04f 0300 	mov.w	r3, #0
200028d2:	75bb      	strb	r3, [r7, #22]
    uint8_t status = MSS_SYS_SUCCESS;
200028d4:	f04f 0300 	mov.w	r3, #0
200028d8:	75fb      	strb	r3, [r7, #23]
    
    if(mode == MSS_SYS_PROG_VERIFY)
200028da:	7bfb      	ldrb	r3, [r7, #15]
200028dc:	2b02      	cmp	r3, #2
200028de:	d103      	bne.n	200028e8 <MSS_SYS_start_isp+0x28>
    {
        /*
         * Check fabric digest before performing ISP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
200028e0:	f04f 0001 	mov.w	r0, #1
200028e4:	f000 f962 	bl	20002bac <MSS_SYS_check_digest>
    }
    
    g_mode = mode;
200028e8:	f245 239c 	movw	r3, #21148	; 0x529c
200028ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
200028f0:	7bfa      	ldrb	r2, [r7, #15]
200028f2:	701a      	strb	r2, [r3, #0]
    
    if(mode != MSS_SYS_PROG_AUTHENTICATE)
200028f4:	7bfb      	ldrb	r3, [r7, #15]
200028f6:	2b00      	cmp	r3, #0
200028f8:	d055      	beq.n	200029a6 <MSS_SYS_start_isp+0xe6>
        /*
         * Keep a copy of the initial eNVM configuration used before ISP was
         * initiated. The eNVM configuration will be restored, as part of the ISP
         * completion handler, when ISP completes.
         */
        g_initial_envm_cr = SYSREG->ENVM_CR;
200028fa:	f248 0300 	movw	r3, #32768	; 0x8000
200028fe:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002902:	68da      	ldr	r2, [r3, #12]
20002904:	f245 1324 	movw	r3, #20772	; 0x5124
20002908:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000290c:	601a      	str	r2, [r3, #0]

        /* Store the MSS DDR FACC 2 register value so that its can be restored back 
         * when the ISP operation is completed in asynchronous_event_handler. */
        g_initial_mssddr_facc2_cr = SYSREG->MSSDDR_FACC2_CR;
2000290e:	f248 0300 	movw	r3, #32768	; 0x8000
20002912:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002916:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
2000291a:	f245 2398 	movw	r3, #21144	; 0x5298
2000291e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002922:	601a      	str	r2, [r3, #0]

        /*
         * Set the eNVM's frequency range to its maximum. This is required to ensure
         * successful eNVM programming on all devices.
         */
        SYSREG->ENVM_CR = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;        
20002924:	f248 0300 	movw	r3, #32768	; 0x8000
20002928:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000292c:	f245 1224 	movw	r2, #20772	; 0x5124
20002930:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002934:	6812      	ldr	r2, [r2, #0]
20002936:	f442 52ff 	orr.w	r2, r2, #8160	; 0x1fe0
2000293a:	60da      	str	r2, [r3, #12]
    
        /* Select output of MUX 0, MUX 1 and MUX 2 during standby */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR & ((uint32_t)(FACC_STANDBY_SEL << FACC_STANDBY_SHIFT) | ~FACC_STANDBY_SEL_MASK);
2000293c:	f248 0300 	movw	r3, #32768	; 0x8000
20002940:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002944:	f248 0200 	movw	r2, #32768	; 0x8000
20002948:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000294c:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
20002950:	f422 72e0 	bic.w	r2, r2, #448	; 0x1c0
20002954:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* Enable the signal for the 50 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_25_50MHZ_EN << MSS_25_50MHZ_EN_SHIFT) & MSS_25_50MHZ_EN_MASK);
20002958:	f248 0300 	movw	r3, #32768	; 0x8000
2000295c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002960:	f248 0200 	movw	r2, #32768	; 0x8000
20002964:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002968:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
2000296c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20002970:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* Enable the signal for the 1 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_1MHZ_EN << MSS_1MHZ_EN_SHIFT) & MSS_1MHZ_EN_MASK);
20002974:	f248 0300 	movw	r3, #32768	; 0x8000
20002978:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000297c:	f248 0200 	movw	r2, #32768	; 0x8000
20002980:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002984:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
20002988:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
2000298c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* SAR 80563
         * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
         * clk_fic64 to the divided by 32 versions based on device version.
         */
        clk_switch_status = clk_switching_fix();
20002990:	f7ff fc10 	bl	200021b4 <clk_switching_fix>
20002994:	4603      	mov	r3, r0
20002996:	75bb      	strb	r3, [r7, #22]
        
        wait_for_clock_switch = 1;
20002998:	f245 1328 	movw	r3, #20776	; 0x5128
2000299c:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029a0:	f04f 0201 	mov.w	r2, #1
200029a4:	701a      	strb	r2, [r3, #0]
    }
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
200029a6:	7dbb      	ldrb	r3, [r7, #22]
200029a8:	2b00      	cmp	r3, #0
200029aa:	d12a      	bne.n	20002a02 <MSS_SYS_start_isp+0x142>
    {
        signal_request_start();
200029ac:	f000 f99a 	bl	20002ce4 <signal_request_start>
        
        isp_prog_request[0] = ISP_PROGRAMMING_REQUEST_CMD;
200029b0:	f04f 0315 	mov.w	r3, #21
200029b4:	753b      	strb	r3, [r7, #20]
        isp_prog_request[1] = mode;
200029b6:	7bfb      	ldrb	r3, [r7, #15]
200029b8:	757b      	strb	r3, [r7, #21]
        
        g_isp_completion_handler = isp_completion_handler;
200029ba:	f245 2390 	movw	r3, #21136	; 0x5290
200029be:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029c2:	687a      	ldr	r2, [r7, #4]
200029c4:	601a      	str	r2, [r3, #0]
        
        g_isp_page_read_handler = page_read_handler;
200029c6:	f245 2394 	movw	r3, #21140	; 0x5294
200029ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029ce:	68ba      	ldr	r2, [r7, #8]
200029d0:	601a      	str	r2, [r3, #0]
        
        MSS_COMBLK_send_paged_cmd(isp_prog_request,                 /* p_cmd */
200029d2:	f107 0214 	add.w	r2, r7, #20
200029d6:	f242 73a9 	movw	r3, #10153	; 0x27a9
200029da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029de:	9300      	str	r3, [sp, #0]
200029e0:	f642 0351 	movw	r3, #10321	; 0x2851
200029e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200029e8:	9301      	str	r3, [sp, #4]
200029ea:	4610      	mov	r0, r2
200029ec:	f04f 0102 	mov.w	r1, #2
200029f0:	f245 228c 	movw	r2, #21132	; 0x528c
200029f4:	f2c2 0200 	movt	r2, #8192	; 0x2000
200029f8:	f04f 0302 	mov.w	r3, #2
200029fc:	f001 fb46 	bl	2000408c <MSS_COMBLK_send_paged_cmd>
20002a00:	e002      	b.n	20002a08 <MSS_SYS_start_isp+0x148>
        /* SAR 80563
         * On 060 device. The user should make sure that the all divisor i.e 
         * fclk, pclk0, pclk1 and clk_fic64 divisor must be equal to each other 
         * and set to to divide by 1,2, 4, 8, 16(but not 32). 
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
20002a02:	f06f 0336 	mvn.w	r3, #54	; 0x36
20002a06:	75fb      	strb	r3, [r7, #23]
    }
    
    return status;
20002a08:	7dfb      	ldrb	r3, [r7, #23]
}
20002a0a:	4618      	mov	r0, r3
20002a0c:	f107 0718 	add.w	r7, r7, #24
20002a10:	46bd      	mov	sp, r7
20002a12:	bd80      	pop	{r7, pc}

20002a14 <MSS_SYS_initiate_iap>:
uint8_t MSS_SYS_initiate_iap
(
    uint8_t mode,
    uint32_t bitstream_spi_addr
)
{
20002a14:	b580      	push	{r7, lr}
20002a16:	b08a      	sub	sp, #40	; 0x28
20002a18:	af04      	add	r7, sp, #16
20002a1a:	4603      	mov	r3, r0
20002a1c:	6039      	str	r1, [r7, #0]
20002a1e:	71fb      	strb	r3, [r7, #7]
    uint8_t status = MSS_SYS_SUCCESS;
20002a20:	f04f 0300 	mov.w	r3, #0
20002a24:	753b      	strb	r3, [r7, #20]
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
20002a26:	f04f 0300 	mov.w	r3, #0
20002a2a:	757b      	strb	r3, [r7, #21]
    uint16_t actual_response_length;
    uint8_t iap_prog_req[6];
    uint8_t response[IAP_PROG_SERV_RESP_LENGTH];
    
    if(mode == MSS_SYS_PROG_VERIFY)
20002a2c:	79fb      	ldrb	r3, [r7, #7]
20002a2e:	2b02      	cmp	r3, #2
20002a30:	d103      	bne.n	20002a3a <MSS_SYS_initiate_iap+0x26>
    {
        /*
         * Check fabric digest before performing IAP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
20002a32:	f04f 0001 	mov.w	r0, #1
20002a36:	f000 f8b9 	bl	20002bac <MSS_SYS_check_digest>
    }
    
    if(mode != MSS_SYS_PROG_AUTHENTICATE)
20002a3a:	79fb      	ldrb	r3, [r7, #7]
20002a3c:	2b00      	cmp	r3, #0
20002a3e:	d04e      	beq.n	20002ade <MSS_SYS_initiate_iap+0xca>
        /*
         * Keep a copy of the initial eNVM configuration used before IAP was
         * initiated. The eNVM configuration will be restored, as part of the IAP
         * completion handler, when IAP completes.
         */
        g_initial_envm_cr = SYSREG->ENVM_CR;
20002a40:	f248 0300 	movw	r3, #32768	; 0x8000
20002a44:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002a48:	68da      	ldr	r2, [r3, #12]
20002a4a:	f245 1324 	movw	r3, #20772	; 0x5124
20002a4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a52:	601a      	str	r2, [r3, #0]
     
        /* Store the MSS DDR FACC 2 register value so that its can be restored back 
         * when the IAP operation is completed.asynchronous_event_handler. */
        g_initial_mssddr_facc2_cr = SYSREG->MSSDDR_FACC2_CR;
20002a54:	f248 0300 	movw	r3, #32768	; 0x8000
20002a58:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002a5c:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
20002a60:	f245 2398 	movw	r3, #21144	; 0x5298
20002a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a68:	601a      	str	r2, [r3, #0]
        
        /*
         * Set the eNVM's frequency range to its maximum. This is required to ensure
         * successful eNVM programming on all devices.
         */
        SYSREG->ENVM_CR = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;                
20002a6a:	f248 0300 	movw	r3, #32768	; 0x8000
20002a6e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002a72:	f245 1224 	movw	r2, #20772	; 0x5124
20002a76:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002a7a:	6812      	ldr	r2, [r2, #0]
20002a7c:	f442 52ff 	orr.w	r2, r2, #8160	; 0x1fe0
20002a80:	60da      	str	r2, [r3, #12]

        /* Select output of MUX 0, MUX 1 and MUX 2 during standby */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR & ((uint32_t)(FACC_STANDBY_SEL << FACC_STANDBY_SHIFT) | ~FACC_STANDBY_SEL_MASK);
20002a82:	f248 0300 	movw	r3, #32768	; 0x8000
20002a86:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002a8a:	f248 0200 	movw	r2, #32768	; 0x8000
20002a8e:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002a92:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
20002a96:	f422 72e0 	bic.w	r2, r2, #448	; 0x1c0
20002a9a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* Enable the signal for the 50 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_25_50MHZ_EN << MSS_25_50MHZ_EN_SHIFT) & MSS_25_50MHZ_EN_MASK);
20002a9e:	f248 0300 	movw	r3, #32768	; 0x8000
20002aa2:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002aa6:	f248 0200 	movw	r2, #32768	; 0x8000
20002aaa:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002aae:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
20002ab2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20002ab6:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* Enable the signal for the 1 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_1MHZ_EN << MSS_1MHZ_EN_SHIFT) & MSS_1MHZ_EN_MASK);
20002aba:	f248 0300 	movw	r3, #32768	; 0x8000
20002abe:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002ac2:	f248 0200 	movw	r2, #32768	; 0x8000
20002ac6:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002aca:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
20002ace:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20002ad2:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* SAR 80563
         * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
         * clk_fic64 to the divided by 32 versions based on device version.
         */
        clk_switch_status = clk_switching_fix();
20002ad6:	f7ff fb6d 	bl	200021b4 <clk_switching_fix>
20002ada:	4603      	mov	r3, r0
20002adc:	757b      	strb	r3, [r7, #21]
    }
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
20002ade:	7d7b      	ldrb	r3, [r7, #21]
20002ae0:	2b00      	cmp	r3, #0
20002ae2:	d157      	bne.n	20002b94 <MSS_SYS_initiate_iap+0x180>
    {
        /*
         * There is no response for Program mode because the Cortex-M3 will
         * get reset on completion of the system service.
         */
        iap_prog_req[0] = IAP_PROGRAMMING_REQUEST_CMD;
20002ae4:	f04f 0314 	mov.w	r3, #20
20002ae8:	733b      	strb	r3, [r7, #12]
        iap_prog_req[1] = mode;
20002aea:	79fb      	ldrb	r3, [r7, #7]
20002aec:	737b      	strb	r3, [r7, #13]

        iap_prog_req[2] = (uint8_t)(bitstream_spi_addr);
20002aee:	683b      	ldr	r3, [r7, #0]
20002af0:	b2db      	uxtb	r3, r3
20002af2:	73bb      	strb	r3, [r7, #14]
        iap_prog_req[3] = (uint8_t)(bitstream_spi_addr >> 8u);
20002af4:	683b      	ldr	r3, [r7, #0]
20002af6:	ea4f 2313 	mov.w	r3, r3, lsr #8
20002afa:	b2db      	uxtb	r3, r3
20002afc:	73fb      	strb	r3, [r7, #15]
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
20002afe:	683b      	ldr	r3, [r7, #0]
20002b00:	ea4f 4313 	mov.w	r3, r3, lsr #16
20002b04:	b2db      	uxtb	r3, r3
20002b06:	743b      	strb	r3, [r7, #16]
        iap_prog_req[5] = (uint8_t)(bitstream_spi_addr >> 24u);
20002b08:	683b      	ldr	r3, [r7, #0]
20002b0a:	ea4f 6313 	mov.w	r3, r3, lsr #24
20002b0e:	b2db      	uxtb	r3, r3
20002b10:	747b      	strb	r3, [r7, #17]

        signal_request_start();
20002b12:	f000 f8e7 	bl	20002ce4 <signal_request_start>
        
        MSS_COMBLK_send_cmd(iap_prog_req,                   /* p_cmd */
20002b16:	f107 020c 	add.w	r2, r7, #12
20002b1a:	f107 0308 	add.w	r3, r7, #8
20002b1e:	9300      	str	r3, [sp, #0]
20002b20:	f04f 0302 	mov.w	r3, #2
20002b24:	9301      	str	r3, [sp, #4]
20002b26:	f642 43b5 	movw	r3, #11445	; 0x2cb5
20002b2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002b2e:	9302      	str	r3, [sp, #8]
20002b30:	4610      	mov	r0, r2
20002b32:	f04f 0106 	mov.w	r1, #6
20002b36:	f04f 0200 	mov.w	r2, #0
20002b3a:	f04f 0300 	mov.w	r3, #0
20002b3e:	f001 f9cf 	bl	20003ee0 <MSS_COMBLK_send_cmd>
                            request_completion_handler);    /* completion_handler */
            
        /*
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();
20002b42:	f000 f8eb 	bl	20002d1c <wait_for_request_completion>
20002b46:	4603      	mov	r3, r0
20002b48:	82fb      	strh	r3, [r7, #22]

        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
20002b4a:	8afb      	ldrh	r3, [r7, #22]
20002b4c:	2b02      	cmp	r3, #2
20002b4e:	d105      	bne.n	20002b5c <MSS_SYS_initiate_iap+0x148>
           (IAP_PROGRAMMING_REQUEST_CMD == response[0]))
20002b50:	7a3b      	ldrb	r3, [r7, #8]
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();

        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
20002b52:	2b14      	cmp	r3, #20
20002b54:	d102      	bne.n	20002b5c <MSS_SYS_initiate_iap+0x148>
           (IAP_PROGRAMMING_REQUEST_CMD == response[0]))
        {
            status = response[1];
20002b56:	7a7b      	ldrb	r3, [r7, #9]
20002b58:	753b      	strb	r3, [r7, #20]
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();

        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
20002b5a:	e002      	b.n	20002b62 <MSS_SYS_initiate_iap+0x14e>
        {
            status = response[1];
        }
        else
        {
            status = MSS_SYS_UNEXPECTED_ERROR;
20002b5c:	f06f 0337 	mvn.w	r3, #55	; 0x37
20002b60:	753b      	strb	r3, [r7, #20]
        }
        
        if(mode != MSS_SYS_PROG_AUTHENTICATE)
20002b62:	79fb      	ldrb	r3, [r7, #7]
20002b64:	2b00      	cmp	r3, #0
20002b66:	d019      	beq.n	20002b9c <MSS_SYS_initiate_iap+0x188>
        {
            /* Restore back to original value. */
            SYSREG->ENVM_CR = g_initial_envm_cr;
20002b68:	f248 0300 	movw	r3, #32768	; 0x8000
20002b6c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002b70:	f245 1224 	movw	r2, #20772	; 0x5124
20002b74:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002b78:	6812      	ldr	r2, [r2, #0]
20002b7a:	60da      	str	r2, [r3, #12]
            SYSREG->MSSDDR_FACC2_CR = g_initial_mssddr_facc2_cr;
20002b7c:	f248 0300 	movw	r3, #32768	; 0x8000
20002b80:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002b84:	f245 2298 	movw	r2, #21144	; 0x5298
20002b88:	f2c2 0200 	movt	r2, #8192	; 0x2000
20002b8c:	6812      	ldr	r2, [r2, #0]
20002b8e:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
20002b92:	e004      	b.n	20002b9e <MSS_SYS_initiate_iap+0x18a>
        /* SAR 80563
         * On 060 device. The user should make sure that the all divisor i.e 
         * fclk, pclk0, pclk1 and clk_fic64 divisor must be equal to each other 
         * and set to to divide by 1,2, 4, 8, 16(but not 32). 
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
20002b94:	f06f 0336 	mvn.w	r3, #54	; 0x36
20002b98:	753b      	strb	r3, [r7, #20]
20002b9a:	e000      	b.n	20002b9e <MSS_SYS_initiate_iap+0x18a>
        
        if(mode != MSS_SYS_PROG_AUTHENTICATE)
        {
            /* Restore back to original value. */
            SYSREG->ENVM_CR = g_initial_envm_cr;
            SYSREG->MSSDDR_FACC2_CR = g_initial_mssddr_facc2_cr;
20002b9c:	bf00      	nop
         * and set to to divide by 1,2, 4, 8, 16(but not 32). 
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
    }
    
    return status;
20002b9e:	7d3b      	ldrb	r3, [r7, #20]
}
20002ba0:	4618      	mov	r0, r3
20002ba2:	f107 0718 	add.w	r7, r7, #24
20002ba6:	46bd      	mov	sp, r7
20002ba8:	bd80      	pop	{r7, pc}
20002baa:	bf00      	nop

20002bac <MSS_SYS_check_digest>:
 */
uint8_t MSS_SYS_check_digest
(
    uint8_t options
)
{
20002bac:	b580      	push	{r7, lr}
20002bae:	b08a      	sub	sp, #40	; 0x28
20002bb0:	af04      	add	r7, sp, #16
20002bb2:	4603      	mov	r3, r0
20002bb4:	71fb      	strb	r3, [r7, #7]
    uint8_t status;
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
20002bb6:	f04f 0300 	mov.w	r3, #0
20002bba:	757b      	strb	r3, [r7, #21]
    uint8_t response[DIGEST_CHECK_SERV_RESP_LENGTH];
    
    /*
     * The Digest Check system service is not available on M2S050 rev A, rev B and rev C.
     */
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
20002bbc:	f248 0300 	movw	r3, #32768	; 0x8000
20002bc0:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002bc4:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
20002bc8:	f64f 0302 	movw	r3, #63490	; 0xf802
20002bcc:	429a      	cmp	r2, r3
20002bce:	d100      	bne.n	20002bd2 <MSS_SYS_check_digest+0x26>
20002bd0:	be00      	bkpt	0x0000
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
20002bd2:	f248 0300 	movw	r3, #32768	; 0x8000
20002bd6:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002bda:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
20002bde:	f64f 0302 	movw	r3, #63490	; 0xf802
20002be2:	f2c0 0301 	movt	r3, #1
20002be6:	429a      	cmp	r2, r3
20002be8:	d100      	bne.n	20002bec <MSS_SYS_check_digest+0x40>
20002bea:	be00      	bkpt	0x0000
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
20002bec:	f248 0300 	movw	r3, #32768	; 0x8000
20002bf0:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002bf4:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
20002bf8:	f64f 0302 	movw	r3, #63490	; 0xf802
20002bfc:	f2c0 0302 	movt	r3, #2
20002c00:	429a      	cmp	r2, r3
20002c02:	d100      	bne.n	20002c06 <MSS_SYS_check_digest+0x5a>
20002c04:	be00      	bkpt	0x0000
    
    /* 
     * Private ENVM factory digest and user digest is available only on G4X 
     * devices
     */
    if((options & 0x30u) != 0x00)
20002c06:	79fb      	ldrb	r3, [r7, #7]
20002c08:	f003 0330 	and.w	r3, r3, #48	; 0x30
20002c0c:	2b00      	cmp	r3, #0
20002c0e:	d00c      	beq.n	20002c2a <MSS_SYS_check_digest+0x7e>
    {
        ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
20002c10:	f248 0300 	movw	r3, #32768	; 0x8000
20002c14:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002c18:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
20002c1c:	f64f 0302 	movw	r3, #63490	; 0xf802
20002c20:	f2c0 0302 	movt	r3, #2
20002c24:	429a      	cmp	r2, r3
20002c26:	d100      	bne.n	20002c2a <MSS_SYS_check_digest+0x7e>
20002c28:	be00      	bkpt	0x0000
    
    /* SAR 80563
     * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
     * clk_fic64 to the divided by 32 versions based on device version.
     */
    if(MSS_SYS_DIGEST_CHECK_FABRIC == (options & 0x01u))
20002c2a:	79fb      	ldrb	r3, [r7, #7]
20002c2c:	f003 0301 	and.w	r3, r3, #1
20002c30:	b2db      	uxtb	r3, r3
20002c32:	2b00      	cmp	r3, #0
20002c34:	d003      	beq.n	20002c3e <MSS_SYS_check_digest+0x92>
    {
        clk_switch_status = clk_switching_fix();
20002c36:	f7ff fabd 	bl	200021b4 <clk_switching_fix>
20002c3a:	4603      	mov	r3, r0
20002c3c:	757b      	strb	r3, [r7, #21]
    }
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
20002c3e:	7d7b      	ldrb	r3, [r7, #21]
20002c40:	2b00      	cmp	r3, #0
20002c42:	d12e      	bne.n	20002ca2 <MSS_SYS_check_digest+0xf6>
    {
      
        signal_request_start();
20002c44:	f000 f84e 	bl	20002ce4 <signal_request_start>

        digest_check_req[0] = DIGEST_CHECK_REQUEST_CMD;
20002c48:	f04f 0317 	mov.w	r3, #23
20002c4c:	743b      	strb	r3, [r7, #16]
        digest_check_req[1] = options;
20002c4e:	79fb      	ldrb	r3, [r7, #7]
20002c50:	747b      	strb	r3, [r7, #17]

        MSS_COMBLK_send_cmd(digest_check_req,               /* p_cmd */
20002c52:	f107 0210 	add.w	r2, r7, #16
20002c56:	f107 030c 	add.w	r3, r7, #12
20002c5a:	9300      	str	r3, [sp, #0]
20002c5c:	f04f 0302 	mov.w	r3, #2
20002c60:	9301      	str	r3, [sp, #4]
20002c62:	f642 43b5 	movw	r3, #11445	; 0x2cb5
20002c66:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002c6a:	9302      	str	r3, [sp, #8]
20002c6c:	4610      	mov	r0, r2
20002c6e:	f04f 0102 	mov.w	r1, #2
20002c72:	f04f 0200 	mov.w	r2, #0
20002c76:	f04f 0300 	mov.w	r3, #0
20002c7a:	f001 f931 	bl	20003ee0 <MSS_COMBLK_send_cmd>
                            0u,                             /* data_size */
                            response,                       /* p_response */
                            DIGEST_CHECK_SERV_RESP_LENGTH,  /* response_size */
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();
20002c7e:	f000 f84d 	bl	20002d1c <wait_for_request_completion>
20002c82:	4603      	mov	r3, r0
20002c84:	82fb      	strh	r3, [r7, #22]

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
20002c86:	8afb      	ldrh	r3, [r7, #22]
20002c88:	2b02      	cmp	r3, #2
20002c8a:	d106      	bne.n	20002c9a <MSS_SYS_check_digest+0xee>
           (DIGEST_CHECK_REQUEST_CMD == response[0]))
20002c8c:	7b3b      	ldrb	r3, [r7, #12]
                            DIGEST_CHECK_SERV_RESP_LENGTH,  /* response_size */
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
20002c8e:	2b17      	cmp	r3, #23
20002c90:	d103      	bne.n	20002c9a <MSS_SYS_check_digest+0xee>
           (DIGEST_CHECK_REQUEST_CMD == response[0]))
        {
            status = response[1];
20002c92:	7b7b      	ldrb	r3, [r7, #13]
20002c94:	753b      	strb	r3, [r7, #20]
                            DIGEST_CHECK_SERV_RESP_LENGTH,  /* response_size */
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
20002c96:	bf00      	nop
20002c98:	e006      	b.n	20002ca8 <MSS_SYS_check_digest+0xfc>
        {
            status = response[1];
        }
        else
        {
            status = MSS_SYS_UNEXPECTED_ERROR;
20002c9a:	f06f 0337 	mvn.w	r3, #55	; 0x37
20002c9e:	753b      	strb	r3, [r7, #20]
20002ca0:	e002      	b.n	20002ca8 <MSS_SYS_check_digest+0xfc>
        /* SAR 80563
         * On 060 device. The user should make sure that the all divisor i.e 
         * fclk, pclk0, pclk1 and clk_fic64 divisor must be equal to each other 
         * and set to to divide by 1,2, 4, 8, 16(but not 32). 
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
20002ca2:	f06f 0336 	mvn.w	r3, #54	; 0x36
20002ca6:	753b      	strb	r3, [r7, #20]
    }
    
    return status;
20002ca8:	7d3b      	ldrb	r3, [r7, #20]
}
20002caa:	4618      	mov	r0, r3
20002cac:	f107 0718 	add.w	r7, r7, #24
20002cb0:	46bd      	mov	sp, r7
20002cb2:	bd80      	pop	{r7, pc}

20002cb4 <request_completion_handler>:
static void request_completion_handler
(
    uint8_t * p_response,
    uint16_t response_size
)
{
20002cb4:	b480      	push	{r7}
20002cb6:	b083      	sub	sp, #12
20002cb8:	af00      	add	r7, sp, #0
20002cba:	6078      	str	r0, [r7, #4]
20002cbc:	460b      	mov	r3, r1
20002cbe:	807b      	strh	r3, [r7, #2]
    g_request_in_progress = 0u;
20002cc0:	f245 236c 	movw	r3, #21100	; 0x526c
20002cc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002cc8:	f04f 0200 	mov.w	r2, #0
20002ccc:	701a      	strb	r2, [r3, #0]
    g_last_response_length = response_size;
20002cce:	f245 236e 	movw	r3, #21102	; 0x526e
20002cd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002cd6:	887a      	ldrh	r2, [r7, #2]
20002cd8:	801a      	strh	r2, [r3, #0]
}
20002cda:	f107 070c 	add.w	r7, r7, #12
20002cde:	46bd      	mov	sp, r7
20002ce0:	bc80      	pop	{r7}
20002ce2:	4770      	bx	lr

20002ce4 <signal_request_start>:

/*==============================================================================
 *
 */
static void signal_request_start(void)
{
20002ce4:	b480      	push	{r7}
20002ce6:	af00      	add	r7, sp, #0
    /* Wait for current request to complete. */
    while(g_request_in_progress)
20002ce8:	f245 236c 	movw	r3, #21100	; 0x526c
20002cec:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002cf0:	781b      	ldrb	r3, [r3, #0]
20002cf2:	b2db      	uxtb	r3, r3
20002cf4:	2b00      	cmp	r3, #0
20002cf6:	d1f7      	bne.n	20002ce8 <signal_request_start+0x4>
    {
        ;
    }
    
    g_request_in_progress = 1u;
20002cf8:	f245 236c 	movw	r3, #21100	; 0x526c
20002cfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d00:	f04f 0201 	mov.w	r2, #1
20002d04:	701a      	strb	r2, [r3, #0]
    g_last_response_length = 0u;
20002d06:	f245 236e 	movw	r3, #21102	; 0x526e
20002d0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d0e:	f04f 0200 	mov.w	r2, #0
20002d12:	801a      	strh	r2, [r3, #0]
}
20002d14:	46bd      	mov	sp, r7
20002d16:	bc80      	pop	{r7}
20002d18:	4770      	bx	lr
20002d1a:	bf00      	nop

20002d1c <wait_for_request_completion>:

/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
20002d1c:	b480      	push	{r7}
20002d1e:	af00      	add	r7, sp, #0
    while(g_request_in_progress)
20002d20:	f245 236c 	movw	r3, #21100	; 0x526c
20002d24:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d28:	781b      	ldrb	r3, [r3, #0]
20002d2a:	b2db      	uxtb	r3, r3
20002d2c:	2b00      	cmp	r3, #0
20002d2e:	d1f7      	bne.n	20002d20 <wait_for_request_completion+0x4>
    {
        ;
    }
    
    return g_last_response_length;
20002d30:	f245 236e 	movw	r3, #21102	; 0x526e
20002d34:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d38:	881b      	ldrh	r3, [r3, #0]
20002d3a:	b29b      	uxth	r3, r3
}
20002d3c:	4618      	mov	r0, r3
20002d3e:	46bd      	mov	sp, r7
20002d40:	bc80      	pop	{r7}
20002d42:	4770      	bx	lr

20002d44 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20002d44:	b480      	push	{r7}
20002d46:	b083      	sub	sp, #12
20002d48:	af00      	add	r7, sp, #0
20002d4a:	4603      	mov	r3, r0
20002d4c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20002d4e:	f24e 1300 	movw	r3, #57600	; 0xe100
20002d52:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002d56:	f997 2007 	ldrsb.w	r2, [r7, #7]
20002d5a:	ea4f 1252 	mov.w	r2, r2, lsr #5
20002d5e:	79f9      	ldrb	r1, [r7, #7]
20002d60:	f001 011f 	and.w	r1, r1, #31
20002d64:	f04f 0001 	mov.w	r0, #1
20002d68:	fa00 f101 	lsl.w	r1, r0, r1
20002d6c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002d70:	f107 070c 	add.w	r7, r7, #12
20002d74:	46bd      	mov	sp, r7
20002d76:	bc80      	pop	{r7}
20002d78:	4770      	bx	lr
20002d7a:	bf00      	nop

20002d7c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20002d7c:	b480      	push	{r7}
20002d7e:	b083      	sub	sp, #12
20002d80:	af00      	add	r7, sp, #0
20002d82:	4603      	mov	r3, r0
20002d84:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20002d86:	f24e 1300 	movw	r3, #57600	; 0xe100
20002d8a:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002d8e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20002d92:	ea4f 1252 	mov.w	r2, r2, lsr #5
20002d96:	79f9      	ldrb	r1, [r7, #7]
20002d98:	f001 011f 	and.w	r1, r1, #31
20002d9c:	f04f 0001 	mov.w	r0, #1
20002da0:	fa00 f101 	lsl.w	r1, r0, r1
20002da4:	f102 0220 	add.w	r2, r2, #32
20002da8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002dac:	f107 070c 	add.w	r7, r7, #12
20002db0:	46bd      	mov	sp, r7
20002db2:	bc80      	pop	{r7}
20002db4:	4770      	bx	lr
20002db6:	bf00      	nop

20002db8 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20002db8:	b480      	push	{r7}
20002dba:	b083      	sub	sp, #12
20002dbc:	af00      	add	r7, sp, #0
20002dbe:	4603      	mov	r3, r0
20002dc0:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20002dc2:	f24e 1300 	movw	r3, #57600	; 0xe100
20002dc6:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002dca:	f997 2007 	ldrsb.w	r2, [r7, #7]
20002dce:	ea4f 1252 	mov.w	r2, r2, lsr #5
20002dd2:	79f9      	ldrb	r1, [r7, #7]
20002dd4:	f001 011f 	and.w	r1, r1, #31
20002dd8:	f04f 0001 	mov.w	r0, #1
20002ddc:	fa00 f101 	lsl.w	r1, r0, r1
20002de0:	f102 0260 	add.w	r2, r2, #96	; 0x60
20002de4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002de8:	f107 070c 	add.w	r7, r7, #12
20002dec:	46bd      	mov	sp, r7
20002dee:	bc80      	pop	{r7}
20002df0:	4770      	bx	lr
20002df2:	bf00      	nop

20002df4 <MSS_SPI_init>:
 */
void MSS_SPI_init
(
    mss_spi_instance_t * this_spi
)
{
20002df4:	b580      	push	{r7, lr}
20002df6:	b084      	sub	sp, #16
20002df8:	af00      	add	r7, sp, #0
20002dfa:	6078      	str	r0, [r7, #4]
    uint16_t slave;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20002dfc:	687a      	ldr	r2, [r7, #4]
20002dfe:	f248 53f8 	movw	r3, #34296	; 0x85f8
20002e02:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e06:	429a      	cmp	r2, r3
20002e08:	d007      	beq.n	20002e1a <MSS_SPI_init+0x26>
20002e0a:	687a      	ldr	r2, [r7, #4]
20002e0c:	f248 5374 	movw	r3, #34164	; 0x8574
20002e10:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e14:	429a      	cmp	r2, r3
20002e16:	d000      	beq.n	20002e1a <MSS_SPI_init+0x26>
20002e18:	be00      	bkpt	0x0000
     * Initialize SPI driver instance data. Relies on the majority
     * of data requiring 0 for initial state so we just need to fill
     * with 0s and finish off with a small number of non zero values.
     */
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20002e1a:	687b      	ldr	r3, [r7, #4]
20002e1c:	791b      	ldrb	r3, [r3, #4]
20002e1e:	b25b      	sxtb	r3, r3
20002e20:	4618      	mov	r0, r3
20002e22:	f7ff ffab 	bl	20002d7c <NVIC_DisableIRQ>

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
20002e26:	6878      	ldr	r0, [r7, #4]
20002e28:	f04f 0100 	mov.w	r1, #0
20002e2c:	f04f 0284 	mov.w	r2, #132	; 0x84
20002e30:	f001 fe44 	bl	20004abc <memset>
    
    this_spi->cmd_done = 1u;
20002e34:	687b      	ldr	r3, [r7, #4]
20002e36:	f04f 0201 	mov.w	r2, #1
20002e3a:	625a      	str	r2, [r3, #36]	; 0x24

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
20002e3c:	f04f 0300 	mov.w	r3, #0
20002e40:	81fb      	strh	r3, [r7, #14]
20002e42:	e00d      	b.n	20002e60 <MSS_SPI_init+0x6c>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
20002e44:	89fb      	ldrh	r3, [r7, #14]
20002e46:	687a      	ldr	r2, [r7, #4]
20002e48:	f103 0306 	add.w	r3, r3, #6
20002e4c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20002e50:	4413      	add	r3, r2
20002e52:	f04f 32ff 	mov.w	r2, #4294967295
20002e56:	605a      	str	r2, [r3, #4]

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
    
    this_spi->cmd_done = 1u;

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
20002e58:	89fb      	ldrh	r3, [r7, #14]
20002e5a:	f103 0301 	add.w	r3, r3, #1
20002e5e:	81fb      	strh	r3, [r7, #14]
20002e60:	89fb      	ldrh	r3, [r7, #14]
20002e62:	2b07      	cmp	r3, #7
20002e64:	d9ee      	bls.n	20002e44 <MSS_SPI_init+0x50>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
    }

    if(this_spi == &g_mss_spi0)
20002e66:	687a      	ldr	r2, [r7, #4]
20002e68:	f248 53f8 	movw	r3, #34296	; 0x85f8
20002e6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002e70:	429a      	cmp	r2, r3
20002e72:	d126      	bne.n	20002ec2 <MSS_SPI_init+0xce>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
20002e74:	687a      	ldr	r2, [r7, #4]
20002e76:	f241 0300 	movw	r3, #4096	; 0x1000
20002e7a:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002e7e:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
20002e80:	687b      	ldr	r3, [r7, #4]
20002e82:	f04f 0202 	mov.w	r2, #2
20002e86:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
20002e88:	f248 0300 	movw	r3, #32768	; 0x8000
20002e8c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002e90:	f248 0200 	movw	r2, #32768	; 0x8000
20002e94:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002e98:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002e9a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20002e9e:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
20002ea0:	f04f 0002 	mov.w	r0, #2
20002ea4:	f7ff ff88 	bl	20002db8 <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
20002ea8:	f248 0300 	movw	r3, #32768	; 0x8000
20002eac:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002eb0:	f248 0200 	movw	r2, #32768	; 0x8000
20002eb4:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002eb8:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002eba:	f422 7200 	bic.w	r2, r2, #512	; 0x200
20002ebe:	649a      	str	r2, [r3, #72]	; 0x48
20002ec0:	e025      	b.n	20002f0e <MSS_SPI_init+0x11a>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
20002ec2:	687a      	ldr	r2, [r7, #4]
20002ec4:	f241 0300 	movw	r3, #4096	; 0x1000
20002ec8:	f2c4 0301 	movt	r3, #16385	; 0x4001
20002ecc:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
20002ece:	687b      	ldr	r3, [r7, #4]
20002ed0:	f04f 0203 	mov.w	r2, #3
20002ed4:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
20002ed6:	f248 0300 	movw	r3, #32768	; 0x8000
20002eda:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002ede:	f248 0200 	movw	r2, #32768	; 0x8000
20002ee2:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002ee6:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002ee8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20002eec:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
20002eee:	f04f 0003 	mov.w	r0, #3
20002ef2:	f7ff ff61 	bl	20002db8 <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
20002ef6:	f248 0300 	movw	r3, #32768	; 0x8000
20002efa:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002efe:	f248 0200 	movw	r2, #32768	; 0x8000
20002f02:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002f06:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002f08:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
20002f0c:	649a      	str	r2, [r3, #72]	; 0x48
    }
    
    /* De-assert reset bit. */
    this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
20002f0e:	687b      	ldr	r3, [r7, #4]
20002f10:	681b      	ldr	r3, [r3, #0]
20002f12:	687a      	ldr	r2, [r7, #4]
20002f14:	6812      	ldr	r2, [r2, #0]
20002f16:	6812      	ldr	r2, [r2, #0]
20002f18:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20002f1c:	601a      	str	r2, [r3, #0]
}
20002f1e:	f107 0710 	add.w	r7, r7, #16
20002f22:	46bd      	mov	sp, r7
20002f24:	bd80      	pop	{r7, pc}
20002f26:	bf00      	nop

20002f28 <recover_from_rx_overflow>:
 */
static void recover_from_rx_overflow
(
    mss_spi_instance_t * this_spi
)
{
20002f28:	b580      	push	{r7, lr}
20002f2a:	b08a      	sub	sp, #40	; 0x28
20002f2c:	af00      	add	r7, sp, #0
20002f2e:	6078      	str	r0, [r7, #4]
    uint32_t slave_select;
    
    /*
     * Read current SPI hardware block configuration.
     */
    control_reg = this_spi->hw_reg->CONTROL;
20002f30:	687b      	ldr	r3, [r7, #4]
20002f32:	681b      	ldr	r3, [r3, #0]
20002f34:	681b      	ldr	r3, [r3, #0]
20002f36:	60fb      	str	r3, [r7, #12]
    clk_gen = this_spi->hw_reg->CLK_GEN;
20002f38:	687b      	ldr	r3, [r7, #4]
20002f3a:	681b      	ldr	r3, [r3, #0]
20002f3c:	699b      	ldr	r3, [r3, #24]
20002f3e:	613b      	str	r3, [r7, #16]
    frame_size = this_spi->hw_reg->TXRXDF_SIZE;
20002f40:	687b      	ldr	r3, [r7, #4]
20002f42:	681b      	ldr	r3, [r3, #0]
20002f44:	685b      	ldr	r3, [r3, #4]
20002f46:	617b      	str	r3, [r7, #20]
    control2 = this_spi->hw_reg->CONTROL2;
20002f48:	687b      	ldr	r3, [r7, #4]
20002f4a:	681b      	ldr	r3, [r3, #0]
20002f4c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20002f4e:	61bb      	str	r3, [r7, #24]
    packet_size = this_spi->hw_reg->PKTSIZE;
20002f50:	687b      	ldr	r3, [r7, #4]
20002f52:	681b      	ldr	r3, [r3, #0]
20002f54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20002f56:	61fb      	str	r3, [r7, #28]
    cmd_size = this_spi->hw_reg->CMDSIZE;
20002f58:	687b      	ldr	r3, [r7, #4]
20002f5a:	681b      	ldr	r3, [r3, #0]
20002f5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20002f5e:	623b      	str	r3, [r7, #32]
    slave_select = this_spi->hw_reg->SLAVE_SELECT;
20002f60:	687b      	ldr	r3, [r7, #4]
20002f62:	681b      	ldr	r3, [r3, #0]
20002f64:	69db      	ldr	r3, [r3, #28]
20002f66:	627b      	str	r3, [r7, #36]	; 0x24
     
    /*
     * Reset the SPI hardware block.
     */
    if(this_spi == &g_mss_spi0)
20002f68:	687a      	ldr	r2, [r7, #4]
20002f6a:	f248 53f8 	movw	r3, #34296	; 0x85f8
20002f6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f72:	429a      	cmp	r2, r3
20002f74:	d12e      	bne.n	20002fd4 <recover_from_rx_overflow+0xac>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
20002f76:	687a      	ldr	r2, [r7, #4]
20002f78:	f241 0300 	movw	r3, #4096	; 0x1000
20002f7c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002f80:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
20002f82:	687b      	ldr	r3, [r7, #4]
20002f84:	f04f 0202 	mov.w	r2, #2
20002f88:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
20002f8a:	f248 0300 	movw	r3, #32768	; 0x8000
20002f8e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002f92:	f248 0200 	movw	r2, #32768	; 0x8000
20002f96:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002f9a:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002f9c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20002fa0:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
20002fa2:	f04f 0002 	mov.w	r0, #2
20002fa6:	f7ff ff07 	bl	20002db8 <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
20002faa:	f248 0300 	movw	r3, #32768	; 0x8000
20002fae:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002fb2:	f248 0200 	movw	r2, #32768	; 0x8000
20002fb6:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002fba:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002fbc:	f422 7200 	bic.w	r2, r2, #512	; 0x200
20002fc0:	649a      	str	r2, [r3, #72]	; 0x48

        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
20002fc2:	687b      	ldr	r3, [r7, #4]
20002fc4:	681b      	ldr	r3, [r3, #0]
20002fc6:	687a      	ldr	r2, [r7, #4]
20002fc8:	6812      	ldr	r2, [r2, #0]
20002fca:	6812      	ldr	r2, [r2, #0]
20002fcc:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20002fd0:	601a      	str	r2, [r3, #0]
20002fd2:	e02d      	b.n	20003030 <recover_from_rx_overflow+0x108>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
20002fd4:	687a      	ldr	r2, [r7, #4]
20002fd6:	f241 0300 	movw	r3, #4096	; 0x1000
20002fda:	f2c4 0301 	movt	r3, #16385	; 0x4001
20002fde:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
20002fe0:	687b      	ldr	r3, [r7, #4]
20002fe2:	f04f 0203 	mov.w	r2, #3
20002fe6:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
20002fe8:	f248 0300 	movw	r3, #32768	; 0x8000
20002fec:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002ff0:	f248 0200 	movw	r2, #32768	; 0x8000
20002ff4:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002ff8:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002ffa:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20002ffe:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
20003000:	f04f 0003 	mov.w	r0, #3
20003004:	f7ff fed8 	bl	20002db8 <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
20003008:	f248 0300 	movw	r3, #32768	; 0x8000
2000300c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003010:	f248 0200 	movw	r2, #32768	; 0x8000
20003014:	f2c4 0203 	movt	r2, #16387	; 0x4003
20003018:	6c92      	ldr	r2, [r2, #72]	; 0x48
2000301a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2000301e:	649a      	str	r2, [r3, #72]	; 0x48
        
        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
20003020:	687b      	ldr	r3, [r7, #4]
20003022:	681b      	ldr	r3, [r3, #0]
20003024:	687a      	ldr	r2, [r7, #4]
20003026:	6812      	ldr	r2, [r2, #0]
20003028:	6812      	ldr	r2, [r2, #0]
2000302a:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
2000302e:	601a      	str	r2, [r3, #0]
    }
    
    /*
     * Restore SPI hardware block configuration.
     */
    control_reg &= ~(uint32_t)CTRL_ENABLE_MASK;
20003030:	68fb      	ldr	r3, [r7, #12]
20003032:	f023 0301 	bic.w	r3, r3, #1
20003036:	60fb      	str	r3, [r7, #12]
    this_spi->hw_reg->CONTROL = control_reg;
20003038:	687b      	ldr	r3, [r7, #4]
2000303a:	681b      	ldr	r3, [r3, #0]
2000303c:	68fa      	ldr	r2, [r7, #12]
2000303e:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CLK_GEN = clk_gen;
20003040:	687b      	ldr	r3, [r7, #4]
20003042:	681b      	ldr	r3, [r3, #0]
20003044:	693a      	ldr	r2, [r7, #16]
20003046:	619a      	str	r2, [r3, #24]
    this_spi->hw_reg->TXRXDF_SIZE = frame_size;
20003048:	687b      	ldr	r3, [r7, #4]
2000304a:	681b      	ldr	r3, [r3, #0]
2000304c:	697a      	ldr	r2, [r7, #20]
2000304e:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20003050:	687b      	ldr	r3, [r7, #4]
20003052:	681b      	ldr	r3, [r3, #0]
20003054:	687a      	ldr	r2, [r7, #4]
20003056:	6812      	ldr	r2, [r2, #0]
20003058:	6812      	ldr	r2, [r2, #0]
2000305a:	f042 0201 	orr.w	r2, r2, #1
2000305e:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL2 = control2;
20003060:	687b      	ldr	r3, [r7, #4]
20003062:	681b      	ldr	r3, [r3, #0]
20003064:	69ba      	ldr	r2, [r7, #24]
20003066:	629a      	str	r2, [r3, #40]	; 0x28
    this_spi->hw_reg->PKTSIZE = packet_size;
20003068:	687b      	ldr	r3, [r7, #4]
2000306a:	681b      	ldr	r3, [r3, #0]
2000306c:	69fa      	ldr	r2, [r7, #28]
2000306e:	631a      	str	r2, [r3, #48]	; 0x30
    this_spi->hw_reg->CMDSIZE = cmd_size;
20003070:	687b      	ldr	r3, [r7, #4]
20003072:	681b      	ldr	r3, [r3, #0]
20003074:	6a3a      	ldr	r2, [r7, #32]
20003076:	635a      	str	r2, [r3, #52]	; 0x34
    this_spi->hw_reg->SLAVE_SELECT = slave_select;
20003078:	687b      	ldr	r3, [r7, #4]
2000307a:	681b      	ldr	r3, [r3, #0]
2000307c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
2000307e:	61da      	str	r2, [r3, #28]
}
20003080:	f107 0728 	add.w	r7, r7, #40	; 0x28
20003084:	46bd      	mov	sp, r7
20003086:	bd80      	pop	{r7, pc}

20003088 <MSS_SPI_configure_master_mode>:
    mss_spi_slave_t         slave,
    mss_spi_protocol_mode_t protocol_mode,
    uint32_t                clk_div,
    uint8_t                 frame_bit_length
)
{
20003088:	b580      	push	{r7, lr}
2000308a:	b086      	sub	sp, #24
2000308c:	af00      	add	r7, sp, #0
2000308e:	60f8      	str	r0, [r7, #12]
20003090:	607a      	str	r2, [r7, #4]
20003092:	603b      	str	r3, [r7, #0]
20003094:	460b      	mov	r3, r1
20003096:	72fb      	strb	r3, [r7, #11]
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20003098:	68fa      	ldr	r2, [r7, #12]
2000309a:	f248 53f8 	movw	r3, #34296	; 0x85f8
2000309e:	f2c2 0300 	movt	r3, #8192	; 0x2000
200030a2:	429a      	cmp	r2, r3
200030a4:	d007      	beq.n	200030b6 <MSS_SPI_configure_master_mode+0x2e>
200030a6:	68fa      	ldr	r2, [r7, #12]
200030a8:	f248 5374 	movw	r3, #34164	; 0x8574
200030ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
200030b0:	429a      	cmp	r2, r3
200030b2:	d000      	beq.n	200030b6 <MSS_SPI_configure_master_mode+0x2e>
200030b4:	be00      	bkpt	0x0000
    ASSERT(slave < MSS_SPI_MAX_NB_OF_SLAVES);
200030b6:	7afb      	ldrb	r3, [r7, #11]
200030b8:	2b07      	cmp	r3, #7
200030ba:	d900      	bls.n	200030be <MSS_SPI_configure_master_mode+0x36>
200030bc:	be00      	bkpt	0x0000
    ASSERT(frame_bit_length <= MAX_FRAME_LENGTH);
200030be:	f897 3020 	ldrb.w	r3, [r7, #32]
200030c2:	2b20      	cmp	r3, #32
200030c4:	d900      	bls.n	200030c8 <MSS_SPI_configure_master_mode+0x40>
200030c6:	be00      	bkpt	0x0000
     /* Check that the requested clock divider is within range and an even number. */
    ASSERT(clk_div >= 2u);
200030c8:	683b      	ldr	r3, [r7, #0]
200030ca:	2b01      	cmp	r3, #1
200030cc:	d800      	bhi.n	200030d0 <MSS_SPI_configure_master_mode+0x48>
200030ce:	be00      	bkpt	0x0000
    ASSERT(clk_div <= 512u);
200030d0:	683b      	ldr	r3, [r7, #0]
200030d2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200030d6:	d900      	bls.n	200030da <MSS_SPI_configure_master_mode+0x52>
200030d8:	be00      	bkpt	0x0000
    ASSERT(0u == (clk_div & 0x00000001));
200030da:	683b      	ldr	r3, [r7, #0]
200030dc:	f003 0301 	and.w	r3, r3, #1
200030e0:	2b00      	cmp	r3, #0
200030e2:	d000      	beq.n	200030e6 <MSS_SPI_configure_master_mode+0x5e>
200030e4:	be00      	bkpt	0x0000
   
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
200030e6:	68fb      	ldr	r3, [r7, #12]
200030e8:	791b      	ldrb	r3, [r3, #4]
200030ea:	b25b      	sxtb	r3, r3
200030ec:	4618      	mov	r0, r3
200030ee:	f7ff fe45 	bl	20002d7c <NVIC_DisableIRQ>

    /* Reset slave transfer mode to unknown to wipe slate clean */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_NONE;
200030f2:	68fb      	ldr	r3, [r7, #12]
200030f4:	f04f 0200 	mov.w	r2, #0
200030f8:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Set the mode. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
200030fc:	68fb      	ldr	r3, [r7, #12]
200030fe:	681b      	ldr	r3, [r3, #0]
20003100:	68fa      	ldr	r2, [r7, #12]
20003102:	6812      	ldr	r2, [r2, #0]
20003104:	6812      	ldr	r2, [r2, #0]
20003106:	f022 0201 	bic.w	r2, r2, #1
2000310a:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_MASTER_MASK;
2000310c:	68fb      	ldr	r3, [r7, #12]
2000310e:	681b      	ldr	r3, [r3, #0]
20003110:	68fa      	ldr	r2, [r7, #12]
20003112:	6812      	ldr	r2, [r2, #0]
20003114:	6812      	ldr	r2, [r2, #0]
20003116:	f042 0202 	orr.w	r2, r2, #2
2000311a:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
2000311c:	68fb      	ldr	r3, [r7, #12]
2000311e:	681b      	ldr	r3, [r3, #0]
20003120:	68fa      	ldr	r2, [r7, #12]
20003122:	6812      	ldr	r2, [r2, #0]
20003124:	6812      	ldr	r2, [r2, #0]
20003126:	f042 0201 	orr.w	r2, r2, #1
2000312a:	601a      	str	r2, [r3, #0]
    /*
     * Keep track of the required register configuration for this slave. These
     * values will be used by the MSS_SPI_set_slave_select() function to configure
     * the master to match the slave being selected.
     */
    if(slave < MSS_SPI_MAX_NB_OF_SLAVES)     
2000312c:	7afb      	ldrb	r3, [r7, #11]
2000312e:	2b07      	cmp	r3, #7
20003130:	d847      	bhi.n	200031c2 <MSS_SPI_configure_master_mode+0x13a>
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
20003132:	687b      	ldr	r3, [r7, #4]
20003134:	2b00      	cmp	r3, #0
20003136:	d00b      	beq.n	20003150 <MSS_SPI_configure_master_mode+0xc8>
20003138:	687b      	ldr	r3, [r7, #4]
2000313a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000313e:	d007      	beq.n	20003150 <MSS_SPI_configure_master_mode+0xc8>
20003140:	687b      	ldr	r3, [r7, #4]
20003142:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20003146:	d003      	beq.n	20003150 <MSS_SPI_configure_master_mode+0xc8>
20003148:	687b      	ldr	r3, [r7, #4]
2000314a:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
2000314e:	d10f      	bne.n	20003170 <MSS_SPI_configure_master_mode+0xe8>
           (MSS_SPI_MODE2 == protocol_mode) || (MSS_SPI_MODE3 == protocol_mode))
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK | SPS_MASK |
20003150:	7afa      	ldrb	r2, [r7, #11]
20003152:	6879      	ldr	r1, [r7, #4]
20003154:	f240 1302 	movw	r3, #258	; 0x102
20003158:	f2c3 4300 	movt	r3, #13312	; 0x3400
2000315c:	ea41 0303 	orr.w	r3, r1, r3
20003160:	68f9      	ldr	r1, [r7, #12]
20003162:	f102 0206 	add.w	r2, r2, #6
20003166:	ea4f 02c2 	mov.w	r2, r2, lsl #3
2000316a:	440a      	add	r2, r1
2000316c:	6053      	str	r3, [r2, #4]
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
2000316e:	e00e      	b.n	2000318e <MSS_SPI_configure_master_mode+0x106>
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        else
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK |
20003170:	7afa      	ldrb	r2, [r7, #11]
20003172:	6879      	ldr	r1, [r7, #4]
20003174:	f240 1302 	movw	r3, #258	; 0x102
20003178:	f2c3 0300 	movt	r3, #12288	; 0x3000
2000317c:	ea41 0303 	orr.w	r3, r1, r3
20003180:	68f9      	ldr	r1, [r7, #12]
20003182:	f102 0206 	add.w	r2, r2, #6
20003186:	ea4f 02c2 	mov.w	r2, r2, lsl #3
2000318a:	440a      	add	r2, r1
2000318c:	6053      	str	r3, [r2, #4]
                                                   BIGFIFO_MASK | CTRL_CLKMODE_MASK |
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        this_spi->slaves_cfg[slave].txrxdf_size_reg = frame_bit_length;
2000318e:	7afb      	ldrb	r3, [r7, #11]
20003190:	68fa      	ldr	r2, [r7, #12]
20003192:	f103 0306 	add.w	r3, r3, #6
20003196:	ea4f 03c3 	mov.w	r3, r3, lsl #3
2000319a:	4413      	add	r3, r2
2000319c:	f897 2020 	ldrb.w	r2, [r7, #32]
200031a0:	721a      	strb	r2, [r3, #8]

        clk_gen = (clk_div / 2u) - 1u;
200031a2:	683b      	ldr	r3, [r7, #0]
200031a4:	ea4f 0353 	mov.w	r3, r3, lsr #1
200031a8:	f103 33ff 	add.w	r3, r3, #4294967295
200031ac:	617b      	str	r3, [r7, #20]
        this_spi->slaves_cfg[slave].clk_gen = (uint8_t)clk_gen;
200031ae:	7afb      	ldrb	r3, [r7, #11]
200031b0:	697a      	ldr	r2, [r7, #20]
200031b2:	b2d2      	uxtb	r2, r2
200031b4:	68f9      	ldr	r1, [r7, #12]
200031b6:	f103 0306 	add.w	r3, r3, #6
200031ba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
200031be:	440b      	add	r3, r1
200031c0:	725a      	strb	r2, [r3, #9]
    }
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
200031c2:	68fb      	ldr	r3, [r7, #12]
200031c4:	791b      	ldrb	r3, [r3, #4]
200031c6:	b25b      	sxtb	r3, r3
200031c8:	4618      	mov	r0, r3
200031ca:	f7ff fdbb 	bl	20002d44 <NVIC_EnableIRQ>
}
200031ce:	f107 0718 	add.w	r7, r7, #24
200031d2:	46bd      	mov	sp, r7
200031d4:	bd80      	pop	{r7, pc}
200031d6:	bf00      	nop

200031d8 <MSS_SPI_set_slave_select>:
void MSS_SPI_set_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
200031d8:	b580      	push	{r7, lr}
200031da:	b084      	sub	sp, #16
200031dc:	af00      	add	r7, sp, #0
200031de:	6078      	str	r0, [r7, #4]
200031e0:	460b      	mov	r3, r1
200031e2:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
200031e4:	687a      	ldr	r2, [r7, #4]
200031e6:	f248 53f8 	movw	r3, #34296	; 0x85f8
200031ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200031ee:	429a      	cmp	r2, r3
200031f0:	d007      	beq.n	20003202 <MSS_SPI_set_slave_select+0x2a>
200031f2:	687a      	ldr	r2, [r7, #4]
200031f4:	f248 5374 	movw	r3, #34164	; 0x8574
200031f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200031fc:	429a      	cmp	r2, r3
200031fe:	d000      	beq.n	20003202 <MSS_SPI_set_slave_select+0x2a>
20003200:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
20003202:	687b      	ldr	r3, [r7, #4]
20003204:	681b      	ldr	r3, [r3, #0]
20003206:	681b      	ldr	r3, [r3, #0]
20003208:	f003 0302 	and.w	r3, r3, #2
2000320c:	2b00      	cmp	r3, #0
2000320e:	d100      	bne.n	20003212 <MSS_SPI_set_slave_select+0x3a>
20003210:	be00      	bkpt	0x0000
    
    ASSERT(this_spi->slaves_cfg[slave].ctrl_reg != NOT_CONFIGURED);
20003212:	78fb      	ldrb	r3, [r7, #3]
20003214:	687a      	ldr	r2, [r7, #4]
20003216:	f103 0306 	add.w	r3, r3, #6
2000321a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
2000321e:	4413      	add	r3, r2
20003220:	685b      	ldr	r3, [r3, #4]
20003222:	f1b3 3fff 	cmp.w	r3, #4294967295
20003226:	d100      	bne.n	2000322a <MSS_SPI_set_slave_select+0x52>
20003228:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
2000322a:	687b      	ldr	r3, [r7, #4]
2000322c:	791b      	ldrb	r3, [r3, #4]
2000322e:	b25b      	sxtb	r3, r3
20003230:	4618      	mov	r0, r3
20003232:	f7ff fda3 	bl	20002d7c <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
20003236:	687b      	ldr	r3, [r7, #4]
20003238:	681b      	ldr	r3, [r3, #0]
2000323a:	689b      	ldr	r3, [r3, #8]
2000323c:	f003 0304 	and.w	r3, r3, #4
20003240:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
20003242:	68fb      	ldr	r3, [r7, #12]
20003244:	2b00      	cmp	r3, #0
20003246:	d002      	beq.n	2000324e <MSS_SPI_set_slave_select+0x76>
    {
         recover_from_rx_overflow(this_spi);
20003248:	6878      	ldr	r0, [r7, #4]
2000324a:	f7ff fe6d 	bl	20002f28 <recover_from_rx_overflow>
    }
    
    /* Set the clock rate. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
2000324e:	687b      	ldr	r3, [r7, #4]
20003250:	681b      	ldr	r3, [r3, #0]
20003252:	687a      	ldr	r2, [r7, #4]
20003254:	6812      	ldr	r2, [r2, #0]
20003256:	6812      	ldr	r2, [r2, #0]
20003258:	f022 0201 	bic.w	r2, r2, #1
2000325c:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = this_spi->slaves_cfg[slave].ctrl_reg;
2000325e:	687b      	ldr	r3, [r7, #4]
20003260:	681a      	ldr	r2, [r3, #0]
20003262:	78fb      	ldrb	r3, [r7, #3]
20003264:	6879      	ldr	r1, [r7, #4]
20003266:	f103 0306 	add.w	r3, r3, #6
2000326a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
2000326e:	440b      	add	r3, r1
20003270:	685b      	ldr	r3, [r3, #4]
20003272:	6013      	str	r3, [r2, #0]
    this_spi->hw_reg->CLK_GEN = this_spi->slaves_cfg[slave].clk_gen;
20003274:	687b      	ldr	r3, [r7, #4]
20003276:	681a      	ldr	r2, [r3, #0]
20003278:	78fb      	ldrb	r3, [r7, #3]
2000327a:	6879      	ldr	r1, [r7, #4]
2000327c:	f103 0306 	add.w	r3, r3, #6
20003280:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20003284:	440b      	add	r3, r1
20003286:	7a5b      	ldrb	r3, [r3, #9]
20003288:	6193      	str	r3, [r2, #24]
    this_spi->hw_reg->TXRXDF_SIZE = this_spi->slaves_cfg[slave].txrxdf_size_reg;
2000328a:	687b      	ldr	r3, [r7, #4]
2000328c:	681a      	ldr	r2, [r3, #0]
2000328e:	78fb      	ldrb	r3, [r7, #3]
20003290:	6879      	ldr	r1, [r7, #4]
20003292:	f103 0306 	add.w	r3, r3, #6
20003296:	ea4f 03c3 	mov.w	r3, r3, lsl #3
2000329a:	440b      	add	r3, r1
2000329c:	7a1b      	ldrb	r3, [r3, #8]
2000329e:	6053      	str	r3, [r2, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
200032a0:	687b      	ldr	r3, [r7, #4]
200032a2:	681b      	ldr	r3, [r3, #0]
200032a4:	687a      	ldr	r2, [r7, #4]
200032a6:	6812      	ldr	r2, [r2, #0]
200032a8:	6812      	ldr	r2, [r2, #0]
200032aa:	f042 0201 	orr.w	r2, r2, #1
200032ae:	601a      	str	r2, [r3, #0]
    
    /* Set slave select */
    this_spi->hw_reg->SLAVE_SELECT |= ((uint32_t)1 << (uint32_t)slave);
200032b0:	687b      	ldr	r3, [r7, #4]
200032b2:	681b      	ldr	r3, [r3, #0]
200032b4:	687a      	ldr	r2, [r7, #4]
200032b6:	6812      	ldr	r2, [r2, #0]
200032b8:	69d1      	ldr	r1, [r2, #28]
200032ba:	78fa      	ldrb	r2, [r7, #3]
200032bc:	f04f 0001 	mov.w	r0, #1
200032c0:	fa00 f202 	lsl.w	r2, r0, r2
200032c4:	ea41 0202 	orr.w	r2, r1, r2
200032c8:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
200032ca:	687b      	ldr	r3, [r7, #4]
200032cc:	791b      	ldrb	r3, [r3, #4]
200032ce:	b25b      	sxtb	r3, r3
200032d0:	4618      	mov	r0, r3
200032d2:	f7ff fd37 	bl	20002d44 <NVIC_EnableIRQ>
}
200032d6:	f107 0710 	add.w	r7, r7, #16
200032da:	46bd      	mov	sp, r7
200032dc:	bd80      	pop	{r7, pc}
200032de:	bf00      	nop

200032e0 <MSS_SPI_clear_slave_select>:
void MSS_SPI_clear_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
200032e0:	b580      	push	{r7, lr}
200032e2:	b084      	sub	sp, #16
200032e4:	af00      	add	r7, sp, #0
200032e6:	6078      	str	r0, [r7, #4]
200032e8:	460b      	mov	r3, r1
200032ea:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
200032ec:	687a      	ldr	r2, [r7, #4]
200032ee:	f248 53f8 	movw	r3, #34296	; 0x85f8
200032f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200032f6:	429a      	cmp	r2, r3
200032f8:	d007      	beq.n	2000330a <MSS_SPI_clear_slave_select+0x2a>
200032fa:	687a      	ldr	r2, [r7, #4]
200032fc:	f248 5374 	movw	r3, #34164	; 0x8574
20003300:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003304:	429a      	cmp	r2, r3
20003306:	d000      	beq.n	2000330a <MSS_SPI_clear_slave_select+0x2a>
20003308:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
2000330a:	687b      	ldr	r3, [r7, #4]
2000330c:	681b      	ldr	r3, [r3, #0]
2000330e:	681b      	ldr	r3, [r3, #0]
20003310:	f003 0302 	and.w	r3, r3, #2
20003314:	2b00      	cmp	r3, #0
20003316:	d100      	bne.n	2000331a <MSS_SPI_clear_slave_select+0x3a>
20003318:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
2000331a:	687b      	ldr	r3, [r7, #4]
2000331c:	791b      	ldrb	r3, [r3, #4]
2000331e:	b25b      	sxtb	r3, r3
20003320:	4618      	mov	r0, r3
20003322:	f7ff fd2b 	bl	20002d7c <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
20003326:	687b      	ldr	r3, [r7, #4]
20003328:	681b      	ldr	r3, [r3, #0]
2000332a:	689b      	ldr	r3, [r3, #8]
2000332c:	f003 0304 	and.w	r3, r3, #4
20003330:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
20003332:	68fb      	ldr	r3, [r7, #12]
20003334:	2b00      	cmp	r3, #0
20003336:	d002      	beq.n	2000333e <MSS_SPI_clear_slave_select+0x5e>
    {
         recover_from_rx_overflow(this_spi);
20003338:	6878      	ldr	r0, [r7, #4]
2000333a:	f7ff fdf5 	bl	20002f28 <recover_from_rx_overflow>
    }
    
    this_spi->hw_reg->SLAVE_SELECT &= ~((uint32_t)1 << (uint32_t)slave);
2000333e:	687b      	ldr	r3, [r7, #4]
20003340:	681b      	ldr	r3, [r3, #0]
20003342:	687a      	ldr	r2, [r7, #4]
20003344:	6812      	ldr	r2, [r2, #0]
20003346:	69d1      	ldr	r1, [r2, #28]
20003348:	78fa      	ldrb	r2, [r7, #3]
2000334a:	f04f 0001 	mov.w	r0, #1
2000334e:	fa00 f202 	lsl.w	r2, r0, r2
20003352:	ea6f 0202 	mvn.w	r2, r2
20003356:	ea01 0202 	and.w	r2, r1, r2
2000335a:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
2000335c:	687b      	ldr	r3, [r7, #4]
2000335e:	791b      	ldrb	r3, [r3, #4]
20003360:	b25b      	sxtb	r3, r3
20003362:	4618      	mov	r0, r3
20003364:	f7ff fcee 	bl	20002d44 <NVIC_EnableIRQ>
}
20003368:	f107 0710 	add.w	r7, r7, #16
2000336c:	46bd      	mov	sp, r7
2000336e:	bd80      	pop	{r7, pc}

20003370 <MSS_SPI_transfer_block>:
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * rd_buffer,
    uint16_t rd_byte_size
)
{
20003370:	b580      	push	{r7, lr}
20003372:	b08e      	sub	sp, #56	; 0x38
20003374:	af00      	add	r7, sp, #0
20003376:	60f8      	str	r0, [r7, #12]
20003378:	60b9      	str	r1, [r7, #8]
2000337a:	603b      	str	r3, [r7, #0]
2000337c:	4613      	mov	r3, r2
2000337e:	80fb      	strh	r3, [r7, #6]
    uint16_t transfer_idx = 0u;
20003380:	f04f 0300 	mov.w	r3, #0
20003384:	837b      	strh	r3, [r7, #26]
    uint16_t tx_idx;
    uint16_t rx_idx;
    uint32_t frame_count;
    volatile uint32_t rx_raw;
    uint16_t transit = 0u;
20003386:	f04f 0300 	mov.w	r3, #0
2000338a:	84fb      	strh	r3, [r7, #38]	; 0x26
    uint32_t rx_overflow;
    uint32_t rx_fifo_empty;
    
    uint16_t transfer_size;     /* Total number of bytes transfered. */
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
2000338c:	68fa      	ldr	r2, [r7, #12]
2000338e:	f248 53f8 	movw	r3, #34296	; 0x85f8
20003392:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003396:	429a      	cmp	r2, r3
20003398:	d007      	beq.n	200033aa <MSS_SPI_transfer_block+0x3a>
2000339a:	68fa      	ldr	r2, [r7, #12]
2000339c:	f248 5374 	movw	r3, #34164	; 0x8574
200033a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200033a4:	429a      	cmp	r2, r3
200033a6:	d000      	beq.n	200033aa <MSS_SPI_transfer_block+0x3a>
200033a8:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
200033aa:	68fb      	ldr	r3, [r7, #12]
200033ac:	681b      	ldr	r3, [r3, #0]
200033ae:	681b      	ldr	r3, [r3, #0]
200033b0:	f003 0302 	and.w	r3, r3, #2
200033b4:	2b00      	cmp	r3, #0
200033b6:	d100      	bne.n	200033ba <MSS_SPI_transfer_block+0x4a>
200033b8:	be00      	bkpt	0x0000
    
    /* Compute number of bytes to transfer. */
    transfer_size = cmd_byte_size + rd_byte_size;
200033ba:	88fa      	ldrh	r2, [r7, #6]
200033bc:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
200033c0:	4413      	add	r3, r2
200033c2:	86fb      	strh	r3, [r7, #54]	; 0x36
    
    /* Adjust to 1 byte transfer to cater for DMA transfers. */
    if(0u == transfer_size)
200033c4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
200033c6:	2b00      	cmp	r3, #0
200033c8:	d103      	bne.n	200033d2 <MSS_SPI_transfer_block+0x62>
    {
        frame_count = 1u;
200033ca:	f04f 0301 	mov.w	r3, #1
200033ce:	623b      	str	r3, [r7, #32]
200033d0:	e001      	b.n	200033d6 <MSS_SPI_transfer_block+0x66>
    }
    else
    {
        frame_count = transfer_size;
200033d2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
200033d4:	623b      	str	r3, [r7, #32]
    }

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
200033d6:	68fb      	ldr	r3, [r7, #12]
200033d8:	681b      	ldr	r3, [r3, #0]
200033da:	68fa      	ldr	r2, [r7, #12]
200033dc:	6812      	ldr	r2, [r2, #0]
200033de:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200033e0:	f042 020c 	orr.w	r2, r2, #12
200033e4:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
200033e6:	68fb      	ldr	r3, [r7, #12]
200033e8:	681b      	ldr	r3, [r3, #0]
200033ea:	689b      	ldr	r3, [r3, #8]
200033ec:	f003 0304 	and.w	r3, r3, #4
200033f0:	62fb      	str	r3, [r7, #44]	; 0x2c
    if(rx_overflow)
200033f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
200033f4:	2b00      	cmp	r3, #0
200033f6:	d002      	beq.n	200033fe <MSS_SPI_transfer_block+0x8e>
    {
         recover_from_rx_overflow(this_spi);
200033f8:	68f8      	ldr	r0, [r7, #12]
200033fa:	f7ff fd95 	bl	20002f28 <recover_from_rx_overflow>
    }
    
    /* Set frame size to 8 bits and the frame count to the transfer size. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
200033fe:	68fb      	ldr	r3, [r7, #12]
20003400:	681b      	ldr	r3, [r3, #0]
20003402:	68fa      	ldr	r2, [r7, #12]
20003404:	6812      	ldr	r2, [r2, #0]
20003406:	6812      	ldr	r2, [r2, #0]
20003408:	f022 0201 	bic.w	r2, r2, #1
2000340c:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) | ( (frame_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
2000340e:	68fb      	ldr	r3, [r7, #12]
20003410:	6819      	ldr	r1, [r3, #0]
20003412:	68fb      	ldr	r3, [r7, #12]
20003414:	681b      	ldr	r3, [r3, #0]
20003416:	681b      	ldr	r3, [r3, #0]
20003418:	f240 02ff 	movw	r2, #255	; 0xff
2000341c:	f6cf 7200 	movt	r2, #65280	; 0xff00
20003420:	ea03 0202 	and.w	r2, r3, r2
20003424:	6a3b      	ldr	r3, [r7, #32]
20003426:	ea4f 2003 	mov.w	r0, r3, lsl #8
2000342a:	f64f 7300 	movw	r3, #65280	; 0xff00
2000342e:	f2c0 03ff 	movt	r3, #255	; 0xff
20003432:	ea00 0303 	and.w	r3, r0, r3
20003436:	ea42 0303 	orr.w	r3, r2, r3
2000343a:	600b      	str	r3, [r1, #0]
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
2000343c:	68fb      	ldr	r3, [r7, #12]
2000343e:	681b      	ldr	r3, [r3, #0]
20003440:	f04f 0208 	mov.w	r2, #8
20003444:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20003446:	68fb      	ldr	r3, [r7, #12]
20003448:	681b      	ldr	r3, [r3, #0]
2000344a:	68fa      	ldr	r2, [r7, #12]
2000344c:	6812      	ldr	r2, [r2, #0]
2000344e:	6812      	ldr	r2, [r2, #0]
20003450:	f042 0201 	orr.w	r2, r2, #1
20003454:	601a      	str	r2, [r3, #0]

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
20003456:	68fb      	ldr	r3, [r7, #12]
20003458:	681b      	ldr	r3, [r3, #0]
2000345a:	689b      	ldr	r3, [r3, #8]
2000345c:	f003 0340 	and.w	r3, r3, #64	; 0x40
20003460:	633b      	str	r3, [r7, #48]	; 0x30
    while(0u == rx_fifo_empty)
20003462:	e009      	b.n	20003478 <MSS_SPI_transfer_block+0x108>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
20003464:	68fb      	ldr	r3, [r7, #12]
20003466:	681b      	ldr	r3, [r3, #0]
20003468:	691b      	ldr	r3, [r3, #16]
2000346a:	617b      	str	r3, [r7, #20]
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
2000346c:	68fb      	ldr	r3, [r7, #12]
2000346e:	681b      	ldr	r3, [r3, #0]
20003470:	689b      	ldr	r3, [r3, #8]
20003472:	f003 0340 	and.w	r3, r3, #64	; 0x40
20003476:	633b      	str	r3, [r7, #48]	; 0x30
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    while(0u == rx_fifo_empty)
20003478:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2000347a:	2b00      	cmp	r3, #0
2000347c:	d0f2      	beq.n	20003464 <MSS_SPI_transfer_block+0xf4>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    }
    
    tx_idx = 0u;
2000347e:	f04f 0300 	mov.w	r3, #0
20003482:	83bb      	strh	r3, [r7, #28]
    rx_idx = 0u;
20003484:	f04f 0300 	mov.w	r3, #0
20003488:	83fb      	strh	r3, [r7, #30]
    if(tx_idx < cmd_byte_size)
2000348a:	8bba      	ldrh	r2, [r7, #28]
2000348c:	88fb      	ldrh	r3, [r7, #6]
2000348e:	429a      	cmp	r2, r3
20003490:	d20f      	bcs.n	200034b2 <MSS_SPI_transfer_block+0x142>
    {
        this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
20003492:	68fb      	ldr	r3, [r7, #12]
20003494:	681b      	ldr	r3, [r3, #0]
20003496:	8bb9      	ldrh	r1, [r7, #28]
20003498:	68ba      	ldr	r2, [r7, #8]
2000349a:	440a      	add	r2, r1
2000349c:	7812      	ldrb	r2, [r2, #0]
2000349e:	615a      	str	r2, [r3, #20]
        ++tx_idx;
200034a0:	8bbb      	ldrh	r3, [r7, #28]
200034a2:	f103 0301 	add.w	r3, r3, #1
200034a6:	83bb      	strh	r3, [r7, #28]
        ++transit;
200034a8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
200034aa:	f103 0301 	add.w	r3, r3, #1
200034ae:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
200034b0:	e06a      	b.n	20003588 <MSS_SPI_transfer_block+0x218>
        ++tx_idx;
        ++transit;
    }
    else
    {
        if(tx_idx < transfer_size)
200034b2:	8bba      	ldrh	r2, [r7, #28]
200034b4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
200034b6:	429a      	cmp	r2, r3
200034b8:	d266      	bcs.n	20003588 <MSS_SPI_transfer_block+0x218>
        {
            this_spi->hw_reg->TX_DATA = 0x00u;
200034ba:	68fb      	ldr	r3, [r7, #12]
200034bc:	681b      	ldr	r3, [r3, #0]
200034be:	f04f 0200 	mov.w	r2, #0
200034c2:	615a      	str	r2, [r3, #20]
            ++tx_idx;
200034c4:	8bbb      	ldrh	r3, [r7, #28]
200034c6:	f103 0301 	add.w	r3, r3, #1
200034ca:	83bb      	strh	r3, [r7, #28]
            ++transit;
200034cc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
200034ce:	f103 0301 	add.w	r3, r3, #1
200034d2:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
200034d4:	e058      	b.n	20003588 <MSS_SPI_transfer_block+0x218>
    {
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
200034d6:	68fb      	ldr	r3, [r7, #12]
200034d8:	681b      	ldr	r3, [r3, #0]
200034da:	689b      	ldr	r3, [r3, #8]
200034dc:	f003 0340 	and.w	r3, r3, #64	; 0x40
200034e0:	633b      	str	r3, [r7, #48]	; 0x30
        if(0u == rx_fifo_empty)
200034e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
200034e4:	2b00      	cmp	r3, #0
200034e6:	d11e      	bne.n	20003526 <MSS_SPI_transfer_block+0x1b6>
        {
            /* Process received byte. */
            rx_raw = this_spi->hw_reg->RX_DATA;
200034e8:	68fb      	ldr	r3, [r7, #12]
200034ea:	681b      	ldr	r3, [r3, #0]
200034ec:	691b      	ldr	r3, [r3, #16]
200034ee:	617b      	str	r3, [r7, #20]
            if(transfer_idx >= cmd_byte_size)
200034f0:	8b7a      	ldrh	r2, [r7, #26]
200034f2:	88fb      	ldrh	r3, [r7, #6]
200034f4:	429a      	cmp	r2, r3
200034f6:	d30e      	bcc.n	20003516 <MSS_SPI_transfer_block+0x1a6>
            {
                if(rx_idx < rd_byte_size)
200034f8:	8bfa      	ldrh	r2, [r7, #30]
200034fa:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
200034fe:	429a      	cmp	r2, r3
20003500:	d205      	bcs.n	2000350e <MSS_SPI_transfer_block+0x19e>
                {
                    rd_buffer[rx_idx] = (uint8_t)rx_raw;   
20003502:	8bfa      	ldrh	r2, [r7, #30]
20003504:	683b      	ldr	r3, [r7, #0]
20003506:	4413      	add	r3, r2
20003508:	697a      	ldr	r2, [r7, #20]
2000350a:	b2d2      	uxtb	r2, r2
2000350c:	701a      	strb	r2, [r3, #0]
                }
                ++rx_idx;
2000350e:	8bfb      	ldrh	r3, [r7, #30]
20003510:	f103 0301 	add.w	r3, r3, #1
20003514:	83fb      	strh	r3, [r7, #30]
            }
            ++transfer_idx;
20003516:	8b7b      	ldrh	r3, [r7, #26]
20003518:	f103 0301 	add.w	r3, r3, #1
2000351c:	837b      	strh	r3, [r7, #26]
            --transit;
2000351e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20003520:	f103 33ff 	add.w	r3, r3, #4294967295
20003524:	84fb      	strh	r3, [r7, #38]	; 0x26
        }

        tx_fifo_full = this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK;
20003526:	68fb      	ldr	r3, [r7, #12]
20003528:	681b      	ldr	r3, [r3, #0]
2000352a:	689b      	ldr	r3, [r3, #8]
2000352c:	f403 7380 	and.w	r3, r3, #256	; 0x100
20003530:	62bb      	str	r3, [r7, #40]	; 0x28
        if(0u == tx_fifo_full)
20003532:	6abb      	ldr	r3, [r7, #40]	; 0x28
20003534:	2b00      	cmp	r3, #0
20003536:	d127      	bne.n	20003588 <MSS_SPI_transfer_block+0x218>
        {
            if(transit < RX_FIFO_SIZE)
20003538:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
2000353a:	2b03      	cmp	r3, #3
2000353c:	d824      	bhi.n	20003588 <MSS_SPI_transfer_block+0x218>
            {
                /* Send another byte. */
                if(tx_idx < cmd_byte_size)
2000353e:	8bba      	ldrh	r2, [r7, #28]
20003540:	88fb      	ldrh	r3, [r7, #6]
20003542:	429a      	cmp	r2, r3
20003544:	d20f      	bcs.n	20003566 <MSS_SPI_transfer_block+0x1f6>
                {
                    this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
20003546:	68fb      	ldr	r3, [r7, #12]
20003548:	681b      	ldr	r3, [r3, #0]
2000354a:	8bb9      	ldrh	r1, [r7, #28]
2000354c:	68ba      	ldr	r2, [r7, #8]
2000354e:	440a      	add	r2, r1
20003550:	7812      	ldrb	r2, [r2, #0]
20003552:	615a      	str	r2, [r3, #20]
                    ++tx_idx;
20003554:	8bbb      	ldrh	r3, [r7, #28]
20003556:	f103 0301 	add.w	r3, r3, #1
2000355a:	83bb      	strh	r3, [r7, #28]
                    ++transit;
2000355c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
2000355e:	f103 0301 	add.w	r3, r3, #1
20003562:	84fb      	strh	r3, [r7, #38]	; 0x26
20003564:	e010      	b.n	20003588 <MSS_SPI_transfer_block+0x218>
                }
                else
                {
                    if(tx_idx < transfer_size)
20003566:	8bba      	ldrh	r2, [r7, #28]
20003568:	8efb      	ldrh	r3, [r7, #54]	; 0x36
2000356a:	429a      	cmp	r2, r3
2000356c:	d20c      	bcs.n	20003588 <MSS_SPI_transfer_block+0x218>
                    {
                        this_spi->hw_reg->TX_DATA = 0x00u;
2000356e:	68fb      	ldr	r3, [r7, #12]
20003570:	681b      	ldr	r3, [r3, #0]
20003572:	f04f 0200 	mov.w	r2, #0
20003576:	615a      	str	r2, [r3, #20]
                        ++tx_idx;
20003578:	8bbb      	ldrh	r3, [r7, #28]
2000357a:	f103 0301 	add.w	r3, r3, #1
2000357e:	83bb      	strh	r3, [r7, #28]
                        ++transit;
20003580:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20003582:	f103 0301 	add.w	r3, r3, #1
20003586:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
20003588:	8b7a      	ldrh	r2, [r7, #26]
2000358a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
2000358c:	429a      	cmp	r2, r3
2000358e:	d3a2      	bcc.n	200034d6 <MSS_SPI_transfer_block+0x166>
                    }
                }
            }
        }
    }
}
20003590:	f107 0738 	add.w	r7, r7, #56	; 0x38
20003594:	46bd      	mov	sp, r7
20003596:	bd80      	pop	{r7, pc}

20003598 <fill_slave_tx_fifo>:
 */
static void fill_slave_tx_fifo
(
    mss_spi_instance_t * this_spi
)
{
20003598:	b480      	push	{r7}
2000359a:	b085      	sub	sp, #20
2000359c:	af00      	add	r7, sp, #0
2000359e:	6078      	str	r0, [r7, #4]
    uint32_t guard = 0u;
200035a0:	f04f 0300 	mov.w	r3, #0
200035a4:	60fb      	str	r3, [r7, #12]

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200035a6:	e00e      	b.n	200035c6 <fill_slave_tx_fifo+0x2e>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
    {
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
200035a8:	687b      	ldr	r3, [r7, #4]
200035aa:	681b      	ldr	r3, [r3, #0]
200035ac:	687a      	ldr	r2, [r7, #4]
200035ae:	6891      	ldr	r1, [r2, #8]
200035b0:	687a      	ldr	r2, [r7, #4]
200035b2:	6912      	ldr	r2, [r2, #16]
200035b4:	440a      	add	r2, r1
200035b6:	7812      	ldrb	r2, [r2, #0]
200035b8:	615a      	str	r2, [r3, #20]
        ++this_spi->slave_tx_idx;
200035ba:	687b      	ldr	r3, [r7, #4]
200035bc:	691b      	ldr	r3, [r3, #16]
200035be:	f103 0201 	add.w	r2, r3, #1
200035c2:	687b      	ldr	r3, [r7, #4]
200035c4:	611a      	str	r2, [r3, #16]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200035c6:	687b      	ldr	r3, [r7, #4]
200035c8:	681b      	ldr	r3, [r3, #0]
200035ca:	689b      	ldr	r3, [r3, #8]
200035cc:	f403 7380 	and.w	r3, r3, #256	; 0x100
200035d0:	2b00      	cmp	r3, #0
200035d2:	d105      	bne.n	200035e0 <fill_slave_tx_fifo+0x48>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
200035d4:	687b      	ldr	r3, [r7, #4]
200035d6:	691a      	ldr	r2, [r3, #16]
200035d8:	687b      	ldr	r3, [r7, #4]
200035da:	68db      	ldr	r3, [r3, #12]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200035dc:	429a      	cmp	r2, r3
200035de:	d3e3      	bcc.n	200035a8 <fill_slave_tx_fifo+0x10>
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
200035e0:	687b      	ldr	r3, [r7, #4]
200035e2:	691a      	ldr	r2, [r3, #16]
200035e4:	687b      	ldr	r3, [r7, #4]
200035e6:	68db      	ldr	r3, [r3, #12]
200035e8:	429a      	cmp	r2, r3
200035ea:	d31c      	bcc.n	20003626 <fill_slave_tx_fifo+0x8e>
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200035ec:	e00e      	b.n	2000360c <fill_slave_tx_fifo+0x74>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
        {
            /* Sending from command response buffer */
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
200035ee:	687b      	ldr	r3, [r7, #4]
200035f0:	681b      	ldr	r3, [r3, #0]
200035f2:	687a      	ldr	r2, [r7, #4]
200035f4:	6951      	ldr	r1, [r2, #20]
200035f6:	687a      	ldr	r2, [r7, #4]
200035f8:	69d2      	ldr	r2, [r2, #28]
200035fa:	440a      	add	r2, r1
200035fc:	7812      	ldrb	r2, [r2, #0]
200035fe:	615a      	str	r2, [r3, #20]
            ++this_spi->resp_buff_tx_idx;
20003600:	687b      	ldr	r3, [r7, #4]
20003602:	69db      	ldr	r3, [r3, #28]
20003604:	f103 0201 	add.w	r2, r3, #1
20003608:	687b      	ldr	r3, [r7, #4]
2000360a:	61da      	str	r2, [r3, #28]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000360c:	687b      	ldr	r3, [r7, #4]
2000360e:	681b      	ldr	r3, [r3, #0]
20003610:	689b      	ldr	r3, [r3, #8]
20003612:	f403 7380 	and.w	r3, r3, #256	; 0x100
20003616:	2b00      	cmp	r3, #0
20003618:	d105      	bne.n	20003626 <fill_slave_tx_fifo+0x8e>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
2000361a:	687b      	ldr	r3, [r7, #4]
2000361c:	69da      	ldr	r2, [r3, #28]
2000361e:	687b      	ldr	r3, [r7, #4]
20003620:	699b      	ldr	r3, [r3, #24]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20003622:	429a      	cmp	r2, r3
20003624:	d3e3      	bcc.n	200035ee <fill_slave_tx_fifo+0x56>
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
20003626:	687b      	ldr	r3, [r7, #4]
20003628:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000362a:	2b00      	cmp	r3, #0
2000362c:	d01f      	beq.n	2000366e <fill_slave_tx_fifo+0xd6>
2000362e:	687b      	ldr	r3, [r7, #4]
20003630:	691a      	ldr	r2, [r3, #16]
20003632:	687b      	ldr	r3, [r7, #4]
20003634:	68db      	ldr	r3, [r3, #12]
20003636:	429a      	cmp	r2, r3
20003638:	d319      	bcc.n	2000366e <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
2000363a:	687b      	ldr	r3, [r7, #4]
2000363c:	69da      	ldr	r2, [r3, #28]
2000363e:	687b      	ldr	r3, [r7, #4]
20003640:	699b      	ldr	r3, [r3, #24]
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
20003642:	429a      	cmp	r2, r3
20003644:	d313      	bcc.n	2000366e <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20003646:	e008      	b.n	2000365a <fill_slave_tx_fifo+0xc2>
              (guard < BIG_FIFO_SIZE))
        {
            /* Nothing left so pad with 0s for consistency */
            this_spi->hw_reg->TX_DATA = 0x00u;
20003648:	687b      	ldr	r3, [r7, #4]
2000364a:	681b      	ldr	r3, [r3, #0]
2000364c:	f04f 0200 	mov.w	r2, #0
20003650:	615a      	str	r2, [r3, #20]
             * We use the guard count to cover the unlikely event that we are
             * never seeing the TX FIFO full because the data is being pulled
             * out as fast as we can stuff it in. In this event we never spend
             * more than a full FIFOs worth of time spinning here.
             */
            guard++;
20003652:	68fb      	ldr	r3, [r7, #12]
20003654:	f103 0301 	add.w	r3, r3, #1
20003658:	60fb      	str	r3, [r7, #12]
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000365a:	687b      	ldr	r3, [r7, #4]
2000365c:	681b      	ldr	r3, [r3, #0]
2000365e:	689b      	ldr	r3, [r3, #8]
20003660:	f403 7380 	and.w	r3, r3, #256	; 0x100
20003664:	2b00      	cmp	r3, #0
20003666:	d102      	bne.n	2000366e <fill_slave_tx_fifo+0xd6>
20003668:	68fb      	ldr	r3, [r7, #12]
2000366a:	2b1f      	cmp	r3, #31
2000366c:	d9ec      	bls.n	20003648 <fill_slave_tx_fifo+0xb0>
             */
            guard++;
        }
    }

}
2000366e:	f107 0714 	add.w	r7, r7, #20
20003672:	46bd      	mov	sp, r7
20003674:	bc80      	pop	{r7}
20003676:	4770      	bx	lr

20003678 <read_slave_rx_fifo>:
 */
static void read_slave_rx_fifo
(
    mss_spi_instance_t * this_spi
)
{
20003678:	b580      	push	{r7, lr}
2000367a:	b084      	sub	sp, #16
2000367c:	af00      	add	r7, sp, #0
2000367e:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
20003680:	687b      	ldr	r3, [r7, #4]
20003682:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20003686:	2b02      	cmp	r3, #2
20003688:	d115      	bne.n	200036b6 <read_slave_rx_fifo+0x3e>
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000368a:	e00c      	b.n	200036a6 <read_slave_rx_fifo+0x2e>
        {
            /* Single frame handling mode. */
            rx_frame = this_spi->hw_reg->RX_DATA;
2000368c:	687b      	ldr	r3, [r7, #4]
2000368e:	681b      	ldr	r3, [r3, #0]
20003690:	691b      	ldr	r3, [r3, #16]
20003692:	60fb      	str	r3, [r7, #12]
            if(0u != this_spi->frame_rx_handler)
20003694:	687b      	ldr	r3, [r7, #4]
20003696:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20003698:	2b00      	cmp	r3, #0
2000369a:	d004      	beq.n	200036a6 <read_slave_rx_fifo+0x2e>
            {
                this_spi->frame_rx_handler( rx_frame );
2000369c:	687b      	ldr	r3, [r7, #4]
2000369e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
200036a0:	68fa      	ldr	r2, [r7, #12]
200036a2:	4610      	mov	r0, r2
200036a4:	4798      	blx	r3
{
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
200036a6:	687b      	ldr	r3, [r7, #4]
200036a8:	681b      	ldr	r3, [r3, #0]
200036aa:	689b      	ldr	r3, [r3, #8]
200036ac:	f003 0340 	and.w	r3, r3, #64	; 0x40
200036b0:	2b00      	cmp	r3, #0
200036b2:	d0eb      	beq.n	2000368c <read_slave_rx_fifo+0x14>
200036b4:	e032      	b.n	2000371c <read_slave_rx_fifo+0xa4>
            {
                this_spi->frame_rx_handler( rx_frame );
            }
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
200036b6:	687b      	ldr	r3, [r7, #4]
200036b8:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
200036bc:	2b01      	cmp	r3, #1
200036be:	d125      	bne.n	2000370c <read_slave_rx_fifo+0x94>
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
200036c0:	e017      	b.n	200036f2 <read_slave_rx_fifo+0x7a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
200036c2:	687b      	ldr	r3, [r7, #4]
200036c4:	681b      	ldr	r3, [r3, #0]
200036c6:	691b      	ldr	r3, [r3, #16]
200036c8:	60fb      	str	r3, [r7, #12]
            if(this_spi->slave_rx_idx < this_spi->slave_rx_size)
200036ca:	687b      	ldr	r3, [r7, #4]
200036cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
200036ce:	687b      	ldr	r3, [r7, #4]
200036d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200036d2:	429a      	cmp	r2, r3
200036d4:	d207      	bcs.n	200036e6 <read_slave_rx_fifo+0x6e>
            {
                this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
200036d6:	687b      	ldr	r3, [r7, #4]
200036d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
200036da:	687b      	ldr	r3, [r7, #4]
200036dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200036de:	4413      	add	r3, r2
200036e0:	68fa      	ldr	r2, [r7, #12]
200036e2:	b2d2      	uxtb	r2, r2
200036e4:	701a      	strb	r2, [r3, #0]
            }

            ++this_spi->slave_rx_idx;
200036e6:	687b      	ldr	r3, [r7, #4]
200036e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200036ea:	f103 0201 	add.w	r2, r3, #1
200036ee:	687b      	ldr	r3, [r7, #4]
200036f0:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
200036f2:	687b      	ldr	r3, [r7, #4]
200036f4:	681b      	ldr	r3, [r3, #0]
200036f6:	689b      	ldr	r3, [r3, #8]
200036f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
200036fc:	2b00      	cmp	r3, #0
200036fe:	d0e0      	beq.n	200036c2 <read_slave_rx_fifo+0x4a>
20003700:	e00c      	b.n	2000371c <read_slave_rx_fifo+0xa4>
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
20003702:	687b      	ldr	r3, [r7, #4]
20003704:	681b      	ldr	r3, [r3, #0]
20003706:	691b      	ldr	r3, [r3, #16]
20003708:	60fb      	str	r3, [r7, #12]
2000370a:	e000      	b.n	2000370e <read_slave_rx_fifo+0x96>
        }
    }
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000370c:	bf00      	nop
2000370e:	687b      	ldr	r3, [r7, #4]
20003710:	681b      	ldr	r3, [r3, #0]
20003712:	689b      	ldr	r3, [r3, #8]
20003714:	f003 0340 	and.w	r3, r3, #64	; 0x40
20003718:	2b00      	cmp	r3, #0
2000371a:	d0f2      	beq.n	20003702 <read_slave_rx_fifo+0x8a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
        }
    }
}
2000371c:	f107 0710 	add.w	r7, r7, #16
20003720:	46bd      	mov	sp, r7
20003722:	bd80      	pop	{r7, pc}

20003724 <mss_spi_isr>:
 */
static void mss_spi_isr
(
    mss_spi_instance_t * this_spi
)
{    
20003724:	b580      	push	{r7, lr}
20003726:	b086      	sub	sp, #24
20003728:	af00      	add	r7, sp, #0
2000372a:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    __I  uint32_t *this_mis = &this_spi->hw_reg->MIS;
2000372c:	687b      	ldr	r3, [r7, #4]
2000372e:	681b      	ldr	r3, [r3, #0]
20003730:	f103 0320 	add.w	r3, r3, #32
20003734:	613b      	str	r3, [r7, #16]

    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20003736:	687a      	ldr	r2, [r7, #4]
20003738:	f248 53f8 	movw	r3, #34296	; 0x85f8
2000373c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003740:	429a      	cmp	r2, r3
20003742:	d007      	beq.n	20003754 <mss_spi_isr+0x30>
20003744:	687a      	ldr	r2, [r7, #4]
20003746:	f248 5374 	movw	r3, #34164	; 0x8574
2000374a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000374e:	429a      	cmp	r2, r3
20003750:	d000      	beq.n	20003754 <mss_spi_isr+0x30>
20003752:	be00      	bkpt	0x0000
  
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
20003754:	693b      	ldr	r3, [r7, #16]
20003756:	681b      	ldr	r3, [r3, #0]
20003758:	f003 0302 	and.w	r3, r3, #2
2000375c:	2b00      	cmp	r3, #0
2000375e:	d052      	beq.n	20003806 <mss_spi_isr+0xe2>
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
20003760:	687b      	ldr	r3, [r7, #4]
20003762:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20003766:	2b02      	cmp	r3, #2
20003768:	d115      	bne.n	20003796 <mss_spi_isr+0x72>
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000376a:	e00c      	b.n	20003786 <mss_spi_isr+0x62>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
2000376c:	687b      	ldr	r3, [r7, #4]
2000376e:	681b      	ldr	r3, [r3, #0]
20003770:	691b      	ldr	r3, [r3, #16]
20003772:	60fb      	str	r3, [r7, #12]
                if(0u != this_spi->frame_rx_handler)
20003774:	687b      	ldr	r3, [r7, #4]
20003776:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20003778:	2b00      	cmp	r3, #0
2000377a:	d004      	beq.n	20003786 <mss_spi_isr+0x62>
                {
                    this_spi->frame_rx_handler( rx_frame );
2000377c:	687b      	ldr	r3, [r7, #4]
2000377e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20003780:	68fa      	ldr	r2, [r7, #12]
20003782:	4610      	mov	r0, r2
20003784:	4798      	blx	r3
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
20003786:	687b      	ldr	r3, [r7, #4]
20003788:	681b      	ldr	r3, [r3, #0]
2000378a:	689b      	ldr	r3, [r3, #8]
2000378c:	f003 0340 	and.w	r3, r3, #64	; 0x40
20003790:	2b00      	cmp	r3, #0
20003792:	d0eb      	beq.n	2000376c <mss_spi_isr+0x48>
20003794:	e032      	b.n	200037fc <mss_spi_isr+0xd8>
                {
                    this_spi->frame_rx_handler( rx_frame );
                }
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
20003796:	687b      	ldr	r3, [r7, #4]
20003798:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
2000379c:	2b01      	cmp	r3, #1
2000379e:	d125      	bne.n	200037ec <mss_spi_isr+0xc8>
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
200037a0:	e017      	b.n	200037d2 <mss_spi_isr+0xae>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;                /* Read from FIFO irrespective */
200037a2:	687b      	ldr	r3, [r7, #4]
200037a4:	681b      	ldr	r3, [r3, #0]
200037a6:	691b      	ldr	r3, [r3, #16]
200037a8:	60fb      	str	r3, [r7, #12]
                if(this_spi->slave_rx_idx < this_spi->slave_rx_size) /* Write to array if required */
200037aa:	687b      	ldr	r3, [r7, #4]
200037ac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
200037ae:	687b      	ldr	r3, [r7, #4]
200037b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200037b2:	429a      	cmp	r2, r3
200037b4:	d207      	bcs.n	200037c6 <mss_spi_isr+0xa2>
                {
                    this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
200037b6:	687b      	ldr	r3, [r7, #4]
200037b8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
200037ba:	687b      	ldr	r3, [r7, #4]
200037bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200037be:	4413      	add	r3, r2
200037c0:	68fa      	ldr	r2, [r7, #12]
200037c2:	b2d2      	uxtb	r2, r2
200037c4:	701a      	strb	r2, [r3, #0]
                }

                ++this_spi->slave_rx_idx;            
200037c6:	687b      	ldr	r3, [r7, #4]
200037c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200037ca:	f103 0201 	add.w	r2, r3, #1
200037ce:	687b      	ldr	r3, [r7, #4]
200037d0:	631a      	str	r2, [r3, #48]	; 0x30
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
200037d2:	687b      	ldr	r3, [r7, #4]
200037d4:	681b      	ldr	r3, [r3, #0]
200037d6:	689b      	ldr	r3, [r3, #8]
200037d8:	f003 0340 	and.w	r3, r3, #64	; 0x40
200037dc:	2b00      	cmp	r3, #0
200037de:	d0e0      	beq.n	200037a2 <mss_spi_isr+0x7e>
200037e0:	e00c      	b.n	200037fc <mss_spi_isr+0xd8>
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
200037e2:	687b      	ldr	r3, [r7, #4]
200037e4:	681b      	ldr	r3, [r3, #0]
200037e6:	691b      	ldr	r3, [r3, #16]
200037e8:	60fb      	str	r3, [r7, #12]
200037ea:	e000      	b.n	200037ee <mss_spi_isr+0xca>
            }
        }
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
200037ec:	bf00      	nop
200037ee:	687b      	ldr	r3, [r7, #4]
200037f0:	681b      	ldr	r3, [r3, #0]
200037f2:	689b      	ldr	r3, [r3, #8]
200037f4:	f003 0340 	and.w	r3, r3, #64	; 0x40
200037f8:	2b00      	cmp	r3, #0
200037fa:	d0f2      	beq.n	200037e2 <mss_spi_isr+0xbe>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
            }
        }

        this_spi->hw_reg->INT_CLEAR = RXDONE_IRQ_MASK;
200037fc:	687b      	ldr	r3, [r7, #4]
200037fe:	681b      	ldr	r3, [r3, #0]
20003800:	f04f 0202 	mov.w	r2, #2
20003804:	60da      	str	r2, [r3, #12]
    }

   /* Handle transmit. */
    if(0u != (*this_mis & TXDONE_IRQ_MASK))
20003806:	693b      	ldr	r3, [r7, #16]
20003808:	681b      	ldr	r3, [r3, #0]
2000380a:	f003 0301 	and.w	r3, r3, #1
2000380e:	b2db      	uxtb	r3, r3
20003810:	2b00      	cmp	r3, #0
20003812:	d012      	beq.n	2000383a <mss_spi_isr+0x116>
    {
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
20003814:	687b      	ldr	r3, [r7, #4]
20003816:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
2000381a:	2b02      	cmp	r3, #2
2000381c:	d105      	bne.n	2000382a <mss_spi_isr+0x106>
        {
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
2000381e:	687b      	ldr	r3, [r7, #4]
20003820:	681b      	ldr	r3, [r3, #0]
20003822:	687a      	ldr	r2, [r7, #4]
20003824:	6f92      	ldr	r2, [r2, #120]	; 0x78
20003826:	615a      	str	r2, [r3, #20]
20003828:	e002      	b.n	20003830 <mss_spi_isr+0x10c>
        }
        else /* Must be block mode so load FIFO to the max */
        {
            fill_slave_tx_fifo(this_spi);
2000382a:	6878      	ldr	r0, [r7, #4]
2000382c:	f7ff feb4 	bl	20003598 <fill_slave_tx_fifo>
        }

        this_spi->hw_reg->INT_CLEAR = TXDONE_IRQ_MASK;
20003830:	687b      	ldr	r3, [r7, #4]
20003832:	681b      	ldr	r3, [r3, #0]
20003834:	f04f 0201 	mov.w	r2, #1
20003838:	60da      	str	r2, [r3, #12]
    }
    
    /* Handle command interrupt. */
    if(0u != (*this_mis & CMD_IRQ_MASK))
2000383a:	693b      	ldr	r3, [r7, #16]
2000383c:	681b      	ldr	r3, [r3, #0]
2000383e:	f003 0310 	and.w	r3, r3, #16
20003842:	2b00      	cmp	r3, #0
20003844:	d023      	beq.n	2000388e <mss_spi_isr+0x16a>
    {
        read_slave_rx_fifo(this_spi);
20003846:	6878      	ldr	r0, [r7, #4]
20003848:	f7ff ff16 	bl	20003678 <read_slave_rx_fifo>
        
        /*
         * Call the command handler if one exists.
         */
        if(0u != this_spi->cmd_handler)
2000384c:	687b      	ldr	r3, [r7, #4]
2000384e:	6a1b      	ldr	r3, [r3, #32]
20003850:	2b00      	cmp	r3, #0
20003852:	d00b      	beq.n	2000386c <mss_spi_isr+0x148>
        {
            (*this_spi->cmd_handler)(this_spi->slave_rx_buffer, this_spi->slave_rx_idx);
20003854:	687b      	ldr	r3, [r7, #4]
20003856:	6a1b      	ldr	r3, [r3, #32]
20003858:	687a      	ldr	r2, [r7, #4]
2000385a:	6a91      	ldr	r1, [r2, #40]	; 0x28
2000385c:	687a      	ldr	r2, [r7, #4]
2000385e:	6b12      	ldr	r2, [r2, #48]	; 0x30
20003860:	4608      	mov	r0, r1
20003862:	4611      	mov	r1, r2
20003864:	4798      	blx	r3
            fill_slave_tx_fifo(this_spi);
20003866:	6878      	ldr	r0, [r7, #4]
20003868:	f7ff fe96 	bl	20003598 <fill_slave_tx_fifo>
        }
        /* Set cmd_done to indicate it is now safe to 0 fill TX FIFO */
        this_spi->cmd_done = 1u;
2000386c:	687b      	ldr	r3, [r7, #4]
2000386e:	f04f 0201 	mov.w	r2, #1
20003872:	625a      	str	r2, [r3, #36]	; 0x24
        /* Disable command interrupt until slave select becomes de-asserted to avoid retriggering. */
        this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
20003874:	687b      	ldr	r3, [r7, #4]
20003876:	681b      	ldr	r3, [r3, #0]
20003878:	687a      	ldr	r2, [r7, #4]
2000387a:	6812      	ldr	r2, [r2, #0]
2000387c:	6a92      	ldr	r2, [r2, #40]	; 0x28
2000387e:	f022 0210 	bic.w	r2, r2, #16
20003882:	629a      	str	r2, [r3, #40]	; 0x28
        this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
20003884:	687b      	ldr	r3, [r7, #4]
20003886:	681b      	ldr	r3, [r3, #0]
20003888:	f04f 0210 	mov.w	r2, #16
2000388c:	60da      	str	r2, [r3, #12]
    }

    if(0u != (*this_mis & RXOVFLOW_IRQ_MASK))
2000388e:	693b      	ldr	r3, [r7, #16]
20003890:	681b      	ldr	r3, [r3, #0]
20003892:	f003 0304 	and.w	r3, r3, #4
20003896:	2b00      	cmp	r3, #0
20003898:	d00f      	beq.n	200038ba <mss_spi_isr+0x196>
    {
        /*
         * Receive overflow, not a lot we can do for this. Reset the receive
         *  FIFO, clear the interrupt and hope it doesn't happen again...
         */
        this_spi->hw_reg->COMMAND |= RX_FIFO_RESET_MASK;
2000389a:	687b      	ldr	r3, [r7, #4]
2000389c:	681b      	ldr	r3, [r3, #0]
2000389e:	687a      	ldr	r2, [r7, #4]
200038a0:	6812      	ldr	r2, [r2, #0]
200038a2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200038a4:	f042 0204 	orr.w	r2, r2, #4
200038a8:	62da      	str	r2, [r3, #44]	; 0x2c
        recover_from_rx_overflow(this_spi);
200038aa:	6878      	ldr	r0, [r7, #4]
200038ac:	f7ff fb3c 	bl	20002f28 <recover_from_rx_overflow>
        this_spi->hw_reg->INT_CLEAR = RXOVFLOW_IRQ_MASK;
200038b0:	687b      	ldr	r3, [r7, #4]
200038b2:	681b      	ldr	r3, [r3, #0]
200038b4:	f04f 0204 	mov.w	r2, #4
200038b8:	60da      	str	r2, [r3, #12]
     * slave TX FIFO data setup (if there is one).
     * In block mode this will probably not be very successful as we will
     * be out of synch with the master but the reset on SSEND will hopefully
     * take care of that for the next transfer.
     */
    if(0u != (*this_mis & TXURUN_IRQ_MASK))
200038ba:	693b      	ldr	r3, [r7, #16]
200038bc:	681b      	ldr	r3, [r3, #0]
200038be:	f003 0308 	and.w	r3, r3, #8
200038c2:	2b00      	cmp	r3, #0
200038c4:	d031      	beq.n	2000392a <mss_spi_isr+0x206>
    {
        this_spi->hw_reg->COMMAND |= TX_FIFO_RESET_MASK;
200038c6:	687b      	ldr	r3, [r7, #4]
200038c8:	681b      	ldr	r3, [r3, #0]
200038ca:	687a      	ldr	r2, [r7, #4]
200038cc:	6812      	ldr	r2, [r2, #0]
200038ce:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
200038d0:	f042 0208 	orr.w	r2, r2, #8
200038d4:	62da      	str	r2, [r3, #44]	; 0x2c
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
200038d6:	687b      	ldr	r3, [r7, #4]
200038d8:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
200038dc:	2b02      	cmp	r3, #2
200038de:	d113      	bne.n	20003908 <mss_spi_isr+0x1e4>
        {
            this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
200038e0:	687b      	ldr	r3, [r7, #4]
200038e2:	681a      	ldr	r2, [r3, #0]
200038e4:	687b      	ldr	r3, [r7, #4]
200038e6:	681b      	ldr	r3, [r3, #0]
200038e8:	6819      	ldr	r1, [r3, #0]
200038ea:	f240 03ff 	movw	r3, #255	; 0xff
200038ee:	f6cf 7300 	movt	r3, #65280	; 0xff00
200038f2:	ea01 0303 	and.w	r3, r1, r3
200038f6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200038fa:	6013      	str	r3, [r2, #0]
                                        | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
200038fc:	687b      	ldr	r3, [r7, #4]
200038fe:	681b      	ldr	r3, [r3, #0]
20003900:	687a      	ldr	r2, [r7, #4]
20003902:	6f92      	ldr	r2, [r2, #120]	; 0x78
20003904:	615a      	str	r2, [r3, #20]
20003906:	e00b      	b.n	20003920 <mss_spi_isr+0x1fc>
        }
        else if( MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode )
20003908:	687b      	ldr	r3, [r7, #4]
2000390a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
2000390e:	2b01      	cmp	r3, #1
20003910:	d106      	bne.n	20003920 <mss_spi_isr+0x1fc>
        {
            /* Block mode so reload FIFO to the max */
            this_spi->slave_tx_idx = 0u;
20003912:	687b      	ldr	r3, [r7, #4]
20003914:	f04f 0200 	mov.w	r2, #0
20003918:	611a      	str	r2, [r3, #16]
            fill_slave_tx_fifo(this_spi);
2000391a:	6878      	ldr	r0, [r7, #4]
2000391c:	f7ff fe3c 	bl	20003598 <fill_slave_tx_fifo>
        else
        {
            /* Not frame or block mode? Can't do anything here... */
        }

        this_spi->hw_reg->INT_CLEAR = TXURUN_IRQ_MASK;
20003920:	687b      	ldr	r3, [r7, #4]
20003922:	681b      	ldr	r3, [r3, #0]
20003924:	f04f 0208 	mov.w	r2, #8
20003928:	60da      	str	r2, [r3, #12]
    /*
     * Handle slave select becoming de-asserted. Only enables if
     * we are operating in block mode, in frame mode we do everything
     * in the receive and transmit interrupt handlers.
     */
    if(0u != (*this_mis & SSEND_IRQ_MASK))
2000392a:	693b      	ldr	r3, [r7, #16]
2000392c:	681b      	ldr	r3, [r3, #0]
2000392e:	f003 0320 	and.w	r3, r3, #32
20003932:	2b00      	cmp	r3, #0
20003934:	d049      	beq.n	200039ca <mss_spi_isr+0x2a6>
    {
        uint32_t rx_size;
        
        read_slave_rx_fifo(this_spi);
20003936:	6878      	ldr	r0, [r7, #4]
20003938:	f7ff fe9e 	bl	20003678 <read_slave_rx_fifo>
        rx_size = this_spi->slave_rx_idx;
2000393c:	687b      	ldr	r3, [r7, #4]
2000393e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003940:	617b      	str	r3, [r7, #20]
        /*
         * Re-enable command interrupt if required and clear all the response
         * buffer state in readiness for next response. This must be done
         * before reloading the TX FIFO.
         */
        if(0 != this_spi->cmd_handler)
20003942:	687b      	ldr	r3, [r7, #4]
20003944:	6a1b      	ldr	r3, [r3, #32]
20003946:	2b00      	cmp	r3, #0
20003948:	d01c      	beq.n	20003984 <mss_spi_isr+0x260>
        {
            this_spi->cmd_done = 0u;
2000394a:	687b      	ldr	r3, [r7, #4]
2000394c:	f04f 0200 	mov.w	r2, #0
20003950:	625a      	str	r2, [r3, #36]	; 0x24
            this_spi->resp_tx_buffer = 0u;
20003952:	687b      	ldr	r3, [r7, #4]
20003954:	f04f 0200 	mov.w	r2, #0
20003958:	615a      	str	r2, [r3, #20]
            this_spi->resp_buff_size = 0u;
2000395a:	687b      	ldr	r3, [r7, #4]
2000395c:	f04f 0200 	mov.w	r2, #0
20003960:	619a      	str	r2, [r3, #24]
            this_spi->resp_buff_tx_idx = 0u;
20003962:	687b      	ldr	r3, [r7, #4]
20003964:	f04f 0200 	mov.w	r2, #0
20003968:	61da      	str	r2, [r3, #28]
            this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
2000396a:	687b      	ldr	r3, [r7, #4]
2000396c:	681b      	ldr	r3, [r3, #0]
2000396e:	f04f 0210 	mov.w	r2, #16
20003972:	60da      	str	r2, [r3, #12]
            this_spi->hw_reg->CONTROL2 |= C2_ENABLE_CMD_IRQ_MASK;
20003974:	687b      	ldr	r3, [r7, #4]
20003976:	681b      	ldr	r3, [r3, #0]
20003978:	687a      	ldr	r2, [r7, #4]
2000397a:	6812      	ldr	r2, [r2, #0]
2000397c:	6a92      	ldr	r2, [r2, #40]	; 0x28
2000397e:	f042 0210 	orr.w	r2, r2, #16
20003982:	629a      	str	r2, [r3, #40]	; 0x28
        /* 
         * Reset the transmit index to 0 to restart transmit at the start of the
         * transmit buffer in the next transaction. This also requires flushing
         * the Tx FIFO and refilling it with the start of Tx data buffer.
         */
        this_spi->slave_tx_idx = 0u;
20003984:	687b      	ldr	r3, [r7, #4]
20003986:	f04f 0200 	mov.w	r2, #0
2000398a:	611a      	str	r2, [r3, #16]
        this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
2000398c:	687b      	ldr	r3, [r7, #4]
2000398e:	681b      	ldr	r3, [r3, #0]
20003990:	687a      	ldr	r2, [r7, #4]
20003992:	6812      	ldr	r2, [r2, #0]
20003994:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20003996:	f042 020c 	orr.w	r2, r2, #12
2000399a:	62da      	str	r2, [r3, #44]	; 0x2c
        fill_slave_tx_fifo(this_spi);
2000399c:	6878      	ldr	r0, [r7, #4]
2000399e:	f7ff fdfb 	bl	20003598 <fill_slave_tx_fifo>
        
        /* Prepare to receive next packet. */
        this_spi->slave_rx_idx = 0u;
200039a2:	687b      	ldr	r3, [r7, #4]
200039a4:	f04f 0200 	mov.w	r2, #0
200039a8:	631a      	str	r2, [r3, #48]	; 0x30
        /*
         * Call the receive handler if one exists.
         */
        if(0u != this_spi->block_rx_handler)
200039aa:	687b      	ldr	r3, [r7, #4]
200039ac:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
200039ae:	2b00      	cmp	r3, #0
200039b0:	d006      	beq.n	200039c0 <mss_spi_isr+0x29c>
        {
            (*this_spi->block_rx_handler)(this_spi->slave_rx_buffer, rx_size);
200039b2:	687b      	ldr	r3, [r7, #4]
200039b4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
200039b6:	687a      	ldr	r2, [r7, #4]
200039b8:	6a92      	ldr	r2, [r2, #40]	; 0x28
200039ba:	4610      	mov	r0, r2
200039bc:	6979      	ldr	r1, [r7, #20]
200039be:	4798      	blx	r3
        }
        
        this_spi->hw_reg->INT_CLEAR = SSEND_IRQ_MASK;
200039c0:	687b      	ldr	r3, [r7, #4]
200039c2:	681b      	ldr	r3, [r3, #0]
200039c4:	f04f 0220 	mov.w	r2, #32
200039c8:	60da      	str	r2, [r3, #12]
    }
}
200039ca:	f107 0718 	add.w	r7, r7, #24
200039ce:	46bd      	mov	sp, r7
200039d0:	bd80      	pop	{r7, pc}
200039d2:	bf00      	nop

200039d4 <SPI0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI0_IRQHandler(void)
#else
void SPI0_IRQHandler( void )
#endif
{
200039d4:	4668      	mov	r0, sp
200039d6:	f020 0107 	bic.w	r1, r0, #7
200039da:	468d      	mov	sp, r1
200039dc:	b589      	push	{r0, r3, r7, lr}
200039de:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi0);
200039e0:	f248 50f8 	movw	r0, #34296	; 0x85f8
200039e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200039e8:	f7ff fe9c 	bl	20003724 <mss_spi_isr>
}
200039ec:	46bd      	mov	sp, r7
200039ee:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
200039f2:	4685      	mov	sp, r0
200039f4:	4770      	bx	lr
200039f6:	bf00      	nop

200039f8 <SPI1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI1_IRQHandler(void)
#else
void SPI1_IRQHandler(void)
#endif
{
200039f8:	4668      	mov	r0, sp
200039fa:	f020 0107 	bic.w	r1, r0, #7
200039fe:	468d      	mov	sp, r1
20003a00:	b589      	push	{r0, r3, r7, lr}
20003a02:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi1);
20003a04:	f248 5074 	movw	r0, #34164	; 0x8574
20003a08:	f2c2 0000 	movt	r0, #8192	; 0x2000
20003a0c:	f7ff fe8a 	bl	20003724 <mss_spi_isr>
}
20003a10:	46bd      	mov	sp, r7
20003a12:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20003a16:	4685      	mov	sp, r0
20003a18:	4770      	bx	lr
20003a1a:	bf00      	nop

20003a1c <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
20003a1c:	b580      	push	{r7, lr}
20003a1e:	af00      	add	r7, sp, #0
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
#endif

    silicon_workarounds();
20003a20:	f000 f936 	bl	20003c90 <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
20003a24:	f64e 5300 	movw	r3, #60672	; 0xed00
20003a28:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003a2c:	f64e 5200 	movw	r2, #60672	; 0xed00
20003a30:	f2ce 0200 	movt	r2, #57344	; 0xe000
20003a34:	6952      	ldr	r2, [r2, #20]
20003a36:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20003a3a:	615a      	str	r2, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
20003a3c:	f7fc fcfa 	bl	20000434 <mscc_post_hw_cfg_init>
    do
    {
        init_done = CORE_SF2_CFG->INIT_DONE & INIT_DONE_MASK;
    } while (0u == init_done);
#endif
}
20003a40:	bd80      	pop	{r7, pc}
20003a42:	bf00      	nop

20003a44 <SystemCoreClockUpdate>:
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
20003a44:	b580      	push	{r7, lr}
20003a46:	b088      	sub	sp, #32
20003a48:	af00      	add	r7, sp, #0
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
20003a4a:	f248 0300 	movw	r3, #32768	; 0x8000
20003a4e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003a52:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20003a56:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
20003a5a:	60fb      	str	r3, [r7, #12]

    if(0u == controller_pll_init)
20003a5c:	68fb      	ldr	r3, [r7, #12]
20003a5e:	2b00      	cmp	r3, #0
20003a60:	f040 808b 	bne.w	20003b7a <SystemCoreClockUpdate+0x136>
    {
        /* Normal operations. */
        uint32_t global_mux_sel;

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
20003a64:	f248 0300 	movw	r3, #32768	; 0x8000
20003a68:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003a6c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20003a70:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20003a74:	617b      	str	r3, [r7, #20]
        if(0u == global_mux_sel)
20003a76:	697b      	ldr	r3, [r7, #20]
20003a78:	2b00      	cmp	r3, #0
20003a7a:	d13f      	bne.n	20003afc <SystemCoreClockUpdate+0xb8>
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
20003a7c:	f245 132c 	movw	r3, #20780	; 0x512c
20003a80:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003a84:	f24f 0280 	movw	r2, #61568	; 0xf080
20003a88:	f2c0 22fa 	movt	r2, #762	; 0x2fa
20003a8c:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
20003a8e:	f245 1330 	movw	r3, #20784	; 0x5130
20003a92:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003a96:	f24f 0280 	movw	r2, #61568	; 0xf080
20003a9a:	f2c0 22fa 	movt	r2, #762	; 0x2fa
20003a9e:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
20003aa0:	f245 1334 	movw	r3, #20788	; 0x5134
20003aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003aa8:	f24f 0280 	movw	r2, #61568	; 0xf080
20003aac:	f2c0 22fa 	movt	r2, #762	; 0x2fa
20003ab0:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
20003ab2:	f245 1338 	movw	r3, #20792	; 0x5138
20003ab6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003aba:	f64b 4220 	movw	r2, #48160	; 0xbc20
20003abe:	f2c0 02be 	movt	r2, #190	; 0xbe
20003ac2:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
20003ac4:	f245 133c 	movw	r3, #20796	; 0x513c
20003ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003acc:	f24f 0280 	movw	r2, #61568	; 0xf080
20003ad0:	f2c0 22fa 	movt	r2, #762	; 0x2fa
20003ad4:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
20003ad6:	f245 1340 	movw	r3, #20800	; 0x5140
20003ada:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003ade:	f24f 0280 	movw	r2, #61568	; 0xf080
20003ae2:	f2c0 22fa 	movt	r2, #762	; 0x2fa
20003ae6:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
20003ae8:	f245 1344 	movw	r3, #20804	; 0x5144
20003aec:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003af0:	f24f 0280 	movw	r2, #61568	; 0xf080
20003af4:	f2c0 22fa 	movt	r2, #762	; 0x2fa
20003af8:	601a      	str	r2, [r3, #0]
                break;

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
20003afa:	e045      	b.n	20003b88 <SystemCoreClockUpdate+0x144>
                                                   RCOSC_25_50MHZ_CLK_SRC,
                                                   CLK_XTAL_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC };
20003afc:	f644 73c8 	movw	r3, #20424	; 0x4fc8
20003b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003b04:	f107 0204 	add.w	r2, r7, #4
20003b08:	e893 0003 	ldmia.w	r3, {r0, r1}
20003b0c:	e882 0003 	stmia.w	r2, {r0, r1}

            uint32_t standby_sel;
            uint8_t clock_source;

            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
20003b10:	f248 0300 	movw	r3, #32768	; 0x8000
20003b14:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003b18:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20003b1c:	ea4f 1393 	mov.w	r3, r3, lsr #6
20003b20:	f003 0307 	and.w	r3, r3, #7
20003b24:	61bb      	str	r3, [r7, #24]
            clock_source = standby_clock_lut[standby_sel];
20003b26:	69bb      	ldr	r3, [r7, #24]
20003b28:	f107 0220 	add.w	r2, r7, #32
20003b2c:	4413      	add	r3, r2
20003b2e:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
20003b32:	77fb      	strb	r3, [r7, #31]
            switch(clock_source)
20003b34:	7ffb      	ldrb	r3, [r7, #31]
20003b36:	2b01      	cmp	r3, #1
20003b38:	d00b      	beq.n	20003b52 <SystemCoreClockUpdate+0x10e>
20003b3a:	2b02      	cmp	r3, #2
20003b3c:	d00e      	beq.n	20003b5c <SystemCoreClockUpdate+0x118>
20003b3e:	2b00      	cmp	r3, #0
20003b40:	d114      	bne.n	20003b6c <SystemCoreClockUpdate+0x128>
            {
                case RCOSC_25_50MHZ_CLK_SRC:
                    clk_src = get_rcosc_25_50mhz_frequency();
20003b42:	f000 f825 	bl	20003b90 <get_rcosc_25_50mhz_frequency>
20003b46:	4603      	mov	r3, r0
20003b48:	613b      	str	r3, [r7, #16]
                    set_clock_frequency_globals(clk_src);
20003b4a:	6938      	ldr	r0, [r7, #16]
20003b4c:	f000 f842 	bl	20003bd4 <set_clock_frequency_globals>
                break;
20003b50:	e01a      	b.n	20003b88 <SystemCoreClockUpdate+0x144>

                case CLK_XTAL_CLK_SRC:
                    set_clock_frequency_globals(FREQ_32KHZ);
20003b52:	f44f 4000 	mov.w	r0, #32768	; 0x8000
20003b56:	f000 f83d 	bl	20003bd4 <set_clock_frequency_globals>
                break;
20003b5a:	e015      	b.n	20003b88 <SystemCoreClockUpdate+0x144>

                case RCOSC_1_MHZ_CLK_SRC:
                    set_clock_frequency_globals(FREQ_1MHZ);
20003b5c:	f244 2040 	movw	r0, #16960	; 0x4240
20003b60:	f2c0 000f 	movt	r0, #15
20003b64:	f000 f836 	bl	20003bd4 <set_clock_frequency_globals>
                break;
20003b68:	bf00      	nop
20003b6a:	e00d      	b.n	20003b88 <SystemCoreClockUpdate+0x144>

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
20003b6c:	f244 2040 	movw	r0, #16960	; 0x4240
20003b70:	f2c0 000f 	movt	r0, #15
20003b74:	f000 f82e 	bl	20003bd4 <set_clock_frequency_globals>
20003b78:	e006      	b.n	20003b88 <SystemCoreClockUpdate+0x144>
        }
    }
    else
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
20003b7a:	f000 f809 	bl	20003b90 <get_rcosc_25_50mhz_frequency>
20003b7e:	4603      	mov	r3, r0
20003b80:	613b      	str	r3, [r7, #16]
        set_clock_frequency_globals(clk_src);
20003b82:	6938      	ldr	r0, [r7, #16]
20003b84:	f000 f826 	bl	20003bd4 <set_clock_frequency_globals>
    }
}
20003b88:	f107 0720 	add.w	r7, r7, #32
20003b8c:	46bd      	mov	sp, r7
20003b8e:	bd80      	pop	{r7, pc}

20003b90 <get_rcosc_25_50mhz_frequency>:

/***************************************************************************//**
 * Find out frequency generated by the 25_50mhz RC osciallator.
 */
static uint32_t get_rcosc_25_50mhz_frequency(void)
{
20003b90:	b480      	push	{r7}
20003b92:	b083      	sub	sp, #12
20003b94:	af00      	add	r7, sp, #0
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;

    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
20003b96:	f248 0300 	movw	r3, #32768	; 0x8000
20003b9a:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003b9e:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
20003ba2:	f003 0304 	and.w	r3, r3, #4
20003ba6:	603b      	str	r3, [r7, #0]
    if(0u == rcosc_div2)
20003ba8:	683b      	ldr	r3, [r7, #0]
20003baa:	2b00      	cmp	r3, #0
20003bac:	d105      	bne.n	20003bba <get_rcosc_25_50mhz_frequency+0x2a>
    {
        /* 25_50mhz oscillator is configured for 25 MHz operations. */
        rcosc_frequency = FREQ_25MHZ;
20003bae:	f647 0340 	movw	r3, #30784	; 0x7840
20003bb2:	f2c0 137d 	movt	r3, #381	; 0x17d
20003bb6:	607b      	str	r3, [r7, #4]
20003bb8:	e004      	b.n	20003bc4 <get_rcosc_25_50mhz_frequency+0x34>
    }
    else
    {
        /* 25_50mhz oscillator is configured for 50 MHz operations. */
        rcosc_frequency = FREQ_50MHZ;
20003bba:	f24f 0380 	movw	r3, #61568	; 0xf080
20003bbe:	f2c0 23fa 	movt	r3, #762	; 0x2fa
20003bc2:	607b      	str	r3, [r7, #4]
    }

    return rcosc_frequency;
20003bc4:	687b      	ldr	r3, [r7, #4]
}
20003bc6:	4618      	mov	r0, r3
20003bc8:	f107 070c 	add.w	r7, r7, #12
20003bcc:	46bd      	mov	sp, r7
20003bce:	bc80      	pop	{r7}
20003bd0:	4770      	bx	lr
20003bd2:	bf00      	nop

20003bd4 <set_clock_frequency_globals>:
        - g_FrequencyFIC0
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
20003bd4:	b480      	push	{r7}
20003bd6:	b083      	sub	sp, #12
20003bd8:	af00      	add	r7, sp, #0
20003bda:	6078      	str	r0, [r7, #4]
    SystemCoreClock = standby_clk;
20003bdc:	f245 132c 	movw	r3, #20780	; 0x512c
20003be0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003be4:	687a      	ldr	r2, [r7, #4]
20003be6:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = standby_clk;
20003be8:	f245 1330 	movw	r3, #20784	; 0x5130
20003bec:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003bf0:	687a      	ldr	r2, [r7, #4]
20003bf2:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = standby_clk;
20003bf4:	f245 1334 	movw	r3, #20788	; 0x5134
20003bf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003bfc:	687a      	ldr	r2, [r7, #4]
20003bfe:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
20003c00:	f245 1338 	movw	r3, #20792	; 0x5138
20003c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003c08:	f64b 4220 	movw	r2, #48160	; 0xbc20
20003c0c:	f2c0 02be 	movt	r2, #190	; 0xbe
20003c10:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC0 = standby_clk;
20003c12:	f245 133c 	movw	r3, #20796	; 0x513c
20003c16:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003c1a:	687a      	ldr	r2, [r7, #4]
20003c1c:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC1 = standby_clk;
20003c1e:	f245 1340 	movw	r3, #20800	; 0x5140
20003c22:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003c26:	687a      	ldr	r2, [r7, #4]
20003c28:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC64 = standby_clk;
20003c2a:	f245 1344 	movw	r3, #20804	; 0x5144
20003c2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003c32:	687a      	ldr	r2, [r7, #4]
20003c34:	601a      	str	r2, [r3, #0]
}
20003c36:	f107 070c 	add.w	r7, r7, #12
20003c3a:	46bd      	mov	sp, r7
20003c3c:	bc80      	pop	{r7}
20003c3e:	4770      	bx	lr

20003c40 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
20003c40:	b480      	push	{r7}
20003c42:	b083      	sub	sp, #12
20003c44:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;

    device_version = SYSREG->DEVICE_VERSION;
20003c46:	f248 0300 	movw	r3, #32768	; 0x8000
20003c4a:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003c4e:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
20003c52:	607b      	str	r3, [r7, #4]
    switch(device_version)
20003c54:	687a      	ldr	r2, [r7, #4]
20003c56:	f64f 0302 	movw	r3, #63490	; 0xf802
20003c5a:	429a      	cmp	r2, r3
20003c5c:	d006      	beq.n	20003c6c <get_silicon_revision+0x2c>
20003c5e:	f64f 0302 	movw	r3, #63490	; 0xf802
20003c62:	f2c0 0301 	movt	r3, #1
20003c66:	429a      	cmp	r2, r3
20003c68:	d004      	beq.n	20003c74 <get_silicon_revision+0x34>
20003c6a:	e007      	b.n	20003c7c <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
20003c6c:	f04f 0301 	mov.w	r3, #1
20003c70:	603b      	str	r3, [r7, #0]
            break;
20003c72:	e006      	b.n	20003c82 <get_silicon_revision+0x42>

        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
20003c74:	f04f 0302 	mov.w	r3, #2
20003c78:	603b      	str	r3, [r7, #0]
            break;
20003c7a:	e002      	b.n	20003c82 <get_silicon_revision+0x42>

        default:
            silicon_revision = UNKNOWN_SILICON_REV;
20003c7c:	f04f 0300 	mov.w	r3, #0
20003c80:	603b      	str	r3, [r7, #0]
            break;
    }

    return silicon_revision;
20003c82:	683b      	ldr	r3, [r7, #0]
}
20003c84:	4618      	mov	r0, r3
20003c86:	f107 070c 	add.w	r7, r7, #12
20003c8a:	46bd      	mov	sp, r7
20003c8c:	bc80      	pop	{r7}
20003c8e:	4770      	bx	lr

20003c90 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
20003c90:	b580      	push	{r7, lr}
20003c92:	b082      	sub	sp, #8
20003c94:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;

    silicon_revision = get_silicon_revision();
20003c96:	f7ff ffd3 	bl	20003c40 <get_silicon_revision>
20003c9a:	4603      	mov	r3, r0
20003c9c:	607b      	str	r3, [r7, #4]

    switch(silicon_revision)
20003c9e:	687b      	ldr	r3, [r7, #4]
20003ca0:	2b01      	cmp	r3, #1
20003ca2:	d101      	bne.n	20003ca8 <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
20003ca4:	f000 f804 	bl	20003cb0 <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
20003ca8:	f107 0708 	add.w	r7, r7, #8
20003cac:	46bd      	mov	sp, r7
20003cae:	bd80      	pop	{r7, pc}

20003cb0 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
20003cb0:	b480      	push	{r7}
20003cb2:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
20003cb4:	f248 0300 	movw	r3, #32768	; 0x8000
20003cb8:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003cbc:	f248 0200 	movw	r2, #32768	; 0x8000
20003cc0:	f2c4 0203 	movt	r2, #16387	; 0x4003
20003cc4:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20003cc8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20003ccc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
20003cd0:	f248 0300 	movw	r3, #32768	; 0x8000
20003cd4:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003cd8:	f248 0200 	movw	r2, #32768	; 0x8000
20003cdc:	f2c4 0203 	movt	r2, #16387	; 0x4003
20003ce0:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20003ce4:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
20003ce8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
20003cec:	46bd      	mov	sp, r7
20003cee:	bc80      	pop	{r7}
20003cf0:	4770      	bx	lr
20003cf2:	bf00      	nop

20003cf4 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20003cf4:	b480      	push	{r7}
20003cf6:	b083      	sub	sp, #12
20003cf8:	af00      	add	r7, sp, #0
20003cfa:	4603      	mov	r3, r0
20003cfc:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20003cfe:	f24e 1300 	movw	r3, #57600	; 0xe100
20003d02:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003d06:	f997 2007 	ldrsb.w	r2, [r7, #7]
20003d0a:	ea4f 1252 	mov.w	r2, r2, lsr #5
20003d0e:	79f9      	ldrb	r1, [r7, #7]
20003d10:	f001 011f 	and.w	r1, r1, #31
20003d14:	f04f 0001 	mov.w	r0, #1
20003d18:	fa00 f101 	lsl.w	r1, r0, r1
20003d1c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20003d20:	f107 070c 	add.w	r7, r7, #12
20003d24:	46bd      	mov	sp, r7
20003d26:	bc80      	pop	{r7}
20003d28:	4770      	bx	lr
20003d2a:	bf00      	nop

20003d2c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20003d2c:	b480      	push	{r7}
20003d2e:	b083      	sub	sp, #12
20003d30:	af00      	add	r7, sp, #0
20003d32:	4603      	mov	r3, r0
20003d34:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20003d36:	f24e 1300 	movw	r3, #57600	; 0xe100
20003d3a:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003d3e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20003d42:	ea4f 1252 	mov.w	r2, r2, lsr #5
20003d46:	79f9      	ldrb	r1, [r7, #7]
20003d48:	f001 011f 	and.w	r1, r1, #31
20003d4c:	f04f 0001 	mov.w	r0, #1
20003d50:	fa00 f101 	lsl.w	r1, r0, r1
20003d54:	f102 0220 	add.w	r2, r2, #32
20003d58:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20003d5c:	f107 070c 	add.w	r7, r7, #12
20003d60:	46bd      	mov	sp, r7
20003d62:	bc80      	pop	{r7}
20003d64:	4770      	bx	lr
20003d66:	bf00      	nop

20003d68 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20003d68:	b480      	push	{r7}
20003d6a:	b083      	sub	sp, #12
20003d6c:	af00      	add	r7, sp, #0
20003d6e:	4603      	mov	r3, r0
20003d70:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20003d72:	f24e 1300 	movw	r3, #57600	; 0xe100
20003d76:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003d7a:	f997 2007 	ldrsb.w	r2, [r7, #7]
20003d7e:	ea4f 1252 	mov.w	r2, r2, lsr #5
20003d82:	79f9      	ldrb	r1, [r7, #7]
20003d84:	f001 011f 	and.w	r1, r1, #31
20003d88:	f04f 0001 	mov.w	r0, #1
20003d8c:	fa00 f101 	lsl.w	r1, r0, r1
20003d90:	f102 0260 	add.w	r2, r2, #96	; 0x60
20003d94:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20003d98:	f107 070c 	add.w	r7, r7, #12
20003d9c:	46bd      	mov	sp, r7
20003d9e:	bc80      	pop	{r7}
20003da0:	4770      	bx	lr
20003da2:	bf00      	nop

20003da4 <MSS_COMBLK_init>:
void MSS_COMBLK_init
(
    comblk_async_event_handler_t async_event_handler,
    uint8_t* p_response
)
{
20003da4:	b580      	push	{r7, lr}
20003da6:	b082      	sub	sp, #8
20003da8:	af00      	add	r7, sp, #0
20003daa:	6078      	str	r0, [r7, #4]
20003dac:	6039      	str	r1, [r7, #0]
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
20003dae:	f04f 0013 	mov.w	r0, #19
20003db2:	f7ff ffbb 	bl	20003d2c <NVIC_DisableIRQ>
    COMBLK->INT_ENABLE = 0u;
20003db6:	f246 0300 	movw	r3, #24576	; 0x6000
20003dba:	f2c4 0301 	movt	r3, #16385	; 0x4001
20003dbe:	f04f 0200 	mov.w	r2, #0
20003dc2:	609a      	str	r2, [r3, #8]
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
20003dc4:	f04f 0013 	mov.w	r0, #19
20003dc8:	f7ff ffce 	bl	20003d68 <NVIC_ClearPendingIRQ>
    
    g_async_event_handler = async_event_handler;
20003dcc:	f245 23c4 	movw	r3, #21188	; 0x52c4
20003dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003dd4:	687a      	ldr	r2, [r7, #4]
20003dd6:	601a      	str	r2, [r3, #0]
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 0u;
20003dd8:	f245 23c0 	movw	r3, #21184	; 0x52c0
20003ddc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003de0:	f04f 0200 	mov.w	r2, #0
20003de4:	701a      	strb	r2, [r3, #0]
    g_comblk_cmd_opcode = 0u;
20003de6:	f245 239d 	movw	r3, #21149	; 0x529d
20003dea:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003dee:	f04f 0200 	mov.w	r2, #0
20003df2:	701a      	strb	r2, [r3, #0]
    g_comblk_p_cmd = 0u;
20003df4:	f245 23a0 	movw	r3, #21152	; 0x52a0
20003df8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003dfc:	f04f 0200 	mov.w	r2, #0
20003e00:	601a      	str	r2, [r3, #0]
    g_comblk_cmd_size = 0u;
20003e02:	f245 23a4 	movw	r3, #21156	; 0x52a4
20003e06:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003e0a:	f04f 0200 	mov.w	r2, #0
20003e0e:	801a      	strh	r2, [r3, #0]
    g_comblk_p_data = 0u;
20003e10:	f245 23a8 	movw	r3, #21160	; 0x52a8
20003e14:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003e18:	f04f 0200 	mov.w	r2, #0
20003e1c:	601a      	str	r2, [r3, #0]
    g_comblk_data_size = 0u;
20003e1e:	f245 23ac 	movw	r3, #21164	; 0x52ac
20003e22:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003e26:	f04f 0200 	mov.w	r2, #0
20003e2a:	601a      	str	r2, [r3, #0]
    g_comblk_p_response = p_response;
20003e2c:	f245 23b0 	movw	r3, #21168	; 0x52b0
20003e30:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003e34:	683a      	ldr	r2, [r7, #0]
20003e36:	601a      	str	r2, [r3, #0]
    g_comblk_response_size = 0u;
20003e38:	f245 23b4 	movw	r3, #21172	; 0x52b4
20003e3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003e40:	f04f 0200 	mov.w	r2, #0
20003e44:	801a      	strh	r2, [r3, #0]
    g_comblk_response_idx = 0u;
20003e46:	f245 23b6 	movw	r3, #21174	; 0x52b6
20003e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003e4e:	f04f 0200 	mov.w	r2, #0
20003e52:	801a      	strh	r2, [r3, #0]
    g_comblk_completion_handler = 0;
20003e54:	f245 23b8 	movw	r3, #21176	; 0x52b8
20003e58:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003e5c:	f04f 0200 	mov.w	r2, #0
20003e60:	601a      	str	r2, [r3, #0]
    
    g_comblk_state = COMBLK_IDLE;
20003e62:	f245 23c1 	movw	r3, #21185	; 0x52c1
20003e66:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003e6a:	f04f 0200 	mov.w	r2, #0
20003e6e:	701a      	strb	r2, [r3, #0]
    /*
     * Disable loopback before enabling the MSS COMM_BLK to ensure that any
     * codes waiting in the TX FIFO of the System Controllers COMM_BLK are
     * not lost.
     */
    COMBLK->CONTROL &= ~CR_LOOPBACK_MASK;
20003e70:	f246 0300 	movw	r3, #24576	; 0x6000
20003e74:	f2c4 0301 	movt	r3, #16385	; 0x4001
20003e78:	f246 0200 	movw	r2, #24576	; 0x6000
20003e7c:	f2c4 0201 	movt	r2, #16385	; 0x4001
20003e80:	6812      	ldr	r2, [r2, #0]
20003e82:	f022 0220 	bic.w	r2, r2, #32
20003e86:	601a      	str	r2, [r3, #0]
    COMBLK->CONTROL |= CR_ENABLE_MASK;
20003e88:	f246 0300 	movw	r3, #24576	; 0x6000
20003e8c:	f2c4 0301 	movt	r3, #16385	; 0x4001
20003e90:	f246 0200 	movw	r2, #24576	; 0x6000
20003e94:	f2c4 0201 	movt	r2, #16385	; 0x4001
20003e98:	6812      	ldr	r2, [r2, #0]
20003e9a:	f042 0210 	orr.w	r2, r2, #16
20003e9e:	601a      	str	r2, [r3, #0]
    
    /*--------------------------------------------------------------------------
     * Enable receive interrupt to receive asynchronous events from the system
     * controller.
     */
    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
20003ea0:	f246 0300 	movw	r3, #24576	; 0x6000
20003ea4:	f2c4 0301 	movt	r3, #16385	; 0x4001
20003ea8:	f246 0200 	movw	r2, #24576	; 0x6000
20003eac:	f2c4 0201 	movt	r2, #16385	; 0x4001
20003eb0:	6892      	ldr	r2, [r2, #8]
20003eb2:	f022 0201 	bic.w	r2, r2, #1
20003eb6:	609a      	str	r2, [r3, #8]
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
20003eb8:	f246 0300 	movw	r3, #24576	; 0x6000
20003ebc:	f2c4 0301 	movt	r3, #16385	; 0x4001
20003ec0:	f246 0200 	movw	r2, #24576	; 0x6000
20003ec4:	f2c4 0201 	movt	r2, #16385	; 0x4001
20003ec8:	6892      	ldr	r2, [r2, #8]
20003eca:	f042 0202 	orr.w	r2, r2, #2
20003ece:	609a      	str	r2, [r3, #8]
    NVIC_EnableIRQ(ComBlk_IRQn);
20003ed0:	f04f 0013 	mov.w	r0, #19
20003ed4:	f7ff ff0e 	bl	20003cf4 <NVIC_EnableIRQ>
}
20003ed8:	f107 0708 	add.w	r7, r7, #8
20003edc:	46bd      	mov	sp, r7
20003ede:	bd80      	pop	{r7, pc}

20003ee0 <MSS_COMBLK_send_cmd>:
    uint32_t data_size,
    uint8_t * p_response,
    uint16_t response_size,
    comblk_completion_handler_t completion_handler
)
{
20003ee0:	b580      	push	{r7, lr}
20003ee2:	b086      	sub	sp, #24
20003ee4:	af00      	add	r7, sp, #0
20003ee6:	60f8      	str	r0, [r7, #12]
20003ee8:	607a      	str	r2, [r7, #4]
20003eea:	603b      	str	r3, [r7, #0]
20003eec:	460b      	mov	r3, r1
20003eee:	817b      	strh	r3, [r7, #10]
    uint32_t size_sent;
    
    ASSERT(cmd_size > 0);
20003ef0:	897b      	ldrh	r3, [r7, #10]
20003ef2:	2b00      	cmp	r3, #0
20003ef4:	d100      	bne.n	20003ef8 <MSS_COMBLK_send_cmd+0x18>
20003ef6:	be00      	bkpt	0x0000
    
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
20003ef8:	f04f 0013 	mov.w	r0, #19
20003efc:	f7ff ff16 	bl	20003d2c <NVIC_DisableIRQ>
    COMBLK->INT_ENABLE = 0u;
20003f00:	f246 0300 	movw	r3, #24576	; 0x6000
20003f04:	f2c4 0301 	movt	r3, #16385	; 0x4001
20003f08:	f04f 0200 	mov.w	r2, #0
20003f0c:	609a      	str	r2, [r3, #8]
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
20003f0e:	f04f 0013 	mov.w	r0, #19
20003f12:	f7ff ff29 	bl	20003d68 <NVIC_ClearPendingIRQ>
    
    /*
     * Abort current command if any.
     */
    abort_current_cmd();
20003f16:	f000 fcbf 	bl	20004898 <abort_current_cmd>
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
20003f1a:	f245 23c0 	movw	r3, #21184	; 0x52c0
20003f1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f22:	f04f 0201 	mov.w	r2, #1
20003f26:	701a      	strb	r2, [r3, #0]
    g_comblk_cmd_opcode = p_cmd[0];
20003f28:	68fb      	ldr	r3, [r7, #12]
20003f2a:	781a      	ldrb	r2, [r3, #0]
20003f2c:	f245 239d 	movw	r3, #21149	; 0x529d
20003f30:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f34:	701a      	strb	r2, [r3, #0]
    g_comblk_p_cmd = p_cmd;
20003f36:	f245 23a0 	movw	r3, #21152	; 0x52a0
20003f3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f3e:	68fa      	ldr	r2, [r7, #12]
20003f40:	601a      	str	r2, [r3, #0]
    g_comblk_cmd_size = cmd_size;
20003f42:	f245 23a4 	movw	r3, #21156	; 0x52a4
20003f46:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f4a:	897a      	ldrh	r2, [r7, #10]
20003f4c:	801a      	strh	r2, [r3, #0]
    g_comblk_p_data = p_data;
20003f4e:	f245 23a8 	movw	r3, #21160	; 0x52a8
20003f52:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f56:	687a      	ldr	r2, [r7, #4]
20003f58:	601a      	str	r2, [r3, #0]
    g_comblk_data_size = data_size;
20003f5a:	f245 23ac 	movw	r3, #21164	; 0x52ac
20003f5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f62:	683a      	ldr	r2, [r7, #0]
20003f64:	601a      	str	r2, [r3, #0]
    g_comblk_p_response = p_response;
20003f66:	f245 23b0 	movw	r3, #21168	; 0x52b0
20003f6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f6e:	6a3a      	ldr	r2, [r7, #32]
20003f70:	601a      	str	r2, [r3, #0]
    g_comblk_response_size = response_size;
20003f72:	f245 23b4 	movw	r3, #21172	; 0x52b4
20003f76:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f7a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
20003f7c:	801a      	strh	r2, [r3, #0]
    g_comblk_response_idx = 0u;
20003f7e:	f245 23b6 	movw	r3, #21174	; 0x52b6
20003f82:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f86:	f04f 0200 	mov.w	r2, #0
20003f8a:	801a      	strh	r2, [r3, #0]
    g_comblk_page_handler = 0u;
20003f8c:	f245 23bc 	movw	r3, #21180	; 0x52bc
20003f90:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003f94:	f04f 0200 	mov.w	r2, #0
20003f98:	601a      	str	r2, [r3, #0]
    g_comblk_completion_handler = completion_handler;
20003f9a:	f245 23b8 	movw	r3, #21176	; 0x52b8
20003f9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003fa2:	6aba      	ldr	r2, [r7, #40]	; 0x28
20003fa4:	601a      	str	r2, [r3, #0]
    
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
20003fa6:	f246 0300 	movw	r3, #24576	; 0x6000
20003faa:	f2c4 0301 	movt	r3, #16385	; 0x4001
20003fae:	f246 0200 	movw	r2, #24576	; 0x6000
20003fb2:	f2c4 0201 	movt	r2, #16385	; 0x4001
20003fb6:	6892      	ldr	r2, [r2, #8]
20003fb8:	f042 0202 	orr.w	r2, r2, #2
20003fbc:	609a      	str	r2, [r3, #8]

    /*
     * Fill FIFO with command.
     */
    send_cmd_opcode(g_comblk_cmd_opcode);
20003fbe:	f245 239d 	movw	r3, #21149	; 0x529d
20003fc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003fc6:	781b      	ldrb	r3, [r3, #0]
20003fc8:	b2db      	uxtb	r3, r3
20003fca:	4618      	mov	r0, r3
20003fcc:	f000 fc94 	bl	200048f8 <send_cmd_opcode>
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
20003fd0:	68fb      	ldr	r3, [r7, #12]
20003fd2:	f103 0201 	add.w	r2, r3, #1
20003fd6:	897b      	ldrh	r3, [r7, #10]
20003fd8:	f103 33ff 	add.w	r3, r3, #4294967295
20003fdc:	4610      	mov	r0, r2
20003fde:	4619      	mov	r1, r3
20003fe0:	f000 fcb2 	bl	20004948 <fill_tx_fifo>
20003fe4:	4603      	mov	r3, r0
20003fe6:	617b      	str	r3, [r7, #20]
    ++size_sent;    /* Adjust for opcode byte sent. */
20003fe8:	697b      	ldr	r3, [r7, #20]
20003fea:	f103 0301 	add.w	r3, r3, #1
20003fee:	617b      	str	r3, [r7, #20]
    if(size_sent < cmd_size)
20003ff0:	897a      	ldrh	r2, [r7, #10]
20003ff2:	697b      	ldr	r3, [r7, #20]
20003ff4:	429a      	cmp	r2, r3
20003ff6:	d923      	bls.n	20004040 <MSS_COMBLK_send_cmd+0x160>
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
20003ff8:	f245 23a4 	movw	r3, #21156	; 0x52a4
20003ffc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004000:	881b      	ldrh	r3, [r3, #0]
20004002:	b29a      	uxth	r2, r3
20004004:	697b      	ldr	r3, [r7, #20]
20004006:	b29b      	uxth	r3, r3
20004008:	ebc3 0302 	rsb	r3, r3, r2
2000400c:	b29a      	uxth	r2, r3
2000400e:	f245 23a4 	movw	r3, #21156	; 0x52a4
20004012:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004016:	801a      	strh	r2, [r3, #0]
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
20004018:	f245 23a0 	movw	r3, #21152	; 0x52a0
2000401c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004020:	681a      	ldr	r2, [r3, #0]
20004022:	697b      	ldr	r3, [r7, #20]
20004024:	441a      	add	r2, r3
20004026:	f245 23a0 	movw	r3, #21152	; 0x52a0
2000402a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000402e:	601a      	str	r2, [r3, #0]
        
        g_comblk_state = COMBLK_TX_CMD;
20004030:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004034:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004038:	f04f 0201 	mov.w	r2, #1
2000403c:	701a      	strb	r2, [r3, #0]
2000403e:	e01c      	b.n	2000407a <MSS_COMBLK_send_cmd+0x19a>
    }
    else
    {
        g_comblk_cmd_size = 0u;
20004040:	f245 23a4 	movw	r3, #21156	; 0x52a4
20004044:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004048:	f04f 0200 	mov.w	r2, #0
2000404c:	801a      	strh	r2, [r3, #0]
        if(g_comblk_data_size > 0u)
2000404e:	f245 23ac 	movw	r3, #21164	; 0x52ac
20004052:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004056:	681b      	ldr	r3, [r3, #0]
20004058:	2b00      	cmp	r3, #0
2000405a:	d007      	beq.n	2000406c <MSS_COMBLK_send_cmd+0x18c>
        {
            g_comblk_state = COMBLK_TX_DATA;
2000405c:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004060:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004064:	f04f 0202 	mov.w	r2, #2
20004068:	701a      	strb	r2, [r3, #0]
2000406a:	e006      	b.n	2000407a <MSS_COMBLK_send_cmd+0x19a>
        }
        else
        {
            g_comblk_state = COMBLK_WAIT_RESPONSE;
2000406c:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004070:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004074:	f04f 0203 	mov.w	r2, #3
20004078:	701a      	strb	r2, [r3, #0]
    }

    /*
     * Enable interrupt.
     */
    NVIC_EnableIRQ(ComBlk_IRQn);
2000407a:	f04f 0013 	mov.w	r0, #19
2000407e:	f7ff fe39 	bl	20003cf4 <NVIC_EnableIRQ>
}
20004082:	f107 0718 	add.w	r7, r7, #24
20004086:	46bd      	mov	sp, r7
20004088:	bd80      	pop	{r7, pc}
2000408a:	bf00      	nop

2000408c <MSS_COMBLK_send_paged_cmd>:
    uint8_t * p_response,
    uint16_t response_size,
    comblk_page_handler_t page_read_handler,
    comblk_completion_handler_t completion_handler
)
{
2000408c:	b580      	push	{r7, lr}
2000408e:	b086      	sub	sp, #24
20004090:	af00      	add	r7, sp, #0
20004092:	60f8      	str	r0, [r7, #12]
20004094:	607a      	str	r2, [r7, #4]
20004096:	460a      	mov	r2, r1
20004098:	817a      	strh	r2, [r7, #10]
2000409a:	807b      	strh	r3, [r7, #2]
    uint32_t size_sent;
    uint8_t irq_enable = 0u;
2000409c:	f04f 0300 	mov.w	r3, #0
200040a0:	75fb      	strb	r3, [r7, #23]
    
    ASSERT(cmd_size > 0u);
200040a2:	897b      	ldrh	r3, [r7, #10]
200040a4:	2b00      	cmp	r3, #0
200040a6:	d100      	bne.n	200040aa <MSS_COMBLK_send_paged_cmd+0x1e>
200040a8:	be00      	bkpt	0x0000
    
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
200040aa:	f04f 0013 	mov.w	r0, #19
200040ae:	f7ff fe3d 	bl	20003d2c <NVIC_DisableIRQ>
    COMBLK->INT_ENABLE = 0u;
200040b2:	f246 0300 	movw	r3, #24576	; 0x6000
200040b6:	f2c4 0301 	movt	r3, #16385	; 0x4001
200040ba:	f04f 0200 	mov.w	r2, #0
200040be:	609a      	str	r2, [r3, #8]
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
200040c0:	f04f 0013 	mov.w	r0, #19
200040c4:	f7ff fe50 	bl	20003d68 <NVIC_ClearPendingIRQ>
    
    /*
     * Abort current command if any.
     */
    abort_current_cmd();
200040c8:	f000 fbe6 	bl	20004898 <abort_current_cmd>
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
200040cc:	f245 23c0 	movw	r3, #21184	; 0x52c0
200040d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200040d4:	f04f 0201 	mov.w	r2, #1
200040d8:	701a      	strb	r2, [r3, #0]
    g_comblk_cmd_opcode = p_cmd[0];
200040da:	68fb      	ldr	r3, [r7, #12]
200040dc:	781a      	ldrb	r2, [r3, #0]
200040de:	f245 239d 	movw	r3, #21149	; 0x529d
200040e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200040e6:	701a      	strb	r2, [r3, #0]
    g_comblk_p_cmd = p_cmd;
200040e8:	f245 23a0 	movw	r3, #21152	; 0x52a0
200040ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
200040f0:	68fa      	ldr	r2, [r7, #12]
200040f2:	601a      	str	r2, [r3, #0]
    g_comblk_cmd_size = cmd_size;
200040f4:	f245 23a4 	movw	r3, #21156	; 0x52a4
200040f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200040fc:	897a      	ldrh	r2, [r7, #10]
200040fe:	801a      	strh	r2, [r3, #0]
    g_comblk_p_data = 0;
20004100:	f245 23a8 	movw	r3, #21160	; 0x52a8
20004104:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004108:	f04f 0200 	mov.w	r2, #0
2000410c:	601a      	str	r2, [r3, #0]
    g_comblk_data_size = 0u;
2000410e:	f245 23ac 	movw	r3, #21164	; 0x52ac
20004112:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004116:	f04f 0200 	mov.w	r2, #0
2000411a:	601a      	str	r2, [r3, #0]
    g_comblk_p_response = p_response;
2000411c:	f245 23b0 	movw	r3, #21168	; 0x52b0
20004120:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004124:	687a      	ldr	r2, [r7, #4]
20004126:	601a      	str	r2, [r3, #0]
    g_comblk_response_size = response_size;
20004128:	f245 23b4 	movw	r3, #21172	; 0x52b4
2000412c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004130:	887a      	ldrh	r2, [r7, #2]
20004132:	801a      	strh	r2, [r3, #0]
    g_comblk_response_idx = 0u;
20004134:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004138:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000413c:	f04f 0200 	mov.w	r2, #0
20004140:	801a      	strh	r2, [r3, #0]
    g_comblk_page_handler = page_read_handler;
20004142:	f245 23bc 	movw	r3, #21180	; 0x52bc
20004146:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000414a:	6a3a      	ldr	r2, [r7, #32]
2000414c:	601a      	str	r2, [r3, #0]
    g_comblk_completion_handler = completion_handler;
2000414e:	f245 23b8 	movw	r3, #21176	; 0x52b8
20004152:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004156:	6a7a      	ldr	r2, [r7, #36]	; 0x24
20004158:	601a      	str	r2, [r3, #0]
    
    /*
     * Fill FIFO with command.
     */
    send_cmd_opcode(g_comblk_cmd_opcode);
2000415a:	f245 239d 	movw	r3, #21149	; 0x529d
2000415e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004162:	781b      	ldrb	r3, [r3, #0]
20004164:	b2db      	uxtb	r3, r3
20004166:	4618      	mov	r0, r3
20004168:	f000 fbc6 	bl	200048f8 <send_cmd_opcode>
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
2000416c:	68fb      	ldr	r3, [r7, #12]
2000416e:	f103 0201 	add.w	r2, r3, #1
20004172:	897b      	ldrh	r3, [r7, #10]
20004174:	f103 33ff 	add.w	r3, r3, #4294967295
20004178:	4610      	mov	r0, r2
2000417a:	4619      	mov	r1, r3
2000417c:	f000 fbe4 	bl	20004948 <fill_tx_fifo>
20004180:	4603      	mov	r3, r0
20004182:	613b      	str	r3, [r7, #16]
    ++size_sent;    /* Adjust for opcode byte sent. */
20004184:	693b      	ldr	r3, [r7, #16]
20004186:	f103 0301 	add.w	r3, r3, #1
2000418a:	613b      	str	r3, [r7, #16]
    if(size_sent < cmd_size)
2000418c:	897a      	ldrh	r2, [r7, #10]
2000418e:	693b      	ldr	r3, [r7, #16]
20004190:	429a      	cmp	r2, r3
20004192:	d926      	bls.n	200041e2 <MSS_COMBLK_send_paged_cmd+0x156>
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
20004194:	f245 23a4 	movw	r3, #21156	; 0x52a4
20004198:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000419c:	881b      	ldrh	r3, [r3, #0]
2000419e:	b29a      	uxth	r2, r3
200041a0:	693b      	ldr	r3, [r7, #16]
200041a2:	b29b      	uxth	r3, r3
200041a4:	ebc3 0302 	rsb	r3, r3, r2
200041a8:	b29a      	uxth	r2, r3
200041aa:	f245 23a4 	movw	r3, #21156	; 0x52a4
200041ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041b2:	801a      	strh	r2, [r3, #0]
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
200041b4:	f245 23a0 	movw	r3, #21152	; 0x52a0
200041b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041bc:	681a      	ldr	r2, [r3, #0]
200041be:	693b      	ldr	r3, [r7, #16]
200041c0:	441a      	add	r2, r3
200041c2:	f245 23a0 	movw	r3, #21152	; 0x52a0
200041c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041ca:	601a      	str	r2, [r3, #0]
        
        g_comblk_state = COMBLK_TX_CMD;
200041cc:	f245 23c1 	movw	r3, #21185	; 0x52c1
200041d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041d4:	f04f 0201 	mov.w	r2, #1
200041d8:	701a      	strb	r2, [r3, #0]
        irq_enable = TXTOKAY_MASK | RCVOKAY_MASK;
200041da:	f04f 0303 	mov.w	r3, #3
200041de:	75fb      	strb	r3, [r7, #23]
200041e0:	e010      	b.n	20004204 <MSS_COMBLK_send_paged_cmd+0x178>
    }
    else
    {
        g_comblk_cmd_size = 0u;
200041e2:	f245 23a4 	movw	r3, #21156	; 0x52a4
200041e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041ea:	f04f 0200 	mov.w	r2, #0
200041ee:	801a      	strh	r2, [r3, #0]
        g_comblk_state = COMBLK_TX_PAGED_DATA;
200041f0:	f245 23c1 	movw	r3, #21185	; 0x52c1
200041f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200041f8:	f04f 0205 	mov.w	r2, #5
200041fc:	701a      	strb	r2, [r3, #0]
        irq_enable = TXTOKAY_MASK | RCVOKAY_MASK;
200041fe:	f04f 0303 	mov.w	r3, #3
20004202:	75fb      	strb	r3, [r7, #23]
    }

    /*
     * Enable interrupt.
     */
    COMBLK->INT_ENABLE |= irq_enable;
20004204:	f246 0300 	movw	r3, #24576	; 0x6000
20004208:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000420c:	f246 0200 	movw	r2, #24576	; 0x6000
20004210:	f2c4 0201 	movt	r2, #16385	; 0x4001
20004214:	6891      	ldr	r1, [r2, #8]
20004216:	7dfa      	ldrb	r2, [r7, #23]
20004218:	ea41 0202 	orr.w	r2, r1, r2
2000421c:	609a      	str	r2, [r3, #8]
    NVIC_EnableIRQ(ComBlk_IRQn);
2000421e:	f04f 0013 	mov.w	r0, #19
20004222:	f7ff fd67 	bl	20003cf4 <NVIC_EnableIRQ>
}
20004226:	f107 0718 	add.w	r7, r7, #24
2000422a:	46bd      	mov	sp, r7
2000422c:	bd80      	pop	{r7, pc}
2000422e:	bf00      	nop

20004230 <ComBlk_IRQHandler>:

/*==============================================================================
 * COMBLK interrupt handler.
 */
void ComBlk_IRQHandler(void)
{
20004230:	b580      	push	{r7, lr}
20004232:	b082      	sub	sp, #8
20004234:	af00      	add	r7, sp, #0
    uint8_t status;
    uint8_t tx_okay;
    uint8_t rcv_okay;
    
    status = (uint8_t)COMBLK->STATUS;
20004236:	f246 0300 	movw	r3, #24576	; 0x6000
2000423a:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000423e:	685b      	ldr	r3, [r3, #4]
20004240:	717b      	strb	r3, [r7, #5]
    
    /* Mask off interrupt that are not enabled.*/
    status &= COMBLK->INT_ENABLE;
20004242:	f246 0300 	movw	r3, #24576	; 0x6000
20004246:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000424a:	689b      	ldr	r3, [r3, #8]
2000424c:	b2da      	uxtb	r2, r3
2000424e:	797b      	ldrb	r3, [r7, #5]
20004250:	ea02 0303 	and.w	r3, r2, r3
20004254:	717b      	strb	r3, [r7, #5]
    
    rcv_okay = status & RCVOKAY_MASK;
20004256:	797b      	ldrb	r3, [r7, #5]
20004258:	f003 0302 	and.w	r3, r3, #2
2000425c:	71fb      	strb	r3, [r7, #7]
    
    if(rcv_okay)
2000425e:	79fb      	ldrb	r3, [r7, #7]
20004260:	2b00      	cmp	r3, #0
20004262:	d001      	beq.n	20004268 <ComBlk_IRQHandler+0x38>
    {
        handle_rx_okay_irq();
20004264:	f000 f970 	bl	20004548 <handle_rx_okay_irq>
    }
        
    tx_okay = status & TXTOKAY_MASK;
20004268:	797b      	ldrb	r3, [r7, #5]
2000426a:	f003 0301 	and.w	r3, r3, #1
2000426e:	71bb      	strb	r3, [r7, #6]
    if(tx_okay)
20004270:	79bb      	ldrb	r3, [r7, #6]
20004272:	2b00      	cmp	r3, #0
20004274:	d001      	beq.n	2000427a <ComBlk_IRQHandler+0x4a>
    {
        handle_tx_okay_irq();
20004276:	f000 f805 	bl	20004284 <handle_tx_okay_irq>
    }
}
2000427a:	f107 0708 	add.w	r7, r7, #8
2000427e:	46bd      	mov	sp, r7
20004280:	bd80      	pop	{r7, pc}
20004282:	bf00      	nop

20004284 <handle_tx_okay_irq>:

/*==============================================================================
 *
 */
static void handle_tx_okay_irq(void)
{
20004284:	b580      	push	{r7, lr}
20004286:	b084      	sub	sp, #16
20004288:	af00      	add	r7, sp, #0
    switch(g_comblk_state)
2000428a:	f245 23c1 	movw	r3, #21185	; 0x52c1
2000428e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004292:	781b      	ldrb	r3, [r3, #0]
20004294:	2b02      	cmp	r3, #2
20004296:	d067      	beq.n	20004368 <handle_tx_okay_irq+0xe4>
20004298:	2b05      	cmp	r3, #5
2000429a:	f000 80b6 	beq.w	2000440a <handle_tx_okay_irq+0x186>
2000429e:	2b01      	cmp	r3, #1
200042a0:	f040 8136 	bne.w	20004510 <handle_tx_okay_irq+0x28c>
        /*----------------------------------------------------------------------
         * The TX_OKAY interrupt should only be enabled for states COMBLK_TX_CMD
         * and COMBLK_TX_DATA.
         */
        case COMBLK_TX_CMD:
            if(g_comblk_cmd_size > 0u)
200042a4:	f245 23a4 	movw	r3, #21156	; 0x52a4
200042a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200042ac:	881b      	ldrh	r3, [r3, #0]
200042ae:	b29b      	uxth	r3, r3
200042b0:	2b00      	cmp	r3, #0
200042b2:	d055      	beq.n	20004360 <handle_tx_okay_irq+0xdc>
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
200042b4:	f245 23a0 	movw	r3, #21152	; 0x52a0
200042b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200042bc:	681a      	ldr	r2, [r3, #0]
200042be:	f245 23a4 	movw	r3, #21156	; 0x52a4
200042c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200042c6:	881b      	ldrh	r3, [r3, #0]
200042c8:	b29b      	uxth	r3, r3
200042ca:	4610      	mov	r0, r2
200042cc:	4619      	mov	r1, r3
200042ce:	f000 fb3b 	bl	20004948 <fill_tx_fifo>
200042d2:	4603      	mov	r3, r0
200042d4:	607b      	str	r3, [r7, #4]
                if(size_sent < g_comblk_cmd_size)
200042d6:	f245 23a4 	movw	r3, #21156	; 0x52a4
200042da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200042de:	881b      	ldrh	r3, [r3, #0]
200042e0:	b29b      	uxth	r3, r3
200042e2:	461a      	mov	r2, r3
200042e4:	687b      	ldr	r3, [r7, #4]
200042e6:	429a      	cmp	r2, r3
200042e8:	d91c      	bls.n	20004324 <handle_tx_okay_irq+0xa0>
                {
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
200042ea:	f245 23a4 	movw	r3, #21156	; 0x52a4
200042ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
200042f2:	881b      	ldrh	r3, [r3, #0]
200042f4:	b29a      	uxth	r2, r3
200042f6:	687b      	ldr	r3, [r7, #4]
200042f8:	b29b      	uxth	r3, r3
200042fa:	ebc3 0302 	rsb	r3, r3, r2
200042fe:	b29a      	uxth	r2, r3
20004300:	f245 23a4 	movw	r3, #21156	; 0x52a4
20004304:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004308:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
2000430a:	f245 23a0 	movw	r3, #21152	; 0x52a0
2000430e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004312:	681a      	ldr	r2, [r3, #0]
20004314:	687b      	ldr	r3, [r7, #4]
20004316:	441a      	add	r2, r3
20004318:	f245 23a0 	movw	r3, #21152	; 0x52a0
2000431c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004320:	601a      	str	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
20004322:	e10c      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
                }
                else
                {
                    g_comblk_cmd_size = 0u;
20004324:	f245 23a4 	movw	r3, #21156	; 0x52a4
20004328:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000432c:	f04f 0200 	mov.w	r2, #0
20004330:	801a      	strh	r2, [r3, #0]
                    if(g_comblk_data_size > 0u)
20004332:	f245 23ac 	movw	r3, #21164	; 0x52ac
20004336:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000433a:	681b      	ldr	r3, [r3, #0]
2000433c:	2b00      	cmp	r3, #0
2000433e:	d007      	beq.n	20004350 <handle_tx_okay_irq+0xcc>
                    {
                        g_comblk_state = COMBLK_TX_DATA;
20004340:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004344:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004348:	f04f 0202 	mov.w	r2, #2
2000434c:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
2000434e:	e0f6      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
                    {
                        g_comblk_state = COMBLK_TX_DATA;
                    }
                    else
                    {
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
20004350:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004354:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004358:	f04f 0203 	mov.w	r2, #3
2000435c:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
2000435e:	e0ee      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
            {
                /*
                 * This is an invalid situation indicating a bug in the driver
                 * or corrupted memory.
                 */
                ASSERT(0);
20004360:	be00      	bkpt	0x0000
                abort_current_cmd();
20004362:	f000 fa99 	bl	20004898 <abort_current_cmd>
            }
        break;
20004366:	e0ea      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
            
        case COMBLK_TX_DATA:
            if(g_comblk_data_size > 0u)
20004368:	f245 23ac 	movw	r3, #21164	; 0x52ac
2000436c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004370:	681b      	ldr	r3, [r3, #0]
20004372:	2b00      	cmp	r3, #0
20004374:	d045      	beq.n	20004402 <handle_tx_okay_irq+0x17e>
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
20004376:	f245 23a8 	movw	r3, #21160	; 0x52a8
2000437a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000437e:	681a      	ldr	r2, [r3, #0]
20004380:	f245 23ac 	movw	r3, #21164	; 0x52ac
20004384:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004388:	681b      	ldr	r3, [r3, #0]
2000438a:	4610      	mov	r0, r2
2000438c:	4619      	mov	r1, r3
2000438e:	f000 fadb 	bl	20004948 <fill_tx_fifo>
20004392:	4603      	mov	r3, r0
20004394:	60bb      	str	r3, [r7, #8]
                if(size_sent < g_comblk_data_size)
20004396:	f245 23ac 	movw	r3, #21164	; 0x52ac
2000439a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000439e:	681b      	ldr	r3, [r3, #0]
200043a0:	68ba      	ldr	r2, [r7, #8]
200043a2:	429a      	cmp	r2, r3
200043a4:	d219      	bcs.n	200043da <handle_tx_okay_irq+0x156>
                {
                    g_comblk_data_size = g_comblk_data_size - size_sent;
200043a6:	f245 23ac 	movw	r3, #21164	; 0x52ac
200043aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200043ae:	681a      	ldr	r2, [r3, #0]
200043b0:	68bb      	ldr	r3, [r7, #8]
200043b2:	ebc3 0202 	rsb	r2, r3, r2
200043b6:	f245 23ac 	movw	r3, #21164	; 0x52ac
200043ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
200043be:	601a      	str	r2, [r3, #0]
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
200043c0:	f245 23a8 	movw	r3, #21160	; 0x52a8
200043c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200043c8:	681a      	ldr	r2, [r3, #0]
200043ca:	68bb      	ldr	r3, [r7, #8]
200043cc:	441a      	add	r2, r3
200043ce:	f245 23a8 	movw	r3, #21160	; 0x52a8
200043d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200043d6:	601a      	str	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
200043d8:	e0b1      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
                    g_comblk_data_size = g_comblk_data_size - size_sent;
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
                }
                else
                {
                    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
200043da:	f246 0300 	movw	r3, #24576	; 0x6000
200043de:	f2c4 0301 	movt	r3, #16385	; 0x4001
200043e2:	f246 0200 	movw	r2, #24576	; 0x6000
200043e6:	f2c4 0201 	movt	r2, #16385	; 0x4001
200043ea:	6892      	ldr	r2, [r2, #8]
200043ec:	f022 0201 	bic.w	r2, r2, #1
200043f0:	609a      	str	r2, [r3, #8]
                    g_comblk_state = COMBLK_WAIT_RESPONSE;
200043f2:	f245 23c1 	movw	r3, #21185	; 0x52c1
200043f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200043fa:	f04f 0203 	mov.w	r2, #3
200043fe:	701a      	strb	r2, [r3, #0]
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
            }
        break;
20004400:	e09d      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
            {
                /*
                 * This is an invalid situation indicating a bug in the driver
                 * or corrupted memory.
                 */
                ASSERT(0);
20004402:	be00      	bkpt	0x0000
                abort_current_cmd();
20004404:	f000 fa48 	bl	20004898 <abort_current_cmd>
            }
        break;
20004408:	e099      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
           
        case COMBLK_TX_PAGED_DATA:
            /*
             * Read a page of data if required.
             */
            if(0u == g_comblk_data_size)
2000440a:	f245 23ac 	movw	r3, #21164	; 0x52ac
2000440e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004412:	681b      	ldr	r3, [r3, #0]
20004414:	2b00      	cmp	r3, #0
20004416:	d136      	bne.n	20004486 <handle_tx_okay_irq+0x202>
            {
                if(g_comblk_page_handler != 0)
20004418:	f245 23bc 	movw	r3, #21180	; 0x52bc
2000441c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004420:	681b      	ldr	r3, [r3, #0]
20004422:	2b00      	cmp	r3, #0
20004424:	d02a      	beq.n	2000447c <handle_tx_okay_irq+0x1f8>
                {
                    g_comblk_data_size = g_comblk_page_handler(&g_comblk_p_data);
20004426:	f245 23bc 	movw	r3, #21180	; 0x52bc
2000442a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000442e:	681b      	ldr	r3, [r3, #0]
20004430:	f245 20a8 	movw	r0, #21160	; 0x52a8
20004434:	f2c2 0000 	movt	r0, #8192	; 0x2000
20004438:	4798      	blx	r3
2000443a:	4602      	mov	r2, r0
2000443c:	f245 23ac 	movw	r3, #21164	; 0x52ac
20004440:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004444:	601a      	str	r2, [r3, #0]
                    if(0u == g_comblk_data_size)
20004446:	f245 23ac 	movw	r3, #21164	; 0x52ac
2000444a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000444e:	681b      	ldr	r3, [r3, #0]
20004450:	2b00      	cmp	r3, #0
20004452:	d117      	bne.n	20004484 <handle_tx_okay_irq+0x200>
                    {
                        COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
20004454:	f246 0300 	movw	r3, #24576	; 0x6000
20004458:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000445c:	f246 0200 	movw	r2, #24576	; 0x6000
20004460:	f2c4 0201 	movt	r2, #16385	; 0x4001
20004464:	6892      	ldr	r2, [r2, #8]
20004466:	f022 0201 	bic.w	r2, r2, #1
2000446a:	609a      	str	r2, [r3, #8]
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
2000446c:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004470:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004474:	f04f 0203 	mov.w	r2, #3
20004478:	701a      	strb	r2, [r3, #0]
2000447a:	e004      	b.n	20004486 <handle_tx_okay_irq+0x202>
                    }
                }
                else
                {
                    ASSERT(0);
2000447c:	be00      	bkpt	0x0000
                    abort_current_cmd();
2000447e:	f000 fa0b 	bl	20004898 <abort_current_cmd>
20004482:	e000      	b.n	20004486 <handle_tx_okay_irq+0x202>
                {
                    g_comblk_data_size = g_comblk_page_handler(&g_comblk_p_data);
                    if(0u == g_comblk_data_size)
                    {
                        COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
20004484:	bf00      	nop
            /*
             * Transmit the page data or move to COMBLK_WAIT_RESPONSE state if
             * no further page data could be obtained by the call to the page
             * handler above.
             */
            if(0u == g_comblk_data_size)
20004486:	f245 23ac 	movw	r3, #21164	; 0x52ac
2000448a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000448e:	681b      	ldr	r3, [r3, #0]
20004490:	2b00      	cmp	r3, #0
20004492:	d113      	bne.n	200044bc <handle_tx_okay_irq+0x238>
            {
                COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
20004494:	f246 0300 	movw	r3, #24576	; 0x6000
20004498:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000449c:	f246 0200 	movw	r2, #24576	; 0x6000
200044a0:	f2c4 0201 	movt	r2, #16385	; 0x4001
200044a4:	6892      	ldr	r2, [r2, #8]
200044a6:	f022 0201 	bic.w	r2, r2, #1
200044aa:	609a      	str	r2, [r3, #8]
                g_comblk_state = COMBLK_WAIT_RESPONSE;
200044ac:	f245 23c1 	movw	r3, #21185	; 0x52c1
200044b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200044b4:	f04f 0203 	mov.w	r2, #3
200044b8:	701a      	strb	r2, [r3, #0]
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                g_comblk_data_size = g_comblk_data_size - size_sent;
                g_comblk_p_data = &g_comblk_p_data[size_sent];
            }
        break;
200044ba:	e040      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
                g_comblk_state = COMBLK_WAIT_RESPONSE;
            }
            else
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
200044bc:	f245 23a8 	movw	r3, #21160	; 0x52a8
200044c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200044c4:	681a      	ldr	r2, [r3, #0]
200044c6:	f245 23ac 	movw	r3, #21164	; 0x52ac
200044ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
200044ce:	681b      	ldr	r3, [r3, #0]
200044d0:	4610      	mov	r0, r2
200044d2:	4619      	mov	r1, r3
200044d4:	f000 fa38 	bl	20004948 <fill_tx_fifo>
200044d8:	4603      	mov	r3, r0
200044da:	60fb      	str	r3, [r7, #12]
                g_comblk_data_size = g_comblk_data_size - size_sent;
200044dc:	f245 23ac 	movw	r3, #21164	; 0x52ac
200044e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200044e4:	681a      	ldr	r2, [r3, #0]
200044e6:	68fb      	ldr	r3, [r7, #12]
200044e8:	ebc3 0202 	rsb	r2, r3, r2
200044ec:	f245 23ac 	movw	r3, #21164	; 0x52ac
200044f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200044f4:	601a      	str	r2, [r3, #0]
                g_comblk_p_data = &g_comblk_p_data[size_sent];
200044f6:	f245 23a8 	movw	r3, #21160	; 0x52a8
200044fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200044fe:	681a      	ldr	r2, [r3, #0]
20004500:	68fb      	ldr	r3, [r7, #12]
20004502:	441a      	add	r2, r3
20004504:	f245 23a8 	movw	r3, #21160	; 0x52a8
20004508:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000450c:	601a      	str	r2, [r3, #0]
            }
        break;
2000450e:	e016      	b.n	2000453e <handle_tx_okay_irq+0x2ba>
        case COMBLK_WAIT_RESPONSE:
            /* Fall through */
        case COMBLK_RX_RESPONSE:
            /* Fall through */
        default:
            COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
20004510:	f246 0300 	movw	r3, #24576	; 0x6000
20004514:	f2c4 0301 	movt	r3, #16385	; 0x4001
20004518:	f246 0200 	movw	r2, #24576	; 0x6000
2000451c:	f2c4 0201 	movt	r2, #16385	; 0x4001
20004520:	6892      	ldr	r2, [r2, #8]
20004522:	f022 0201 	bic.w	r2, r2, #1
20004526:	609a      	str	r2, [r3, #8]
            complete_request(0u);
20004528:	f04f 0000 	mov.w	r0, #0
2000452c:	f000 f988 	bl	20004840 <complete_request>
            g_comblk_state = COMBLK_IDLE;
20004530:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004534:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004538:	f04f 0200 	mov.w	r2, #0
2000453c:	701a      	strb	r2, [r3, #0]
        break;
    }
}
2000453e:	f107 0710 	add.w	r7, r7, #16
20004542:	46bd      	mov	sp, r7
20004544:	bd80      	pop	{r7, pc}
20004546:	bf00      	nop

20004548 <handle_rx_okay_irq>:

/*==============================================================================
 *
 */
static void handle_rx_okay_irq(void)
{
20004548:	b580      	push	{r7, lr}
2000454a:	b084      	sub	sp, #16
2000454c:	af00      	add	r7, sp, #0
    uint16_t data16;
    uint16_t is_command;
    uint8_t data8;
    
    data16 = (uint16_t)COMBLK->DATA8;
2000454e:	f246 0300 	movw	r3, #24576	; 0x6000
20004552:	f2c4 0301 	movt	r3, #16385	; 0x4001
20004556:	691b      	ldr	r3, [r3, #16]
20004558:	80bb      	strh	r3, [r7, #4]
    is_command = data16 & DATA8_COMMAND_MASK;
2000455a:	88bb      	ldrh	r3, [r7, #4]
2000455c:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
20004560:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
20004564:	80fb      	strh	r3, [r7, #6]
    data8 = (uint8_t)data16;
20004566:	88bb      	ldrh	r3, [r7, #4]
20004568:	727b      	strb	r3, [r7, #9]
            
    switch(g_comblk_state)
2000456a:	f245 23c1 	movw	r3, #21185	; 0x52c1
2000456e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004572:	781b      	ldrb	r3, [r3, #0]
20004574:	2b05      	cmp	r3, #5
20004576:	f200 814b 	bhi.w	20004810 <handle_rx_okay_irq+0x2c8>
2000457a:	a201      	add	r2, pc, #4	; (adr r2, 20004580 <handle_rx_okay_irq+0x38>)
2000457c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20004580:	20004599 	.word	0x20004599
20004584:	200047fd 	.word	0x200047fd
20004588:	200047fd 	.word	0x200047fd
2000458c:	20004629 	.word	0x20004629
20004590:	200046a7 	.word	0x200046a7
20004594:	200047bf 	.word	0x200047bf
        * MSS_COMBLK_init() enables the RCV_OKAY interrupt for the COMBLK_IDLE
        * state to receive the asynchronous power-on-reset from the system
        * controller.
        */
        case COMBLK_IDLE:
            if(is_command)
20004598:	88fb      	ldrh	r3, [r7, #6]
2000459a:	2b00      	cmp	r3, #0
2000459c:	f000 8144 	beq.w	20004828 <handle_rx_okay_irq+0x2e0>
            {
                if(data8 != POR_DIGEST_ERROR_OPCODE)
200045a0:	7a7b      	ldrb	r3, [r7, #9]
200045a2:	2bf1      	cmp	r3, #241	; 0xf1
200045a4:	d006      	beq.n	200045b4 <handle_rx_okay_irq+0x6c>
                {
                    uint8_t rxed_opcode;
                    rxed_opcode = data8;
200045a6:	7a7b      	ldrb	r3, [r7, #9]
200045a8:	72bb      	strb	r3, [r7, #10]
                    process_sys_ctrl_command(rxed_opcode);
200045aa:	7abb      	ldrb	r3, [r7, #10]
200045ac:	4618      	mov	r0, r3
200045ae:	f000 fa0b 	bl	200049c8 <process_sys_ctrl_command>
                    g_comblk_response_idx++;
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
            }
        break;
200045b2:	e140      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
                    rxed_opcode = data8;
                    process_sys_ctrl_command(rxed_opcode);
                }
                else
                {  
                    g_comblk_response_idx = 0;
200045b4:	f245 23b6 	movw	r3, #21174	; 0x52b6
200045b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200045bc:	f04f 0200 	mov.w	r2, #0
200045c0:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = data8;
200045c2:	f245 23b0 	movw	r3, #21168	; 0x52b0
200045c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200045ca:	681a      	ldr	r2, [r3, #0]
200045cc:	f245 23b6 	movw	r3, #21174	; 0x52b6
200045d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200045d4:	881b      	ldrh	r3, [r3, #0]
200045d6:	b29b      	uxth	r3, r3
200045d8:	4413      	add	r3, r2
200045da:	7a7a      	ldrb	r2, [r7, #9]
200045dc:	701a      	strb	r2, [r3, #0]
                    g_comblk_response_idx++;
200045de:	f245 23b6 	movw	r3, #21174	; 0x52b6
200045e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200045e6:	881b      	ldrh	r3, [r3, #0]
200045e8:	b29b      	uxth	r3, r3
200045ea:	f103 0301 	add.w	r3, r3, #1
200045ee:	b29a      	uxth	r2, r3
200045f0:	f245 23b6 	movw	r3, #21174	; 0x52b6
200045f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200045f8:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
200045fa:	f245 23b0 	movw	r3, #21168	; 0x52b0
200045fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004602:	681a      	ldr	r2, [r3, #0]
20004604:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004608:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000460c:	881b      	ldrh	r3, [r3, #0]
2000460e:	b29b      	uxth	r3, r3
20004610:	4413      	add	r3, r2
20004612:	f04f 0200 	mov.w	r2, #0
20004616:	701a      	strb	r2, [r3, #0]
                    g_comblk_state = COMBLK_RX_RESPONSE;
20004618:	f245 23c1 	movw	r3, #21185	; 0x52c1
2000461c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004620:	f04f 0204 	mov.w	r2, #4
20004624:	701a      	strb	r2, [r3, #0]
                }
            }
        break;
20004626:	e106      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
        /*----------------------------------------------------------------------
         * The RCV_OKAY interrupt should only be enabled for states
         * COMBLK_WAIT_RESPONSE and COMBLK_RX_RESPONSE. 
         */
        case COMBLK_WAIT_RESPONSE:
            if(is_command)
20004628:	88fb      	ldrh	r3, [r7, #6]
2000462a:	2b00      	cmp	r3, #0
2000462c:	f000 80fe 	beq.w	2000482c <handle_rx_okay_irq+0x2e4>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
20004630:	7a7b      	ldrb	r3, [r7, #9]
20004632:	72fb      	strb	r3, [r7, #11]
                if(rxed_opcode == g_comblk_cmd_opcode)
20004634:	f245 239d 	movw	r3, #21149	; 0x529d
20004638:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000463c:	781b      	ldrb	r3, [r3, #0]
2000463e:	b2db      	uxtb	r3, r3
20004640:	7afa      	ldrb	r2, [r7, #11]
20004642:	429a      	cmp	r2, r3
20004644:	d12a      	bne.n	2000469c <handle_rx_okay_irq+0x154>
                {
                    g_comblk_response_idx = 0u;
20004646:	f245 23b6 	movw	r3, #21174	; 0x52b6
2000464a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000464e:	f04f 0200 	mov.w	r2, #0
20004652:	801a      	strh	r2, [r3, #0]
                    g_comblk_p_response[g_comblk_response_idx] = rxed_opcode;
20004654:	f245 23b0 	movw	r3, #21168	; 0x52b0
20004658:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000465c:	681a      	ldr	r2, [r3, #0]
2000465e:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004662:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004666:	881b      	ldrh	r3, [r3, #0]
20004668:	b29b      	uxth	r3, r3
2000466a:	4413      	add	r3, r2
2000466c:	7afa      	ldrb	r2, [r7, #11]
2000466e:	701a      	strb	r2, [r3, #0]
                    ++g_comblk_response_idx;
20004670:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004674:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004678:	881b      	ldrh	r3, [r3, #0]
2000467a:	b29b      	uxth	r3, r3
2000467c:	f103 0301 	add.w	r3, r3, #1
20004680:	b29a      	uxth	r2, r3
20004682:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004686:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000468a:	801a      	strh	r2, [r3, #0]
                    g_comblk_state = COMBLK_RX_RESPONSE;
2000468c:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004690:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004694:	f04f 0204 	mov.w	r2, #4
20004698:	701a      	strb	r2, [r3, #0]
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
                }
            }
        break;
2000469a:	e0cc      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
                    ++g_comblk_response_idx;
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
2000469c:	7afb      	ldrb	r3, [r7, #11]
2000469e:	4618      	mov	r0, r3
200046a0:	f000 f992 	bl	200049c8 <process_sys_ctrl_command>
                }
            }
        break;
200046a4:	e0c7      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
            
        case COMBLK_RX_RESPONSE:
            if(is_command)
200046a6:	88fb      	ldrh	r3, [r7, #6]
200046a8:	2b00      	cmp	r3, #0
200046aa:	d006      	beq.n	200046ba <handle_rx_okay_irq+0x172>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
200046ac:	7a7b      	ldrb	r3, [r7, #9]
200046ae:	733b      	strb	r3, [r7, #12]
                process_sys_ctrl_command(rxed_opcode);
200046b0:	7b3b      	ldrb	r3, [r7, #12]
200046b2:	4618      	mov	r0, r3
200046b4:	f000 f988 	bl	200049c8 <process_sys_ctrl_command>
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
200046b8:	e0bd      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
            else
            {
                if( g_comblk_p_response[g_comblk_response_idx-1] == POR_DIGEST_ERROR_OPCODE)
200046ba:	f245 23b0 	movw	r3, #21168	; 0x52b0
200046be:	f2c2 0300 	movt	r3, #8192	; 0x2000
200046c2:	681a      	ldr	r2, [r3, #0]
200046c4:	f245 23b6 	movw	r3, #21174	; 0x52b6
200046c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200046cc:	881b      	ldrh	r3, [r3, #0]
200046ce:	b29b      	uxth	r3, r3
200046d0:	f103 33ff 	add.w	r3, r3, #4294967295
200046d4:	4413      	add	r3, r2
200046d6:	781b      	ldrb	r3, [r3, #0]
200046d8:	2bf1      	cmp	r3, #241	; 0xf1
200046da:	d127      	bne.n	2000472c <handle_rx_okay_irq+0x1e4>
                {
                    g_comblk_p_response[g_comblk_response_idx] = data8;
200046dc:	f245 23b0 	movw	r3, #21168	; 0x52b0
200046e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200046e4:	681a      	ldr	r2, [r3, #0]
200046e6:	f245 23b6 	movw	r3, #21174	; 0x52b6
200046ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200046ee:	881b      	ldrh	r3, [r3, #0]
200046f0:	b29b      	uxth	r3, r3
200046f2:	4413      	add	r3, r2
200046f4:	7a7a      	ldrb	r2, [r7, #9]
200046f6:	701a      	strb	r2, [r3, #0]
                    process_sys_ctrl_command(g_comblk_p_response[g_comblk_response_idx-1]);
200046f8:	f245 23b0 	movw	r3, #21168	; 0x52b0
200046fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004700:	681a      	ldr	r2, [r3, #0]
20004702:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004706:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000470a:	881b      	ldrh	r3, [r3, #0]
2000470c:	b29b      	uxth	r3, r3
2000470e:	f103 33ff 	add.w	r3, r3, #4294967295
20004712:	4413      	add	r3, r2
20004714:	781b      	ldrb	r3, [r3, #0]
20004716:	4618      	mov	r0, r3
20004718:	f000 f956 	bl	200049c8 <process_sys_ctrl_command>
                    g_comblk_state = COMBLK_IDLE;
2000471c:	f245 23c1 	movw	r3, #21185	; 0x52c1
20004720:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004724:	f04f 0200 	mov.w	r2, #0
20004728:	701a      	strb	r2, [r3, #0]
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
2000472a:	e084      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
                    process_sys_ctrl_command(g_comblk_p_response[g_comblk_response_idx-1]);
                    g_comblk_state = COMBLK_IDLE;
                }
                else
                {
                    if(g_comblk_response_idx < g_comblk_response_size)
2000472c:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004730:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004734:	881b      	ldrh	r3, [r3, #0]
20004736:	b29a      	uxth	r2, r3
20004738:	f245 23b4 	movw	r3, #21172	; 0x52b4
2000473c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004740:	881b      	ldrh	r3, [r3, #0]
20004742:	429a      	cmp	r2, r3
20004744:	d21d      	bcs.n	20004782 <handle_rx_okay_irq+0x23a>
                    {
                        uint8_t rxed_data;
                        
                        rxed_data = data8;
20004746:	7a7b      	ldrb	r3, [r7, #9]
20004748:	737b      	strb	r3, [r7, #13]
                        g_comblk_p_response[g_comblk_response_idx] = rxed_data;
2000474a:	f245 23b0 	movw	r3, #21168	; 0x52b0
2000474e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004752:	681a      	ldr	r2, [r3, #0]
20004754:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004758:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000475c:	881b      	ldrh	r3, [r3, #0]
2000475e:	b29b      	uxth	r3, r3
20004760:	4413      	add	r3, r2
20004762:	7b7a      	ldrb	r2, [r7, #13]
20004764:	701a      	strb	r2, [r3, #0]
                        ++g_comblk_response_idx;
20004766:	f245 23b6 	movw	r3, #21174	; 0x52b6
2000476a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000476e:	881b      	ldrh	r3, [r3, #0]
20004770:	b29b      	uxth	r3, r3
20004772:	f103 0301 	add.w	r3, r3, #1
20004776:	b29a      	uxth	r2, r3
20004778:	f245 23b6 	movw	r3, #21174	; 0x52b6
2000477c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004780:	801a      	strh	r2, [r3, #0]
                    }
                    
                    if(g_comblk_response_idx == g_comblk_response_size)
20004782:	f245 23b6 	movw	r3, #21174	; 0x52b6
20004786:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000478a:	881b      	ldrh	r3, [r3, #0]
2000478c:	b29a      	uxth	r2, r3
2000478e:	f245 23b4 	movw	r3, #21172	; 0x52b4
20004792:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004796:	881b      	ldrh	r3, [r3, #0]
20004798:	429a      	cmp	r2, r3
2000479a:	d149      	bne.n	20004830 <handle_rx_okay_irq+0x2e8>
                    {
                        complete_request(g_comblk_response_idx);
2000479c:	f245 23b6 	movw	r3, #21174	; 0x52b6
200047a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200047a4:	881b      	ldrh	r3, [r3, #0]
200047a6:	b29b      	uxth	r3, r3
200047a8:	4618      	mov	r0, r3
200047aa:	f000 f849 	bl	20004840 <complete_request>
                        g_comblk_state = COMBLK_IDLE;
200047ae:	f245 23c1 	movw	r3, #21185	; 0x52c1
200047b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200047b6:	f04f 0200 	mov.w	r2, #0
200047ba:	701a      	strb	r2, [r3, #0]
                    }
                }
            }
        break;
200047bc:	e03b      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
         * The RCV_OKAY interrupt should NOT be enabled for states
         * COMBLK_IDLE, COMBLK_TX_CMD and COMBLK_TX_DATA.
         */
        case COMBLK_TX_PAGED_DATA:
            /* This is needed because when there is an error, we need to terminate loading the data */
            if(!is_command)
200047be:	88fb      	ldrh	r3, [r7, #6]
200047c0:	2b00      	cmp	r3, #0
200047c2:	d114      	bne.n	200047ee <handle_rx_okay_irq+0x2a6>
            {
                g_comblk_p_response[1] = data8;
200047c4:	f245 23b0 	movw	r3, #21168	; 0x52b0
200047c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200047cc:	681b      	ldr	r3, [r3, #0]
200047ce:	f103 0301 	add.w	r3, r3, #1
200047d2:	7a7a      	ldrb	r2, [r7, #9]
200047d4:	701a      	strb	r2, [r3, #0]
                complete_request(2u);
200047d6:	f04f 0002 	mov.w	r0, #2
200047da:	f000 f831 	bl	20004840 <complete_request>
                g_comblk_state = COMBLK_IDLE;
200047de:	f245 23c1 	movw	r3, #21185	; 0x52c1
200047e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200047e6:	f04f 0200 	mov.w	r2, #0
200047ea:	701a      	strb	r2, [r3, #0]
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
        break;
200047ec:	e023      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
                g_comblk_state = COMBLK_IDLE;
            }
            else
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
200047ee:	7a7b      	ldrb	r3, [r7, #9]
200047f0:	73bb      	strb	r3, [r7, #14]
                process_sys_ctrl_command(rxed_opcode);
200047f2:	7bbb      	ldrb	r3, [r7, #14]
200047f4:	4618      	mov	r0, r3
200047f6:	f000 f8e7 	bl	200049c8 <process_sys_ctrl_command>
            }
        break;
200047fa:	e01c      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
        
        case COMBLK_TX_CMD:
            /* Fall through */
        case COMBLK_TX_DATA:
            /* Fall through */
            if(is_command)
200047fc:	88fb      	ldrh	r3, [r7, #6]
200047fe:	2b00      	cmp	r3, #0
20004800:	d018      	beq.n	20004834 <handle_rx_okay_irq+0x2ec>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
20004802:	7a7b      	ldrb	r3, [r7, #9]
20004804:	73fb      	strb	r3, [r7, #15]
                process_sys_ctrl_command(rxed_opcode);
20004806:	7bfb      	ldrb	r3, [r7, #15]
20004808:	4618      	mov	r0, r3
2000480a:	f000 f8dd 	bl	200049c8 <process_sys_ctrl_command>
            }
        break;
2000480e:	e012      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
        
        default:
            complete_request(0u);
20004810:	f04f 0000 	mov.w	r0, #0
20004814:	f000 f814 	bl	20004840 <complete_request>
            g_comblk_state = COMBLK_IDLE;
20004818:	f245 23c1 	movw	r3, #21185	; 0x52c1
2000481c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004820:	f04f 0200 	mov.w	r2, #0
20004824:	701a      	strb	r2, [r3, #0]
20004826:	e006      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
                    g_comblk_response_idx++;
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
                    g_comblk_state = COMBLK_RX_RESPONSE;
                }
            }
        break;
20004828:	bf00      	nop
2000482a:	e004      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
                else
                {
                    process_sys_ctrl_command(rxed_opcode);
                }
            }
        break;
2000482c:	bf00      	nop
2000482e:	e002      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
                        complete_request(g_comblk_response_idx);
                        g_comblk_state = COMBLK_IDLE;
                    }
                }
            }
        break;
20004830:	bf00      	nop
20004832:	e000      	b.n	20004836 <handle_rx_okay_irq+0x2ee>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
        break;
20004834:	bf00      	nop
        default:
            complete_request(0u);
            g_comblk_state = COMBLK_IDLE;
        break;
    }
}
20004836:	f107 0710 	add.w	r7, r7, #16
2000483a:	46bd      	mov	sp, r7
2000483c:	bd80      	pop	{r7, pc}
2000483e:	bf00      	nop

20004840 <complete_request>:
 */
static void complete_request
(
    uint16_t response_length
)
{
20004840:	b580      	push	{r7, lr}
20004842:	b082      	sub	sp, #8
20004844:	af00      	add	r7, sp, #0
20004846:	4603      	mov	r3, r0
20004848:	80fb      	strh	r3, [r7, #6]
    if(g_comblk_completion_handler != 0)
2000484a:	f245 23b8 	movw	r3, #21176	; 0x52b8
2000484e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004852:	681b      	ldr	r3, [r3, #0]
20004854:	2b00      	cmp	r3, #0
20004856:	d01b      	beq.n	20004890 <complete_request+0x50>
    {
        g_comblk_completion_handler(g_comblk_p_response, response_length);
20004858:	f245 23b8 	movw	r3, #21176	; 0x52b8
2000485c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20004860:	681a      	ldr	r2, [r3, #0]
20004862:	f245 23b0 	movw	r3, #21168	; 0x52b0
20004866:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000486a:	6819      	ldr	r1, [r3, #0]
2000486c:	88fb      	ldrh	r3, [r7, #6]
2000486e:	4608      	mov	r0, r1
20004870:	4619      	mov	r1, r3
20004872:	4790      	blx	r2
        g_comblk_completion_handler = 0;
20004874:	f245 23b8 	movw	r3, #21176	; 0x52b8
20004878:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000487c:	f04f 0200 	mov.w	r2, #0
20004880:	601a      	str	r2, [r3, #0]
        g_request_in_progress = 0u;
20004882:	f245 23c0 	movw	r3, #21184	; 0x52c0
20004886:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000488a:	f04f 0200 	mov.w	r2, #0
2000488e:	701a      	strb	r2, [r3, #0]
    }
}
20004890:	f107 0708 	add.w	r7, r7, #8
20004894:	46bd      	mov	sp, r7
20004896:	bd80      	pop	{r7, pc}

20004898 <abort_current_cmd>:

/*==============================================================================
 *
 */
static void abort_current_cmd(void)
{
20004898:	b580      	push	{r7, lr}
2000489a:	b082      	sub	sp, #8
2000489c:	af00      	add	r7, sp, #0
    if(g_request_in_progress)
2000489e:	f245 23c0 	movw	r3, #21184	; 0x52c0
200048a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200048a6:	781b      	ldrb	r3, [r3, #0]
200048a8:	b2db      	uxtb	r3, r3
200048aa:	2b00      	cmp	r3, #0
200048ac:	d01f      	beq.n	200048ee <abort_current_cmd+0x56>
        
        /*
         * Call completion handler just in case we are in a multi threaded system
         * to avoid a task lockup.
         */
        complete_request(g_comblk_response_idx);
200048ae:	f245 23b6 	movw	r3, #21174	; 0x52b6
200048b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200048b6:	881b      	ldrh	r3, [r3, #0]
200048b8:	b29b      	uxth	r3, r3
200048ba:	4618      	mov	r0, r3
200048bc:	f7ff ffc0 	bl	20004840 <complete_request>
        
        /*
         * Flush the FIFOs
         */
        COMBLK->CONTROL |= CR_FLUSHOUT_MASK;
200048c0:	f246 0300 	movw	r3, #24576	; 0x6000
200048c4:	f2c4 0301 	movt	r3, #16385	; 0x4001
200048c8:	f246 0200 	movw	r2, #24576	; 0x6000
200048cc:	f2c4 0201 	movt	r2, #16385	; 0x4001
200048d0:	6812      	ldr	r2, [r2, #0]
200048d2:	f042 0201 	orr.w	r2, r2, #1
200048d6:	601a      	str	r2, [r3, #0]
        do {
            flush_in_progress = COMBLK->CONTROL & CR_FLUSHOUT_MASK;
200048d8:	f246 0300 	movw	r3, #24576	; 0x6000
200048dc:	f2c4 0301 	movt	r3, #16385	; 0x4001
200048e0:	681b      	ldr	r3, [r3, #0]
200048e2:	f003 0301 	and.w	r3, r3, #1
200048e6:	607b      	str	r3, [r7, #4]
        } while(flush_in_progress);
200048e8:	687b      	ldr	r3, [r7, #4]
200048ea:	2b00      	cmp	r3, #0
200048ec:	d1f4      	bne.n	200048d8 <abort_current_cmd+0x40>
    }
}
200048ee:	f107 0708 	add.w	r7, r7, #8
200048f2:	46bd      	mov	sp, r7
200048f4:	bd80      	pop	{r7, pc}
200048f6:	bf00      	nop

200048f8 <send_cmd_opcode>:
 */
static void send_cmd_opcode
(
    uint8_t opcode
)
{
200048f8:	b480      	push	{r7}
200048fa:	b085      	sub	sp, #20
200048fc:	af00      	add	r7, sp, #0
200048fe:	4603      	mov	r3, r0
20004900:	71fb      	strb	r3, [r7, #7]
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
20004902:	f246 0300 	movw	r3, #24576	; 0x6000
20004906:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000490a:	f246 0200 	movw	r2, #24576	; 0x6000
2000490e:	f2c4 0201 	movt	r2, #16385	; 0x4001
20004912:	6812      	ldr	r2, [r2, #0]
20004914:	f022 0204 	bic.w	r2, r2, #4
20004918:	601a      	str	r2, [r3, #0]
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
2000491a:	f246 0300 	movw	r3, #24576	; 0x6000
2000491e:	f2c4 0301 	movt	r3, #16385	; 0x4001
20004922:	685b      	ldr	r3, [r3, #4]
20004924:	f003 0301 	and.w	r3, r3, #1
20004928:	60fb      	str	r3, [r7, #12]
    } while(0u == tx_okay);
2000492a:	68fb      	ldr	r3, [r7, #12]
2000492c:	2b00      	cmp	r3, #0
2000492e:	d0f4      	beq.n	2000491a <send_cmd_opcode+0x22>
    
    /* Send command opcode. */
    COMBLK->FRAME_START8 = opcode;
20004930:	f246 0300 	movw	r3, #24576	; 0x6000
20004934:	f2c4 0301 	movt	r3, #16385	; 0x4001
20004938:	79fa      	ldrb	r2, [r7, #7]
2000493a:	619a      	str	r2, [r3, #24]
}
2000493c:	f107 0714 	add.w	r7, r7, #20
20004940:	46bd      	mov	sp, r7
20004942:	bc80      	pop	{r7}
20004944:	4770      	bx	lr
20004946:	bf00      	nop

20004948 <fill_tx_fifo>:
static uint32_t fill_tx_fifo
(
    const uint8_t * p_cmd,
    uint32_t cmd_size
)
{
20004948:	b480      	push	{r7}
2000494a:	b085      	sub	sp, #20
2000494c:	af00      	add	r7, sp, #0
2000494e:	6078      	str	r0, [r7, #4]
20004950:	6039      	str	r1, [r7, #0]
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
20004952:	f246 0300 	movw	r3, #24576	; 0x6000
20004956:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000495a:	f246 0200 	movw	r2, #24576	; 0x6000
2000495e:	f2c4 0201 	movt	r2, #16385	; 0x4001
20004962:	6812      	ldr	r2, [r2, #0]
20004964:	f022 0204 	bic.w	r2, r2, #4
20004968:	601a      	str	r2, [r3, #0]
    
    size_sent = 0u;
2000496a:	f04f 0300 	mov.w	r3, #0
2000496e:	60fb      	str	r3, [r7, #12]
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
20004970:	f246 0300 	movw	r3, #24576	; 0x6000
20004974:	f2c4 0301 	movt	r3, #16385	; 0x4001
20004978:	685b      	ldr	r3, [r3, #4]
2000497a:	f003 0301 	and.w	r3, r3, #1
2000497e:	60bb      	str	r3, [r7, #8]
    while((tx_okay != 0u) && (size_sent < cmd_size))
20004980:	e014      	b.n	200049ac <fill_tx_fifo+0x64>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
20004982:	f246 0300 	movw	r3, #24576	; 0x6000
20004986:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000498a:	6879      	ldr	r1, [r7, #4]
2000498c:	68fa      	ldr	r2, [r7, #12]
2000498e:	440a      	add	r2, r1
20004990:	7812      	ldrb	r2, [r2, #0]
20004992:	611a      	str	r2, [r3, #16]
        ++size_sent;
20004994:	68fb      	ldr	r3, [r7, #12]
20004996:	f103 0301 	add.w	r3, r3, #1
2000499a:	60fb      	str	r3, [r7, #12]
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
2000499c:	f246 0300 	movw	r3, #24576	; 0x6000
200049a0:	f2c4 0301 	movt	r3, #16385	; 0x4001
200049a4:	685b      	ldr	r3, [r3, #4]
200049a6:	f003 0301 	and.w	r3, r3, #1
200049aa:	60bb      	str	r3, [r7, #8]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
200049ac:	68bb      	ldr	r3, [r7, #8]
200049ae:	2b00      	cmp	r3, #0
200049b0:	d003      	beq.n	200049ba <fill_tx_fifo+0x72>
200049b2:	68fa      	ldr	r2, [r7, #12]
200049b4:	683b      	ldr	r3, [r7, #0]
200049b6:	429a      	cmp	r2, r3
200049b8:	d3e3      	bcc.n	20004982 <fill_tx_fifo+0x3a>
        COMBLK->DATA8 = p_cmd[size_sent];
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    }
    
    return size_sent;
200049ba:	68fb      	ldr	r3, [r7, #12]
}
200049bc:	4618      	mov	r0, r3
200049be:	f107 0714 	add.w	r7, r7, #20
200049c2:	46bd      	mov	sp, r7
200049c4:	bc80      	pop	{r7}
200049c6:	4770      	bx	lr

200049c8 <process_sys_ctrl_command>:

/*==============================================================================
 *
 */
static void process_sys_ctrl_command(uint8_t cmd_opcode)
{
200049c8:	b580      	push	{r7, lr}
200049ca:	b082      	sub	sp, #8
200049cc:	af00      	add	r7, sp, #0
200049ce:	4603      	mov	r3, r0
200049d0:	71fb      	strb	r3, [r7, #7]
    if(g_async_event_handler != 0)
200049d2:	f245 23c4 	movw	r3, #21188	; 0x52c4
200049d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200049da:	681b      	ldr	r3, [r3, #0]
200049dc:	2b00      	cmp	r3, #0
200049de:	d007      	beq.n	200049f0 <process_sys_ctrl_command+0x28>
    {
        g_async_event_handler(cmd_opcode);
200049e0:	f245 23c4 	movw	r3, #21188	; 0x52c4
200049e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200049e8:	681b      	ldr	r3, [r3, #0]
200049ea:	79fa      	ldrb	r2, [r7, #7]
200049ec:	4610      	mov	r0, r2
200049ee:	4798      	blx	r3
    }
}
200049f0:	f107 0708 	add.w	r7, r7, #8
200049f4:	46bd      	mov	sp, r7
200049f6:	bd80      	pop	{r7, pc}

200049f8 <_atoi_r>:
200049f8:	2200      	movs	r2, #0
200049fa:	230a      	movs	r3, #10
200049fc:	f000 b8c8 	b.w	20004b90 <_strtol_r>

20004a00 <atoi>:
20004a00:	2100      	movs	r1, #0
20004a02:	220a      	movs	r2, #10
20004a04:	f000 b964 	b.w	20004cd0 <strtol>

20004a08 <__libc_init_array>:
20004a08:	b570      	push	{r4, r5, r6, lr}
20004a0a:	f245 06f0 	movw	r6, #20720	; 0x50f0
20004a0e:	f245 05f0 	movw	r5, #20720	; 0x50f0
20004a12:	f2c2 0600 	movt	r6, #8192	; 0x2000
20004a16:	f2c2 0500 	movt	r5, #8192	; 0x2000
20004a1a:	1b76      	subs	r6, r6, r5
20004a1c:	10b6      	asrs	r6, r6, #2
20004a1e:	d006      	beq.n	20004a2e <__libc_init_array+0x26>
20004a20:	2400      	movs	r4, #0
20004a22:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
20004a26:	3401      	adds	r4, #1
20004a28:	4798      	blx	r3
20004a2a:	42a6      	cmp	r6, r4
20004a2c:	d8f9      	bhi.n	20004a22 <__libc_init_array+0x1a>
20004a2e:	f245 05f0 	movw	r5, #20720	; 0x50f0
20004a32:	f245 06f4 	movw	r6, #20724	; 0x50f4
20004a36:	f2c2 0500 	movt	r5, #8192	; 0x2000
20004a3a:	f2c2 0600 	movt	r6, #8192	; 0x2000
20004a3e:	1b76      	subs	r6, r6, r5
20004a40:	f000 fb4a 	bl	200050d8 <_init>
20004a44:	10b6      	asrs	r6, r6, #2
20004a46:	d006      	beq.n	20004a56 <__libc_init_array+0x4e>
20004a48:	2400      	movs	r4, #0
20004a4a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
20004a4e:	3401      	adds	r4, #1
20004a50:	4798      	blx	r3
20004a52:	42a6      	cmp	r6, r4
20004a54:	d8f9      	bhi.n	20004a4a <__libc_init_array+0x42>
20004a56:	bd70      	pop	{r4, r5, r6, pc}

20004a58 <memcmp>:
20004a58:	2a03      	cmp	r2, #3
20004a5a:	b430      	push	{r4, r5}
20004a5c:	4605      	mov	r5, r0
20004a5e:	460c      	mov	r4, r1
20004a60:	d925      	bls.n	20004aae <memcmp+0x56>
20004a62:	ea41 0300 	orr.w	r3, r1, r0
20004a66:	f013 0f03 	tst.w	r3, #3
20004a6a:	d015      	beq.n	20004a98 <memcmp+0x40>
20004a6c:	7828      	ldrb	r0, [r5, #0]
20004a6e:	f894 c000 	ldrb.w	ip, [r4]
20004a72:	4560      	cmp	r0, ip
20004a74:	d11e      	bne.n	20004ab4 <memcmp+0x5c>
20004a76:	3a01      	subs	r2, #1
20004a78:	2300      	movs	r3, #0
20004a7a:	e006      	b.n	20004a8a <memcmp+0x32>
20004a7c:	7840      	ldrb	r0, [r0, #1]
20004a7e:	3301      	adds	r3, #1
20004a80:	f891 c001 	ldrb.w	ip, [r1, #1]
20004a84:	3a01      	subs	r2, #1
20004a86:	4560      	cmp	r0, ip
20004a88:	d114      	bne.n	20004ab4 <memcmp+0x5c>
20004a8a:	18e8      	adds	r0, r5, r3
20004a8c:	18e1      	adds	r1, r4, r3
20004a8e:	2a00      	cmp	r2, #0
20004a90:	d1f4      	bne.n	20004a7c <memcmp+0x24>
20004a92:	2000      	movs	r0, #0
20004a94:	bc30      	pop	{r4, r5}
20004a96:	4770      	bx	lr
20004a98:	6804      	ldr	r4, [r0, #0]
20004a9a:	680b      	ldr	r3, [r1, #0]
20004a9c:	429c      	cmp	r4, r3
20004a9e:	d104      	bne.n	20004aaa <memcmp+0x52>
20004aa0:	3a04      	subs	r2, #4
20004aa2:	3004      	adds	r0, #4
20004aa4:	3104      	adds	r1, #4
20004aa6:	2a03      	cmp	r2, #3
20004aa8:	d8f6      	bhi.n	20004a98 <memcmp+0x40>
20004aaa:	4605      	mov	r5, r0
20004aac:	460c      	mov	r4, r1
20004aae:	2a00      	cmp	r2, #0
20004ab0:	d1dc      	bne.n	20004a6c <memcmp+0x14>
20004ab2:	e7ee      	b.n	20004a92 <memcmp+0x3a>
20004ab4:	ebcc 0000 	rsb	r0, ip, r0
20004ab8:	e7ec      	b.n	20004a94 <memcmp+0x3c>
20004aba:	bf00      	nop

20004abc <memset>:
20004abc:	2a03      	cmp	r2, #3
20004abe:	b2c9      	uxtb	r1, r1
20004ac0:	b430      	push	{r4, r5}
20004ac2:	d807      	bhi.n	20004ad4 <memset+0x18>
20004ac4:	b122      	cbz	r2, 20004ad0 <memset+0x14>
20004ac6:	2300      	movs	r3, #0
20004ac8:	54c1      	strb	r1, [r0, r3]
20004aca:	3301      	adds	r3, #1
20004acc:	4293      	cmp	r3, r2
20004ace:	d1fb      	bne.n	20004ac8 <memset+0xc>
20004ad0:	bc30      	pop	{r4, r5}
20004ad2:	4770      	bx	lr
20004ad4:	eb00 0c02 	add.w	ip, r0, r2
20004ad8:	4603      	mov	r3, r0
20004ada:	e001      	b.n	20004ae0 <memset+0x24>
20004adc:	f803 1c01 	strb.w	r1, [r3, #-1]
20004ae0:	f003 0403 	and.w	r4, r3, #3
20004ae4:	461a      	mov	r2, r3
20004ae6:	3301      	adds	r3, #1
20004ae8:	2c00      	cmp	r4, #0
20004aea:	d1f7      	bne.n	20004adc <memset+0x20>
20004aec:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
20004af0:	ebc2 040c 	rsb	r4, r2, ip
20004af4:	fb03 f301 	mul.w	r3, r3, r1
20004af8:	e01f      	b.n	20004b3a <memset+0x7e>
20004afa:	f842 3c40 	str.w	r3, [r2, #-64]
20004afe:	f842 3c3c 	str.w	r3, [r2, #-60]
20004b02:	f842 3c38 	str.w	r3, [r2, #-56]
20004b06:	f842 3c34 	str.w	r3, [r2, #-52]
20004b0a:	f842 3c30 	str.w	r3, [r2, #-48]
20004b0e:	f842 3c2c 	str.w	r3, [r2, #-44]
20004b12:	f842 3c28 	str.w	r3, [r2, #-40]
20004b16:	f842 3c24 	str.w	r3, [r2, #-36]
20004b1a:	f842 3c20 	str.w	r3, [r2, #-32]
20004b1e:	f842 3c1c 	str.w	r3, [r2, #-28]
20004b22:	f842 3c18 	str.w	r3, [r2, #-24]
20004b26:	f842 3c14 	str.w	r3, [r2, #-20]
20004b2a:	f842 3c10 	str.w	r3, [r2, #-16]
20004b2e:	f842 3c0c 	str.w	r3, [r2, #-12]
20004b32:	f842 3c08 	str.w	r3, [r2, #-8]
20004b36:	f842 3c04 	str.w	r3, [r2, #-4]
20004b3a:	4615      	mov	r5, r2
20004b3c:	3240      	adds	r2, #64	; 0x40
20004b3e:	2c3f      	cmp	r4, #63	; 0x3f
20004b40:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
20004b44:	dcd9      	bgt.n	20004afa <memset+0x3e>
20004b46:	462a      	mov	r2, r5
20004b48:	ebc5 040c 	rsb	r4, r5, ip
20004b4c:	e007      	b.n	20004b5e <memset+0xa2>
20004b4e:	f842 3c10 	str.w	r3, [r2, #-16]
20004b52:	f842 3c0c 	str.w	r3, [r2, #-12]
20004b56:	f842 3c08 	str.w	r3, [r2, #-8]
20004b5a:	f842 3c04 	str.w	r3, [r2, #-4]
20004b5e:	4615      	mov	r5, r2
20004b60:	3210      	adds	r2, #16
20004b62:	2c0f      	cmp	r4, #15
20004b64:	f1a4 0410 	sub.w	r4, r4, #16
20004b68:	dcf1      	bgt.n	20004b4e <memset+0x92>
20004b6a:	462a      	mov	r2, r5
20004b6c:	ebc5 050c 	rsb	r5, r5, ip
20004b70:	e001      	b.n	20004b76 <memset+0xba>
20004b72:	f842 3c04 	str.w	r3, [r2, #-4]
20004b76:	4614      	mov	r4, r2
20004b78:	3204      	adds	r2, #4
20004b7a:	2d03      	cmp	r5, #3
20004b7c:	f1a5 0504 	sub.w	r5, r5, #4
20004b80:	dcf7      	bgt.n	20004b72 <memset+0xb6>
20004b82:	e001      	b.n	20004b88 <memset+0xcc>
20004b84:	f804 1b01 	strb.w	r1, [r4], #1
20004b88:	4564      	cmp	r4, ip
20004b8a:	d3fb      	bcc.n	20004b84 <memset+0xc8>
20004b8c:	e7a0      	b.n	20004ad0 <memset+0x14>
20004b8e:	bf00      	nop

20004b90 <_strtol_r>:
20004b90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
20004b94:	f245 2540 	movw	r5, #21056	; 0x5240
20004b98:	f2c2 0500 	movt	r5, #8192	; 0x2000
20004b9c:	b083      	sub	sp, #12
20004b9e:	460c      	mov	r4, r1
20004ba0:	461f      	mov	r7, r3
20004ba2:	f8d5 8000 	ldr.w	r8, [r5]
20004ba6:	460e      	mov	r6, r1
20004ba8:	9001      	str	r0, [sp, #4]
20004baa:	9200      	str	r2, [sp, #0]
20004bac:	f816 5b01 	ldrb.w	r5, [r6], #1
20004bb0:	eb08 0305 	add.w	r3, r8, r5
20004bb4:	f893 b001 	ldrb.w	fp, [r3, #1]
20004bb8:	f01b 0b08 	ands.w	fp, fp, #8
20004bbc:	d1f6      	bne.n	20004bac <_strtol_r+0x1c>
20004bbe:	2d2d      	cmp	r5, #45	; 0x2d
20004bc0:	d065      	beq.n	20004c8e <_strtol_r+0xfe>
20004bc2:	2d2b      	cmp	r5, #43	; 0x2b
20004bc4:	bf08      	it	eq
20004bc6:	f816 5b01 	ldrbeq.w	r5, [r6], #1
20004bca:	f1d7 0301 	rsbs	r3, r7, #1
20004bce:	bf38      	it	cc
20004bd0:	2300      	movcc	r3, #0
20004bd2:	2f10      	cmp	r7, #16
20004bd4:	bf14      	ite	ne
20004bd6:	461a      	movne	r2, r3
20004bd8:	f043 0201 	orreq.w	r2, r3, #1
20004bdc:	b132      	cbz	r2, 20004bec <_strtol_r+0x5c>
20004bde:	2d30      	cmp	r5, #48	; 0x30
20004be0:	d066      	beq.n	20004cb0 <_strtol_r+0x120>
20004be2:	b11b      	cbz	r3, 20004bec <_strtol_r+0x5c>
20004be4:	2d30      	cmp	r5, #48	; 0x30
20004be6:	bf0c      	ite	eq
20004be8:	2708      	moveq	r7, #8
20004bea:	270a      	movne	r7, #10
20004bec:	f1bb 0f00 	cmp.w	fp, #0
20004bf0:	4639      	mov	r1, r7
20004bf2:	bf14      	ite	ne
20004bf4:	f04f 4900 	movne.w	r9, #2147483648	; 0x80000000
20004bf8:	f06f 4900 	mvneq.w	r9, #2147483648	; 0x80000000
20004bfc:	4648      	mov	r0, r9
20004bfe:	f000 f9a1 	bl	20004f44 <__aeabi_uidivmod>
20004c02:	4648      	mov	r0, r9
20004c04:	468a      	mov	sl, r1
20004c06:	4639      	mov	r1, r7
20004c08:	f000 f86e 	bl	20004ce8 <__aeabi_uidiv>
20004c0c:	2100      	movs	r1, #0
20004c0e:	468c      	mov	ip, r1
20004c10:	eb08 0205 	add.w	r2, r8, r5
20004c14:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
20004c18:	7852      	ldrb	r2, [r2, #1]
20004c1a:	f012 0f04 	tst.w	r2, #4
20004c1e:	d108      	bne.n	20004c32 <_strtol_r+0xa2>
20004c20:	f012 0f03 	tst.w	r2, #3
20004c24:	d020      	beq.n	20004c68 <_strtol_r+0xd8>
20004c26:	f012 0f01 	tst.w	r2, #1
20004c2a:	bf14      	ite	ne
20004c2c:	2337      	movne	r3, #55	; 0x37
20004c2e:	2357      	moveq	r3, #87	; 0x57
20004c30:	1aeb      	subs	r3, r5, r3
20004c32:	429f      	cmp	r7, r3
20004c34:	dd18      	ble.n	20004c68 <_strtol_r+0xd8>
20004c36:	4584      	cmp	ip, r0
20004c38:	bf94      	ite	ls
20004c3a:	2200      	movls	r2, #0
20004c3c:	2201      	movhi	r2, #1
20004c3e:	ea52 71d1 	orrs.w	r1, r2, r1, lsr #31
20004c42:	f04f 31ff 	mov.w	r1, #4294967295
20004c46:	d10c      	bne.n	20004c62 <_strtol_r+0xd2>
20004c48:	4584      	cmp	ip, r0
20004c4a:	bf14      	ite	ne
20004c4c:	2200      	movne	r2, #0
20004c4e:	2201      	moveq	r2, #1
20004c50:	4553      	cmp	r3, sl
20004c52:	bfd4      	ite	le
20004c54:	2200      	movle	r2, #0
20004c56:	f002 0201 	andgt.w	r2, r2, #1
20004c5a:	b912      	cbnz	r2, 20004c62 <_strtol_r+0xd2>
20004c5c:	fb07 3c0c 	mla	ip, r7, ip, r3
20004c60:	2101      	movs	r1, #1
20004c62:	f816 5b01 	ldrb.w	r5, [r6], #1
20004c66:	e7d3      	b.n	20004c10 <_strtol_r+0x80>
20004c68:	f1b1 3fff 	cmp.w	r1, #4294967295
20004c6c:	d014      	beq.n	20004c98 <_strtol_r+0x108>
20004c6e:	f1bb 0f00 	cmp.w	fp, #0
20004c72:	d109      	bne.n	20004c88 <_strtol_r+0xf8>
20004c74:	4660      	mov	r0, ip
20004c76:	9b00      	ldr	r3, [sp, #0]
20004c78:	b11b      	cbz	r3, 20004c82 <_strtol_r+0xf2>
20004c7a:	b101      	cbz	r1, 20004c7e <_strtol_r+0xee>
20004c7c:	1e74      	subs	r4, r6, #1
20004c7e:	9a00      	ldr	r2, [sp, #0]
20004c80:	6014      	str	r4, [r2, #0]
20004c82:	b003      	add	sp, #12
20004c84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
20004c88:	f1cc 0000 	rsb	r0, ip, #0
20004c8c:	e7f3      	b.n	20004c76 <_strtol_r+0xe6>
20004c8e:	f816 5b01 	ldrb.w	r5, [r6], #1
20004c92:	f04f 0b01 	mov.w	fp, #1
20004c96:	e798      	b.n	20004bca <_strtol_r+0x3a>
20004c98:	9a01      	ldr	r2, [sp, #4]
20004c9a:	f1bb 0f00 	cmp.w	fp, #0
20004c9e:	f04f 0322 	mov.w	r3, #34	; 0x22
20004ca2:	bf14      	ite	ne
20004ca4:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
20004ca8:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
20004cac:	6013      	str	r3, [r2, #0]
20004cae:	e7e2      	b.n	20004c76 <_strtol_r+0xe6>
20004cb0:	7832      	ldrb	r2, [r6, #0]
20004cb2:	2a78      	cmp	r2, #120	; 0x78
20004cb4:	bf14      	ite	ne
20004cb6:	2100      	movne	r1, #0
20004cb8:	2101      	moveq	r1, #1
20004cba:	2a58      	cmp	r2, #88	; 0x58
20004cbc:	bf14      	ite	ne
20004cbe:	460a      	movne	r2, r1
20004cc0:	f041 0201 	orreq.w	r2, r1, #1
20004cc4:	2a00      	cmp	r2, #0
20004cc6:	d08c      	beq.n	20004be2 <_strtol_r+0x52>
20004cc8:	7875      	ldrb	r5, [r6, #1]
20004cca:	2710      	movs	r7, #16
20004ccc:	3602      	adds	r6, #2
20004cce:	e78d      	b.n	20004bec <_strtol_r+0x5c>

20004cd0 <strtol>:
20004cd0:	b410      	push	{r4}
20004cd2:	f245 1448 	movw	r4, #20808	; 0x5148
20004cd6:	f2c2 0400 	movt	r4, #8192	; 0x2000
20004cda:	468c      	mov	ip, r1
20004cdc:	4613      	mov	r3, r2
20004cde:	4601      	mov	r1, r0
20004ce0:	4662      	mov	r2, ip
20004ce2:	6820      	ldr	r0, [r4, #0]
20004ce4:	bc10      	pop	{r4}
20004ce6:	e753      	b.n	20004b90 <_strtol_r>

20004ce8 <__aeabi_uidiv>:
20004ce8:	1e4a      	subs	r2, r1, #1
20004cea:	bf08      	it	eq
20004cec:	4770      	bxeq	lr
20004cee:	f0c0 8124 	bcc.w	20004f3a <__aeabi_uidiv+0x252>
20004cf2:	4288      	cmp	r0, r1
20004cf4:	f240 8116 	bls.w	20004f24 <__aeabi_uidiv+0x23c>
20004cf8:	4211      	tst	r1, r2
20004cfa:	f000 8117 	beq.w	20004f2c <__aeabi_uidiv+0x244>
20004cfe:	fab0 f380 	clz	r3, r0
20004d02:	fab1 f281 	clz	r2, r1
20004d06:	eba2 0303 	sub.w	r3, r2, r3
20004d0a:	f1c3 031f 	rsb	r3, r3, #31
20004d0e:	a204      	add	r2, pc, #16	; (adr r2, 20004d20 <__aeabi_uidiv+0x38>)
20004d10:	eb02 1303 	add.w	r3, r2, r3, lsl #4
20004d14:	f04f 0200 	mov.w	r2, #0
20004d18:	469f      	mov	pc, r3
20004d1a:	bf00      	nop
20004d1c:	f3af 8000 	nop.w
20004d20:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
20004d24:	bf00      	nop
20004d26:	eb42 0202 	adc.w	r2, r2, r2
20004d2a:	bf28      	it	cs
20004d2c:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
20004d30:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
20004d34:	bf00      	nop
20004d36:	eb42 0202 	adc.w	r2, r2, r2
20004d3a:	bf28      	it	cs
20004d3c:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
20004d40:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
20004d44:	bf00      	nop
20004d46:	eb42 0202 	adc.w	r2, r2, r2
20004d4a:	bf28      	it	cs
20004d4c:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
20004d50:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
20004d54:	bf00      	nop
20004d56:	eb42 0202 	adc.w	r2, r2, r2
20004d5a:	bf28      	it	cs
20004d5c:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
20004d60:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
20004d64:	bf00      	nop
20004d66:	eb42 0202 	adc.w	r2, r2, r2
20004d6a:	bf28      	it	cs
20004d6c:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
20004d70:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
20004d74:	bf00      	nop
20004d76:	eb42 0202 	adc.w	r2, r2, r2
20004d7a:	bf28      	it	cs
20004d7c:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
20004d80:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
20004d84:	bf00      	nop
20004d86:	eb42 0202 	adc.w	r2, r2, r2
20004d8a:	bf28      	it	cs
20004d8c:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
20004d90:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
20004d94:	bf00      	nop
20004d96:	eb42 0202 	adc.w	r2, r2, r2
20004d9a:	bf28      	it	cs
20004d9c:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
20004da0:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
20004da4:	bf00      	nop
20004da6:	eb42 0202 	adc.w	r2, r2, r2
20004daa:	bf28      	it	cs
20004dac:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
20004db0:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
20004db4:	bf00      	nop
20004db6:	eb42 0202 	adc.w	r2, r2, r2
20004dba:	bf28      	it	cs
20004dbc:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
20004dc0:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
20004dc4:	bf00      	nop
20004dc6:	eb42 0202 	adc.w	r2, r2, r2
20004dca:	bf28      	it	cs
20004dcc:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
20004dd0:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
20004dd4:	bf00      	nop
20004dd6:	eb42 0202 	adc.w	r2, r2, r2
20004dda:	bf28      	it	cs
20004ddc:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
20004de0:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
20004de4:	bf00      	nop
20004de6:	eb42 0202 	adc.w	r2, r2, r2
20004dea:	bf28      	it	cs
20004dec:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
20004df0:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
20004df4:	bf00      	nop
20004df6:	eb42 0202 	adc.w	r2, r2, r2
20004dfa:	bf28      	it	cs
20004dfc:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
20004e00:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
20004e04:	bf00      	nop
20004e06:	eb42 0202 	adc.w	r2, r2, r2
20004e0a:	bf28      	it	cs
20004e0c:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
20004e10:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
20004e14:	bf00      	nop
20004e16:	eb42 0202 	adc.w	r2, r2, r2
20004e1a:	bf28      	it	cs
20004e1c:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
20004e20:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
20004e24:	bf00      	nop
20004e26:	eb42 0202 	adc.w	r2, r2, r2
20004e2a:	bf28      	it	cs
20004e2c:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
20004e30:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
20004e34:	bf00      	nop
20004e36:	eb42 0202 	adc.w	r2, r2, r2
20004e3a:	bf28      	it	cs
20004e3c:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
20004e40:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
20004e44:	bf00      	nop
20004e46:	eb42 0202 	adc.w	r2, r2, r2
20004e4a:	bf28      	it	cs
20004e4c:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
20004e50:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
20004e54:	bf00      	nop
20004e56:	eb42 0202 	adc.w	r2, r2, r2
20004e5a:	bf28      	it	cs
20004e5c:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
20004e60:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
20004e64:	bf00      	nop
20004e66:	eb42 0202 	adc.w	r2, r2, r2
20004e6a:	bf28      	it	cs
20004e6c:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
20004e70:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
20004e74:	bf00      	nop
20004e76:	eb42 0202 	adc.w	r2, r2, r2
20004e7a:	bf28      	it	cs
20004e7c:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
20004e80:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
20004e84:	bf00      	nop
20004e86:	eb42 0202 	adc.w	r2, r2, r2
20004e8a:	bf28      	it	cs
20004e8c:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
20004e90:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
20004e94:	bf00      	nop
20004e96:	eb42 0202 	adc.w	r2, r2, r2
20004e9a:	bf28      	it	cs
20004e9c:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
20004ea0:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
20004ea4:	bf00      	nop
20004ea6:	eb42 0202 	adc.w	r2, r2, r2
20004eaa:	bf28      	it	cs
20004eac:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
20004eb0:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
20004eb4:	bf00      	nop
20004eb6:	eb42 0202 	adc.w	r2, r2, r2
20004eba:	bf28      	it	cs
20004ebc:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
20004ec0:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
20004ec4:	bf00      	nop
20004ec6:	eb42 0202 	adc.w	r2, r2, r2
20004eca:	bf28      	it	cs
20004ecc:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
20004ed0:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
20004ed4:	bf00      	nop
20004ed6:	eb42 0202 	adc.w	r2, r2, r2
20004eda:	bf28      	it	cs
20004edc:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
20004ee0:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
20004ee4:	bf00      	nop
20004ee6:	eb42 0202 	adc.w	r2, r2, r2
20004eea:	bf28      	it	cs
20004eec:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
20004ef0:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
20004ef4:	bf00      	nop
20004ef6:	eb42 0202 	adc.w	r2, r2, r2
20004efa:	bf28      	it	cs
20004efc:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
20004f00:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
20004f04:	bf00      	nop
20004f06:	eb42 0202 	adc.w	r2, r2, r2
20004f0a:	bf28      	it	cs
20004f0c:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
20004f10:	ebb0 0f01 	cmp.w	r0, r1
20004f14:	bf00      	nop
20004f16:	eb42 0202 	adc.w	r2, r2, r2
20004f1a:	bf28      	it	cs
20004f1c:	eba0 0001 	subcs.w	r0, r0, r1
20004f20:	4610      	mov	r0, r2
20004f22:	4770      	bx	lr
20004f24:	bf0c      	ite	eq
20004f26:	2001      	moveq	r0, #1
20004f28:	2000      	movne	r0, #0
20004f2a:	4770      	bx	lr
20004f2c:	fab1 f281 	clz	r2, r1
20004f30:	f1c2 021f 	rsb	r2, r2, #31
20004f34:	fa20 f002 	lsr.w	r0, r0, r2
20004f38:	4770      	bx	lr
20004f3a:	b108      	cbz	r0, 20004f40 <__aeabi_uidiv+0x258>
20004f3c:	f04f 30ff 	mov.w	r0, #4294967295
20004f40:	f000 b80e 	b.w	20004f60 <__aeabi_idiv0>

20004f44 <__aeabi_uidivmod>:
20004f44:	2900      	cmp	r1, #0
20004f46:	d0f8      	beq.n	20004f3a <__aeabi_uidiv+0x252>
20004f48:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
20004f4c:	f7ff fecc 	bl	20004ce8 <__aeabi_uidiv>
20004f50:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
20004f54:	fb02 f300 	mul.w	r3, r2, r0
20004f58:	eba1 0103 	sub.w	r1, r1, r3
20004f5c:	4770      	bx	lr
20004f5e:	bf00      	nop

20004f60 <__aeabi_idiv0>:
20004f60:	4770      	bx	lr
20004f62:	bf00      	nop

20004f64 <gp_my_uart>:
20004f64:	8534 2000 0946 0000 0953 0000 0061 0000     4.. F...S...a...
20004f74:	0064 0000 0068 0000 006b 0000 0072 0000     d...h...k...r...
20004f84:	006d 0000 007a 0000 2049 6168 6576 6220     m...z...I have b
20004f94:	6565 206e 6572 6f63 6576 6572 2064 6977     een recovered wi
20004fa4:	6874 3520 4d30 5a48 000a 0000 0070 0000     th 50MHZ....p...
20004fb4:	0071 0000 0062 0000 006e 0000               q...b...n...

20004fc0 <C.31.5392>:
20004fc0:	ab90 0000                                   ....

20004fc4 <C.34.5399>:
20004fc4:	6411 0000                                   .d..

20004fc8 <C.18.3527>:
20004fc8:	0100 0100 0202 0303 0043 0000               ........C...

20004fd4 <_ctype_>:
20004fd4:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
20004fe4:	2020 2020 2020 2020 2020 2020 2020 2020                     
20004ff4:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
20005004:	0410 0404 0404 0404 0404 1004 1010 1010     ................
20005014:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
20005024:	0101 0101 0101 0101 0101 0101 1010 1010     ................
20005034:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
20005044:	0202 0202 0202 0202 0202 0202 1010 1010     ................
20005054:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

200050d8 <_init>:
200050d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
200050da:	bf00      	nop
200050dc:	bcf8      	pop	{r3, r4, r5, r6, r7}
200050de:	bc08      	pop	{r3}
200050e0:	469e      	mov	lr, r3
200050e2:	4770      	bx	lr

200050e4 <_fini>:
200050e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
200050e6:	bf00      	nop
200050e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
200050ea:	bc08      	pop	{r3}
200050ec:	469e      	mov	lr, r3
200050ee:	4770      	bx	lr

200050f0 <__frame_dummy_init_array_entry>:
200050f0:	04d5 2000                                   ... 

200050f4 <__do_global_dtors_aux_fini_array_entry>:
200050f4:	04c1 2000 0000 0000 0000 0000               ... ........
